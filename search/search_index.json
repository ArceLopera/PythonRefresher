{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Python Refresher Everyone can forget about grammar and vocabulary. The most important think is to know where to look. Sections Basics Machine Learning Algorithms Exercises","title":"Home"},{"location":"#welcome-to-python-refresher","text":"Everyone can forget about grammar and vocabulary. The most important think is to know where to look.","title":"Welcome to Python Refresher"},{"location":"#sections","text":"Basics Machine Learning Algorithms Exercises","title":"Sections"},{"location":"pythonRefresh/","text":"Python is strongly typed (i.e. types are enforced), dynamically, implicitly typed (i.e. you don\u2019t have to declare variables), case sensitive (i.e. var and VAR are two different variables) and object-oriented (i.e. everything is an object, Like C# and Java). A unique aspect of the Python language: indentation. While a language like C uses curly braces to contain code statements within loops or conditionals, Python indicates these statements through indentation. This feature lends Python code readability. Notice the colon at the end of the expression in the for, while and if statement. Python Resources Free e-book Python Like You Mean It , by Ryan Soklaski, will provide a more comprehensive introduction to Python for scientific computing. The website http://www.python.org , Tutorial and doc","title":"General"},{"location":"pythonRefresh/#python-resources","text":"Free e-book Python Like You Mean It , by Ryan Soklaski, will provide a more comprehensive introduction to Python for scientific computing. The website http://www.python.org , Tutorial and doc","title":"Python Resources"},{"location":"DS/pyDS/","text":"Python Collections Iterable Anything that you can loop over using a for loop e.g: list, tuples, strings, set and dictionaries Sequence a subset of Iterables that have: 1. A length 2. An Index 3. Can be sliced e.g: Strings, list, tuples Not dictionaries, sets, files and generators Data Structures Python supports the following data structures: lists, dictionaries, tuples, sets. For arrays, see numpy array. When to use a dictionary: - When you need a logical association between a key:value pair. - When you need fast lookup for your data, based on a custom key. - When your data is being constantly modified. Remember, dictionaries are mutable. When to use the other types: - Use lists if you have a collection of data that does not need random access. Try to choose lists when you need a simple, iterable collection that is modified frequently. - Use a set if you need uniqueness for the elements. - Use tuples when your data cannot change. Many times, a tuple is used in combination with a dictionary, for example, a tuple might represent a key, because it's immutable. Tuples Lists Dict Sets ( ) [ ] {k:v} { } Immutable Mutable Mutable Mutable Ordered Ordered Ordered(>3.7) Unordered Iterable Iterable Iterable Iterable Constant time Linear time Constant time Constant time mytuple[0] mylist[0] mydict['somekey'] myset[0] Allow repetition Allow repetition Allow repetition Unique data len(mytuple) len(mylist) len(mydict) len(myset) .count() .append() and .insert() .keys(), .values() and .items() .add() and .update() .index() .pop() and .remove() .pop() or del mydict['somekey'] .remove() .reverse() and sort()","title":"General"},{"location":"DS/pyDS/#python-collections","text":"","title":"Python Collections"},{"location":"DS/pyDS/#iterable","text":"Anything that you can loop over using a for loop e.g: list, tuples, strings, set and dictionaries","title":"Iterable"},{"location":"DS/pyDS/#sequence","text":"a subset of Iterables that have: 1. A length 2. An Index 3. Can be sliced e.g: Strings, list, tuples Not dictionaries, sets, files and generators","title":"Sequence"},{"location":"DS/pyDS/#data-structures","text":"Python supports the following data structures: lists, dictionaries, tuples, sets. For arrays, see numpy array. When to use a dictionary: - When you need a logical association between a key:value pair. - When you need fast lookup for your data, based on a custom key. - When your data is being constantly modified. Remember, dictionaries are mutable. When to use the other types: - Use lists if you have a collection of data that does not need random access. Try to choose lists when you need a simple, iterable collection that is modified frequently. - Use a set if you need uniqueness for the elements. - Use tuples when your data cannot change. Many times, a tuple is used in combination with a dictionary, for example, a tuple might represent a key, because it's immutable. Tuples Lists Dict Sets ( ) [ ] {k:v} { } Immutable Mutable Mutable Mutable Ordered Ordered Ordered(>3.7) Unordered Iterable Iterable Iterable Iterable Constant time Linear time Constant time Constant time mytuple[0] mylist[0] mydict['somekey'] myset[0] Allow repetition Allow repetition Allow repetition Unique data len(mytuple) len(mylist) len(mydict) len(myset) .count() .append() and .insert() .keys(), .values() and .items() .add() and .update() .index() .pop() and .remove() .pop() or del mydict['somekey'] .remove() .reverse() and sort()","title":"Data Structures"},{"location":"DS/pyDict/","text":"Since you've seen parenthesis (for tuples) and square brackets (for lists), you may be wondering what curly braces are used for in Python. The answer: Python dictionaries. The defining feature of a Python dictionary is that it has keys and values that are associated with each other. When defining a dictionary, this association may be accomplished using the colon (:) as is done below. Dictionaries are data structures used to map arbitrary keys to values. Lists can be thought of as dictionaries with integer keys within a certain range. Dictionaries can be indexed in the same way as lists, using square brackets containing keys. Dict Creation An empty dictionary is defined as {}. Dictionary can also be created by the built-in function dict(). # Creating an empty Dictionary Dict = {} print ( \"Empty Dictionary: \" ) print ( Dict ) # Creating a Dictionary # with dict() method Dict = dict ({ 1 : 'Trips' , 2 : 'For' , 3 : 'chips' }) print ( \" \\n Dictionary with the use of dict(): \" ) print ( Dict ) # Creating a Dictionary # with each item as a Pair Dict = dict ([( 1 , 'Trips' ), ( 2 , 'For' )]) print ( \" \\n Dictionary with each item as a pair: \" ) print ( Dict ) Empty Dictionary: {} Dictionary with the use of dict(): {1: 'Trips', 2: 'For', 3: 'chips'} Dictionary with each item as a pair: {1: 'Trips', 2: 'For'} Dict = {} #Set default value Dict . setdefault ( 1 , 'Trips' ) Dict . setdefault ( 3 , 'chips' ) print ( Dict ) {1: 'Trips', 3: 'chips'} empty_dic = {} book_dictionary = { \"Title\" : \"Frankenstein\" , \"Author\" : \"Mary Shelley\" , \"Year\" : 1818 } print ( book_dictionary [ \"Author\" ]) Mary Shelley Above, the keys of the book_dictionary are \"Title\", \"Author\", and \"Year\", and each of these keys has a corresponding value associated with it. Notice that the key-value pairs are separated by a comma. Using keys allows us to access a piece of the dictionary by its name, rather than needing to know the index of the piece that we want, as is the case with lists and tuples. For instance, above we could get the author of Frankenstein using the \"Author\" key, rather than using an index. In fact, unlike in a list or tuple, the order of elements in a dictionary doesn't matter, and dictionaries cannot be indexed using integers, which we see below when we try to access the second element of the dictionary using an integer: print ( book_dictionary [ 1 ]) --------------------------------------------------------------------------- KeyError Traceback (most recent call last) <ipython-input-11-43bbaea82a52> in <module>() ----> 1 print(book_dictionary[1]) KeyError: 1 Just like lists, dictionary keys can be assigned to different values. However, unlike lists, a new dictionary key can also be assigned a value, not just ones that already exist. squares = { 1 : 1 , 2 : 4 , 3 : \"Error\" , 4 : 16 ,} squares [ 8 ] = 64 squares [ 3 ] = 9 print ( squares ) {1: 1, 2: 4, 3: 9, 4: 16, 8: 64} in operator To determine whether a key is in a dictionary, you can use in and not in, just as you can for a list. nums = { 1 : \"one\" , 2 : \"two\" , 3 : \"three\" ,} print ( 1 in nums ) print ( \"three\" in nums ) print ( 4 not in nums ) True False True Dictionary Functions get() A useful dictionary method is get. It does the same thing as indexing, but if the key is not found in the dictionary it returns another specified value instead ('None', by default). pairs = { 1 : \"apple\" , \"orange\" :[ 2 , 3 , 4 ], True : False , None : \"True\" } print ( pairs . get ( \"orange\" )) print ( pairs . get ( 7 )) print ( pairs . get ( 12345 , \"not in dictionary\" )) ##Default message when not found fib = { 1 : 1 , 2 : 1 , 3 : 2 , 4 : 3 ,} print ( fib . get ( 4 , 0 ) + fib . get ( 7 , 5 )) [2, 3, 4] None not in dictionary 8 values() To iterate over the values of a dictionary, you can use the .values() function: for value in data . values (): pass Other funtions: copy() They copy() method returns a shallow copy of the dictionary. clear() The clear() method removes all items from the dictionary. pop() Removes and returns an element from a dictionary having the given key. popitem() Removes the arbitrary key-value pair from the dictionary and returns it as tuple. get() It is a conventional method to access a value for a key. dictionary_name.values() returns a list of all the values available in a given dictionary. str() Produces a printable string representation of a dictionary. update() Adds dictionary dict2\u2019s key-values pairs to dict setdefault() Set dict[key]=default if key is not already in dict keys() Returns list of dictionary dict\u2019s keys items() Returns a list of dict\u2019s (key, value) tuple pairs has_key() Returns true if key in dictionary dict, false otherwise fromkeys() Create a new dictionary with keys from seq and values set to value. type() Returns the type of the passed variable. cmp() Compares elements of both dict.","title":"Dictionary"},{"location":"DS/pyDict/#dict-creation","text":"An empty dictionary is defined as {}. Dictionary can also be created by the built-in function dict(). # Creating an empty Dictionary Dict = {} print ( \"Empty Dictionary: \" ) print ( Dict ) # Creating a Dictionary # with dict() method Dict = dict ({ 1 : 'Trips' , 2 : 'For' , 3 : 'chips' }) print ( \" \\n Dictionary with the use of dict(): \" ) print ( Dict ) # Creating a Dictionary # with each item as a Pair Dict = dict ([( 1 , 'Trips' ), ( 2 , 'For' )]) print ( \" \\n Dictionary with each item as a pair: \" ) print ( Dict ) Empty Dictionary: {} Dictionary with the use of dict(): {1: 'Trips', 2: 'For', 3: 'chips'} Dictionary with each item as a pair: {1: 'Trips', 2: 'For'} Dict = {} #Set default value Dict . setdefault ( 1 , 'Trips' ) Dict . setdefault ( 3 , 'chips' ) print ( Dict ) {1: 'Trips', 3: 'chips'} empty_dic = {} book_dictionary = { \"Title\" : \"Frankenstein\" , \"Author\" : \"Mary Shelley\" , \"Year\" : 1818 } print ( book_dictionary [ \"Author\" ]) Mary Shelley Above, the keys of the book_dictionary are \"Title\", \"Author\", and \"Year\", and each of these keys has a corresponding value associated with it. Notice that the key-value pairs are separated by a comma. Using keys allows us to access a piece of the dictionary by its name, rather than needing to know the index of the piece that we want, as is the case with lists and tuples. For instance, above we could get the author of Frankenstein using the \"Author\" key, rather than using an index. In fact, unlike in a list or tuple, the order of elements in a dictionary doesn't matter, and dictionaries cannot be indexed using integers, which we see below when we try to access the second element of the dictionary using an integer: print ( book_dictionary [ 1 ]) --------------------------------------------------------------------------- KeyError Traceback (most recent call last) <ipython-input-11-43bbaea82a52> in <module>() ----> 1 print(book_dictionary[1]) KeyError: 1 Just like lists, dictionary keys can be assigned to different values. However, unlike lists, a new dictionary key can also be assigned a value, not just ones that already exist. squares = { 1 : 1 , 2 : 4 , 3 : \"Error\" , 4 : 16 ,} squares [ 8 ] = 64 squares [ 3 ] = 9 print ( squares ) {1: 1, 2: 4, 3: 9, 4: 16, 8: 64}","title":"Dict Creation"},{"location":"DS/pyDict/#in-operator","text":"To determine whether a key is in a dictionary, you can use in and not in, just as you can for a list. nums = { 1 : \"one\" , 2 : \"two\" , 3 : \"three\" ,} print ( 1 in nums ) print ( \"three\" in nums ) print ( 4 not in nums ) True False True","title":"in operator"},{"location":"DS/pyDict/#dictionary-functions","text":"","title":"Dictionary Functions"},{"location":"DS/pyDict/#get","text":"A useful dictionary method is get. It does the same thing as indexing, but if the key is not found in the dictionary it returns another specified value instead ('None', by default). pairs = { 1 : \"apple\" , \"orange\" :[ 2 , 3 , 4 ], True : False , None : \"True\" } print ( pairs . get ( \"orange\" )) print ( pairs . get ( 7 )) print ( pairs . get ( 12345 , \"not in dictionary\" )) ##Default message when not found fib = { 1 : 1 , 2 : 1 , 3 : 2 , 4 : 3 ,} print ( fib . get ( 4 , 0 ) + fib . get ( 7 , 5 )) [2, 3, 4] None not in dictionary 8","title":"get()"},{"location":"DS/pyDict/#values","text":"To iterate over the values of a dictionary, you can use the .values() function: for value in data . values (): pass","title":"values()"},{"location":"DS/pyDict/#other-funtions","text":"copy() They copy() method returns a shallow copy of the dictionary. clear() The clear() method removes all items from the dictionary. pop() Removes and returns an element from a dictionary having the given key. popitem() Removes the arbitrary key-value pair from the dictionary and returns it as tuple. get() It is a conventional method to access a value for a key. dictionary_name.values() returns a list of all the values available in a given dictionary. str() Produces a printable string representation of a dictionary. update() Adds dictionary dict2\u2019s key-values pairs to dict setdefault() Set dict[key]=default if key is not already in dict keys() Returns list of dictionary dict\u2019s keys items() Returns a list of dict\u2019s (key, value) tuple pairs has_key() Returns true if key in dictionary dict, false otherwise fromkeys() Create a new dictionary with keys from seq and values set to value. type() Returns the type of the passed variable. cmp() Compares elements of both dict.","title":"Other funtions:"},{"location":"DS/pyIterAllAny/","text":"Often used in conditional statements, all and any take a list as an argument, and return True if all or any (respectively) of their arguments evaluate to True (and False otherwise). nums = [ 55 , 44 , 33 , 22 , 11 ,] if all ([ i > 5 for i in nums ]): print ( \"All larger than 5\" ) if any ([ i % 2 == 0 for i in nums ]): print ( \"At least one is even\" ) All larger than 5 At least one is even","title":"All & Any"},{"location":"DS/pyIterEnumerate/","text":"The function enumerate can be used to iterate through the values and indices of a list simultaneously. Enumerate() method adds a counter to an iterable and returns it in a form of enumerating object. This enumerated object can then be used directly for loops or converted into a list of tuples using the list() method. nums = [ 55 , 44 , 33 , 22 , 11 ,] #Without enumerate use index variable index = 0 for value in nums : print ( index , value ) index += 1 0 55 1 44 2 33 3 22 4 11 nums = [ 55 , 44 , 33 , 22 , 11 ,] #Using range and len for index in range ( len ( nums )): value = nums [ index ] print ( index , value ) 0 55 1 44 2 33 3 22 4 11 #using enumarate nums = [ 55 , 44 , 33 , 22 , 11 ,] for v in enumerate ( nums ): print ( v ) (0, 55) (1, 44) (2, 33) (3, 22) (4, 11) nums = [ 55 , 44 , 33 , 22 , 11 ,] for i , v in enumerate ( nums ): print ( f \"value { v } is at { i } position\" ) value 55 is at 0 position value 44 is at 1 position value 33 is at 2 position value 22 is at 3 position value 11 is at 4 position nums = [ 55 , 44 , 33 , 22 , 11 ,] for i , v in enumerate ( nums , start = 10 ): print ( f \"value { v } is at { i } position\" ) value 55 is at 10 position value 44 is at 11 position value 33 is at 12 position value 22 is at 13 position value 11 is at 14 position","title":"Enumerate"},{"location":"DS/pyIterMapFilter/","text":"The built-in functions map and filter are very useful higher-order functions that operate on lists (or similar objects called iterables). Map The function map takes a function and an iterable as arguments, and returns a new iterable with the function applied to each argument. def add_five ( x ): return x + 5 nums = [ 11 , 22 , 33 , 44 , 55 ] result = list ( map ( add_five , nums )) print ( result ) <class 'list'> [16, 27, 38, 49, 60] #the same using lambda syntax result = list ( map ( lambda x : x + 5 , nums )) print ( result ) [16, 27, 38, 49, 60] Filter The function filter filters an iterable by removing items that don't match a predicate (a function that returns a Boolean). Like map, the result has to be explicitly converted to a list if you want to print it. nums = [ 11 , 22 , 33 , 44 , 55 ] res = list ( filter ( lambda x : x % 2 == 0 , nums )) print ( res ) [22, 44] # use transform functions like sorted, filter, map def filterFunc ( x ): if x % 2 == 0 : return False return True def filterFunc2 ( x ): if x . isupper (): return False return True def squareFunc ( x ): return x ** 2 def toGrade ( x ): if ( x >= 90 ): return \"A\" elif ( x >= 80 and x < 90 ): return \"B\" elif ( x >= 70 and x < 80 ): return \"C\" elif ( x >= 65 and x < 70 ): return \"D\" return \"F\" def main (): # define some sample sequences to operate on nums = ( 1 , 8 , 4 , 5 , 13 , 26 , 381 , 410 , 58 , 47 ) chars = \"abcDeFGHiJklmnoP\" grades = ( 81 , 89 , 94 , 78 , 61 , 66 , 99 , 74 ) # use filter to remove items from a list odds = list ( filter ( filterFunc , nums )) print ( odds ) # use filter on non-numeric sequence lowers = list ( filter ( filterFunc2 , chars )) print ( lowers ) # use map to create a new sequence of values squares = list ( map ( squareFunc , nums )) print ( squares ) # use sorted and map to change numbers to grades grades = sorted ( grades ) letters = list ( map ( toGrade , grades )) print ( letters ) if __name__ == \"__main__\" : main () [1, 5, 13, 381, 47] ['a', 'b', 'c', 'e', 'i', 'k', 'l', 'm', 'n', 'o'] [1, 64, 16, 25, 169, 676, 145161, 168100, 3364, 2209] ['F', 'D', 'C', 'C', 'B', 'B', 'A', 'A']","title":"Map & Filter"},{"location":"DS/pyIterMapFilter/#map","text":"The function map takes a function and an iterable as arguments, and returns a new iterable with the function applied to each argument. def add_five ( x ): return x + 5 nums = [ 11 , 22 , 33 , 44 , 55 ] result = list ( map ( add_five , nums )) print ( result ) <class 'list'> [16, 27, 38, 49, 60] #the same using lambda syntax result = list ( map ( lambda x : x + 5 , nums )) print ( result ) [16, 27, 38, 49, 60]","title":"Map"},{"location":"DS/pyIterMapFilter/#filter","text":"The function filter filters an iterable by removing items that don't match a predicate (a function that returns a Boolean). Like map, the result has to be explicitly converted to a list if you want to print it. nums = [ 11 , 22 , 33 , 44 , 55 ] res = list ( filter ( lambda x : x % 2 == 0 , nums )) print ( res ) [22, 44] # use transform functions like sorted, filter, map def filterFunc ( x ): if x % 2 == 0 : return False return True def filterFunc2 ( x ): if x . isupper (): return False return True def squareFunc ( x ): return x ** 2 def toGrade ( x ): if ( x >= 90 ): return \"A\" elif ( x >= 80 and x < 90 ): return \"B\" elif ( x >= 70 and x < 80 ): return \"C\" elif ( x >= 65 and x < 70 ): return \"D\" return \"F\" def main (): # define some sample sequences to operate on nums = ( 1 , 8 , 4 , 5 , 13 , 26 , 381 , 410 , 58 , 47 ) chars = \"abcDeFGHiJklmnoP\" grades = ( 81 , 89 , 94 , 78 , 61 , 66 , 99 , 74 ) # use filter to remove items from a list odds = list ( filter ( filterFunc , nums )) print ( odds ) # use filter on non-numeric sequence lowers = list ( filter ( filterFunc2 , chars )) print ( lowers ) # use map to create a new sequence of values squares = list ( map ( squareFunc , nums )) print ( squares ) # use sorted and map to change numbers to grades grades = sorted ( grades ) letters = list ( map ( toGrade , grades )) print ( letters ) if __name__ == \"__main__\" : main () [1, 5, 13, 381, 47] ['a', 'b', 'c', 'e', 'i', 'k', 'l', 'm', 'n', 'o'] [1, 64, 16, 25, 169, 676, 145161, 168100, 3364, 2209] ['F', 'D', 'C', 'C', 'B', 'B', 'A', 'A']","title":"Filter"},{"location":"DS/pyIterReversed/","text":"Returns an iterator Python reversed() method returns an iterator that accesses the given sequence in the reverse order. 3 ways to reverse a sequence: iter.reverse() reverses a mutable sequence in place and is not available for inmutable sequences Slicing [::-1] creates a reversed copy of a sequence, it is the fastest but creates a copy of the sequence. Memory considerations to reverse millions of items. Used for both mutable and inmutable sequences. reversed() returns a reversed iterator, scales well to millions of items. Used for both mutable and inmutable sequences. # Python code to demonstrate working of # reversed() # For tuple seqTuple = ( 'm' , 'o' , 'r' , 'p' , 's' ) print ( list ( reversed ( seqTuple ))) # For range seqRange = range ( 1 , 5 ) print ( list ( reversed ( seqRange ))) ['s', 'p', 'r', 'o', 'm'] [4, 3, 2, 1] class pyp : vowels = [ 'a' , 'e' , 'i' , 'o' , 'u' ] # Function to reverse the list def __reversed__ ( self ): return reversed ( self . vowels ) ['u', 'o', 'i', 'e', 'a']","title":"Reversed"},{"location":"DS/pyIterSorted/","text":"Python sorted() function returns a sorted list from the iterable object. Sorted() sorts any sequence (list, tuple) and always returns a list with the elements in a sorted manner, without modifying the original sequence. x = [ 2 , 8 , 1 , 4 , 6 , 3 , 7 ] print ( \"Sorted List returned :\" ), print ( sorted ( x )) print ( \" \\n Reverse sort :\" ), print ( sorted ( x , reverse = True )) print ( \" \\n Original list not modified :\" ), print ( x ) Sorted List returned : [1, 2, 3, 4, 6, 7, 8] Reverse sort : [8, 7, 6, 4, 3, 2, 1] Original list not modified : [2, 8, 1, 4, 6, 3, 7] # List x = [ 'q' , 'w' , 'r' , 'e' , 't' , 'y' ] print ( f 'List : { sorted ( x ) } ' ) # Tuple x = ( 'q' , 'w' , 'e' , 'r' , 't' , 'y' ) print ( f 'Tuple : { sorted ( x ) } ' ) # String-sorted based on ASCII translations x = \"python\" print ( f 'String : { sorted ( x ) } ' ) # Dictionary x = { 'q' : 1 , 'w' : 2 , 'e' : 3 , 'r' : 4 , 't' : 5 , 'y' : 6 } print ( f 'Dict : { sorted ( x ) } ' ) # Set x = { 'q' , 'w' , 'e' , 'r' , 't' , 'y' } print ( f 'Set : { sorted ( x ) } ' ) # Frozen Set x = frozenset (( 'q' , 'w' , 'e' , 'r' , 't' , 'y' )) print ( f 'Frozen Set : { sorted ( x ) } ' ) List : ['e', 'q', 'r', 't', 'w', 'y'] Tuple : ['e', 'q', 'r', 't', 'w', 'y'] String : ['h', 'n', 'o', 'p', 't', 'y'] Dict : ['e', 'q', 'r', 't', 'w', 'y'] Set : ['e', 'q', 'r', 't', 'w', 'y'] Frozen Set : ['e', 'q', 'r', 't', 'w', 'y'] L = [ \"cccc\" , \"b\" , \"dd\" , \"aaa\" ] print ( \"Normal sort :\" , sorted ( L )) print ( \"Sort with len :\" , sorted ( L , key = len )) Normal sort : ['aaa', 'b', 'cccc', 'dd'] Sort with len : ['b', 'dd', 'aaa', 'cccc'] # Sort a list of integers based on # their remainder on dividing from 7 def func ( x ): return x % 7 L = [ 15 , 3 , 11 , 7 ] print ( \"Normal sort :\" , sorted ( L )) print ( \"Sorted with key:\" , sorted ( L , key = func )) Normal sort : [3, 7, 11, 15] Sorted with key: [7, 15, 3, 11]","title":"Sorted"},{"location":"DS/pyIterZip/","text":"Zip Python zip() method takes iterable or containers and returns a single iterator object, having mapped values from all the containers. It is used to map the similar index of multiple containers so that they can be used just using a single entity. name = [ \"Manjeet\" , \"Nikhil\" , \"Shambhavi\" , \"Astha\" ] roll_no = [ 4 , 1 , 3 , 2 ] # using zip() to map values mapped = zip ( name , roll_no ) print ( set ( mapped )) {('Shambhavi', 3), ('Nikhil', 1), ('Astha', 2), ('Manjeet', 4)} names = [ 'Mukesh' , 'Roni' , 'Chari' ] ages = [ 24 , 50 , 18 ] for i , ( name , age ) in enumerate ( zip ( names , ages )): print ( i , name , age ) 0 Mukesh 24 1 Roni 50 2 Chari 18 stocks = [ 'reliance' , 'infosys' , 'tcs' ] prices = [ 2175 , 1127 , 2750 ] new_dict = { stocks : prices for stocks , prices in zip ( stocks , prices )} print ( new_dict ) {'reliance': 2175, 'infosys': 1127, 'tcs': 2750} Unzip How to unzip? Unzipping means converting the zipped values back to the individual self as they were. This is done with the help of \u201c*\u201d operator. # Python code to demonstrate the working of # unzip # initializing lists name = [ \"Manjeet\" , \"Nikhil\" , \"Shambhavi\" , \"Astha\" ] roll_no = [ 4 , 1 , 3 , 2 ] marks = [ 40 , 50 , 60 , 70 ] # using zip() to map values mapped = zip ( name , roll_no , marks ) # converting values to print as list mapped = list ( mapped ) # printing resultant values print ( \"The zipped result is : \" , end = \"\" ) print ( mapped ) print ( \" \\n \" ) # unzipping values namz , roll_noz , marksz = zip ( * mapped ) print ( \"The unzipped result: \\n \" , end = \"\" ) # printing initial lists print ( \"The name list is : \" , end = \"\" ) print ( namz ) print ( \"The roll_no list is : \" , end = \"\" ) print ( roll_noz ) print ( \"The marks list is : \" , end = \"\" ) print ( marksz ) The zipped result is : [('Manjeet', 4, 40), ('Nikhil', 1, 50), ('Shambhavi', 3, 60), ('Astha', 2, 70)] The unzipped result: The name list is : ('Manjeet', 'Nikhil', 'Shambhavi', 'Astha') The roll_no list is : (4, 1, 3, 2) The marks list is : (40, 50, 60, 70)","title":"Zip"},{"location":"DS/pyIterZip/#zip","text":"Python zip() method takes iterable or containers and returns a single iterator object, having mapped values from all the containers. It is used to map the similar index of multiple containers so that they can be used just using a single entity. name = [ \"Manjeet\" , \"Nikhil\" , \"Shambhavi\" , \"Astha\" ] roll_no = [ 4 , 1 , 3 , 2 ] # using zip() to map values mapped = zip ( name , roll_no ) print ( set ( mapped )) {('Shambhavi', 3), ('Nikhil', 1), ('Astha', 2), ('Manjeet', 4)} names = [ 'Mukesh' , 'Roni' , 'Chari' ] ages = [ 24 , 50 , 18 ] for i , ( name , age ) in enumerate ( zip ( names , ages )): print ( i , name , age ) 0 Mukesh 24 1 Roni 50 2 Chari 18 stocks = [ 'reliance' , 'infosys' , 'tcs' ] prices = [ 2175 , 1127 , 2750 ] new_dict = { stocks : prices for stocks , prices in zip ( stocks , prices )} print ( new_dict ) {'reliance': 2175, 'infosys': 1127, 'tcs': 2750}","title":"Zip"},{"location":"DS/pyIterZip/#unzip","text":"How to unzip? Unzipping means converting the zipped values back to the individual self as they were. This is done with the help of \u201c*\u201d operator. # Python code to demonstrate the working of # unzip # initializing lists name = [ \"Manjeet\" , \"Nikhil\" , \"Shambhavi\" , \"Astha\" ] roll_no = [ 4 , 1 , 3 , 2 ] marks = [ 40 , 50 , 60 , 70 ] # using zip() to map values mapped = zip ( name , roll_no , marks ) # converting values to print as list mapped = list ( mapped ) # printing resultant values print ( \"The zipped result is : \" , end = \"\" ) print ( mapped ) print ( \" \\n \" ) # unzipping values namz , roll_noz , marksz = zip ( * mapped ) print ( \"The unzipped result: \\n \" , end = \"\" ) # printing initial lists print ( \"The name list is : \" , end = \"\" ) print ( namz ) print ( \"The roll_no list is : \" , end = \"\" ) print ( roll_noz ) print ( \"The marks list is : \" , end = \"\" ) print ( marksz ) The zipped result is : [('Manjeet', 4, 40), ('Nikhil', 1, 50), ('Shambhavi', 3, 60), ('Astha', 2, 70)] The unzipped result: The name list is : ('Manjeet', 'Nikhil', 'Shambhavi', 'Astha') The roll_no list is : (4, 1, 3, 2) The marks list is : (40, 50, 60, 70)","title":"Unzip"},{"location":"DS/pyList/","text":"A list comprises a sequence of objects, usually represented using square brackets with commas between the items in the sequence as is done below: my_list = [ 'a' , 'b' , 'c' , 'd' ] print ( my_list ) ['a', 'b', 'c', 'd'] Above, my_list contains a sequence of character objects. Lists, however, accomodate items of varying types of objects: varied_list = [ 'a' , 1 , 'b' , 3.14159 ] # a list with elements of char, integer, and float types nested_list = [ 'hello' , 'governor' , [ 1.618 , 42 ]] # a list within a list! Lists allow for what is called indexing, in which a specified element of the list may be obtained. For instance, say you wanted to grab the second element of varied_list above. Then you could index the list as so: second_element = varied_list [ 1 ] # Grab second element of varied_list print ( second_element ) Now is a good time to mention that Python is what's called a zero-indexed programming language. This simply means that the \"first\" element in a list or other collection of data items is indexed using \"0\" (zero) rather than \"1\". This is why, above, we grab the second element of varied_list using the integer index \"1\" instead of \"2\" as some might expect from a one-indexed language (like MATLab). Another feature of python indexing that comes in handy is the use of negative indexing. As we discussed above, the \"first\" element of a python list is denoted by index \"0\"; thus, it is almost natural to consider the last element of the list as being indexed by \"-1\". Observe the following examples of negative indexing: last_element = my_list [ - 1 ] # the last element of my_list last_element_2 = my_list [ len ( my_list ) - 1 ] # also the last element of my_list, obtained differently second_to_last_element = my_list [ - 2 ] Similar to indexing is list slicing, in which a contiguous section of list may be accessed. The colon (:) is used to perform slicing, with integers denoting the positions at which to begin and end the slice. Below, we show that the beginning or ending integer for a slice may be omited when one is slicing from the beginning or to the end of the list. Also note below that the index for slice beginning is included in the slice, but the index for the slice end is not included. NFL_list = [ \"Chargers\" , \"Broncos\" , \"Raiders\" , \"Chiefs\" , \"Panthers\" , \"Falcons\" , \"Cowboys\" , \"Eagles\" ] AFC_west_list = NFL_list [: 4 ] # Slice to grab list indices 0, 1, 2, 3 -- \"Chargers\", \"Broncos\", \"Raiders\", \"Chiefs\" NFC_south_list = NFL_list [ 4 : 6 ] # Slice list indices 4, 5 -- \"Panthers\", \"Falcons\" NFC_east_list = NFL_list [ 6 :] # Slice list indices 6, 7 -- \"Cowboys\", \"Eagles\" List slices can also have a third number, representing the step, to include only alternate values in the slice. NFL_list = [ \"Chargers\" , \"Broncos\" , \"Raiders\" , \"Chiefs\" , \"Panthers\" , \"Falcons\" , \"Cowboys\" , \"Eagles\" ] list1 = NFL_list [ 3 :: 2 ] print ( list1 ) ['Chiefs', 'Falcons', 'Eagles'] Negative values can be used in list slicing (and normal list indexing). When negative values are used for the first and second values in a slice (or a normal index), they count from the end of the list. If a negative value is used for the step, the slice is done backwards. Using [::-1] as a slice is a common and idiomatic way to reverse a list. squares = [ 0 , 1 , 4 , 9 , 16 , 25 , 36 , 49 , 64 , 81 ] print ( squares [ 1 : - 3 ]) print ( squares [:: - 1 ]) print ( squares [: 4 : - 1 ]) [1, 4, 9, 16, 25, 36] [81, 64, 49, 36, 25, 16, 9, 4, 1, 0] [81, 64, 49, 36, 25] Sometimes you need to create an empty list and populate it later during the program. For example, if you are creating a queue management program, the queue is going to be empty in the beginning and get populated with people data later. An empty list is created with an empty pair of square brackets. Nested lists can be used to represent 2D grids, such as matrices. Indexing strings behaves as though you are indexing a list containing each character in the string. empty_list = [] print ( empty_list ) m = [ [ 1 , 2 , 3 ], [ 4 , 5 , 6 ] ] print ( m ) s = \"Hello world\" print ( s [ 6 ]) [] [[1, 2, 3], [4, 5, 6]] w List Operations The item at a certain index in a list can be reassigned. Lists can be added and multiplied in the same way as strings. To check if an item is in a list, the in operator can be used. It returns True if the item occurs one or more times in the list, and False if it doesn't. The in operator is also used to determine whether or not a string is a substring of another string. M = [ 1 , 1 , 1 ] M [ 1 ] = \"hello\" print ( M ) print ( M * 3 ) print ( M + [ 1 , 2 ]) print ( 1 in M ) print ( \"Spam\" in M ) print ( not \"hello\" in M ) [1, 'hello', 1] [1, 'hello', 1, 1, 'hello', 1, 1, 'hello', 1] [1, 'hello', 1, 1, 2] True False False List Functions len(list): to get the number of items in a list. max(list): Returns the list item with the maximum value min(list): Returns the list item with minimum value list.append(item): adds an item to the end of an existing list. list.insert(index, item): is similar to append, except that it allows you to insert a new item at any position in the list, as opposed to just at the end. list.index(item): finds the first occurrence of a list item and returns its index. If the item isn't in the list, it raises a ValueError. list.count(item): Returns a count of how many times an item occurs in a list list.remove(item): Removes an object from a list list.pop(index) removes the item at the given index. list.reverse(): Reverses items in a list. list.sort() sorts the list. By default, the list is sorted ascending. You can specify reverse=True as the parameter, to sort descending. nums = [ 1 , 2 , 3 ] nums . append ( 4 ) print ( nums ) nums . insert ( 2 , \"hello\" ) print ( nums ) print ( len ( nums )) print ( nums . index ( 3 )) nums += [ 1 , 2 , 1 ] print ( nums . count ( 1 )) nums . remove ( \"hello\" ) print ( nums . reverse ()) print ( max ( nums )) print ( min ( nums )) [1, 2, 3, 4] [1, 2, 'hello', 3, 4] 5 3 3 None 4 1 # use iterator functions like enumerate, zip, iter, next # define a list of days in English and French days = [ \"Sun\" , \"Mon\" , \"Tue\" , \"Wed\" , \"Thu\" , \"Fri\" , \"Sat\" ] daysFr = [ \"Dim\" , \"Lun\" , \"Mar\" , \"Mer\" , \"Jeu\" , \"Ven\" , \"Sam\" ] # use iter to create an iterator over a collection i = iter ( days ) print ( next ( i )) # Sun print ( next ( i )) # Mon print ( next ( i )) # Tue # iterate using a function and a sentinel with open ( \"game.txt\" , \"r\" ) as fp : for line in iter ( fp . readline , '' ): print ( line ) # use regular interation over the days for m in range ( len ( days )): print ( m + 1 , days [ m ]) 1 Sun 2 Mon 3 Tue 4 Wed 5 Thu 6 Fri 7 Sat # using enumerate reduces code and provides a counter for i , m in enumerate ( days , start = 1 ): print ( i , m ) 1 Sun 2 Mon 3 Tue 4 Wed 5 Thu 6 Fri 7 Sat # use zip to combine sequences for m in zip ( days , daysFr ): print ( m ) for i , m in enumerate ( zip ( days , daysFr ), start = 1 ): print ( i , m [ 0 ], \"=\" , m [ 1 ], \"in French\" ) ('Sun', 'Dim') ('Mon', 'Lun') ('Tue', 'Mar') ('Wed', 'Mer') ('Thu', 'Jeu') ('Fri', 'Ven') ('Sat', 'Sam') 1 Sun = Dim in French 2 Mon = Lun in French 3 Tue = Mar in French 4 Wed = Mer in French 5 Thu = Jeu in French 6 Fri = Ven in French 7 Sat = Sam in French","title":"Lists"},{"location":"DS/pyList/#list-operations","text":"The item at a certain index in a list can be reassigned. Lists can be added and multiplied in the same way as strings. To check if an item is in a list, the in operator can be used. It returns True if the item occurs one or more times in the list, and False if it doesn't. The in operator is also used to determine whether or not a string is a substring of another string. M = [ 1 , 1 , 1 ] M [ 1 ] = \"hello\" print ( M ) print ( M * 3 ) print ( M + [ 1 , 2 ]) print ( 1 in M ) print ( \"Spam\" in M ) print ( not \"hello\" in M ) [1, 'hello', 1] [1, 'hello', 1, 1, 'hello', 1, 1, 'hello', 1] [1, 'hello', 1, 1, 2] True False False","title":"List Operations"},{"location":"DS/pyList/#list-functions","text":"len(list): to get the number of items in a list. max(list): Returns the list item with the maximum value min(list): Returns the list item with minimum value list.append(item): adds an item to the end of an existing list. list.insert(index, item): is similar to append, except that it allows you to insert a new item at any position in the list, as opposed to just at the end. list.index(item): finds the first occurrence of a list item and returns its index. If the item isn't in the list, it raises a ValueError. list.count(item): Returns a count of how many times an item occurs in a list list.remove(item): Removes an object from a list list.pop(index) removes the item at the given index. list.reverse(): Reverses items in a list. list.sort() sorts the list. By default, the list is sorted ascending. You can specify reverse=True as the parameter, to sort descending. nums = [ 1 , 2 , 3 ] nums . append ( 4 ) print ( nums ) nums . insert ( 2 , \"hello\" ) print ( nums ) print ( len ( nums )) print ( nums . index ( 3 )) nums += [ 1 , 2 , 1 ] print ( nums . count ( 1 )) nums . remove ( \"hello\" ) print ( nums . reverse ()) print ( max ( nums )) print ( min ( nums )) [1, 2, 3, 4] [1, 2, 'hello', 3, 4] 5 3 3 None 4 1 # use iterator functions like enumerate, zip, iter, next # define a list of days in English and French days = [ \"Sun\" , \"Mon\" , \"Tue\" , \"Wed\" , \"Thu\" , \"Fri\" , \"Sat\" ] daysFr = [ \"Dim\" , \"Lun\" , \"Mar\" , \"Mer\" , \"Jeu\" , \"Ven\" , \"Sam\" ] # use iter to create an iterator over a collection i = iter ( days ) print ( next ( i )) # Sun print ( next ( i )) # Mon print ( next ( i )) # Tue # iterate using a function and a sentinel with open ( \"game.txt\" , \"r\" ) as fp : for line in iter ( fp . readline , '' ): print ( line ) # use regular interation over the days for m in range ( len ( days )): print ( m + 1 , days [ m ]) 1 Sun 2 Mon 3 Tue 4 Wed 5 Thu 6 Fri 7 Sat # using enumerate reduces code and provides a counter for i , m in enumerate ( days , start = 1 ): print ( i , m ) 1 Sun 2 Mon 3 Tue 4 Wed 5 Thu 6 Fri 7 Sat # use zip to combine sequences for m in zip ( days , daysFr ): print ( m ) for i , m in enumerate ( zip ( days , daysFr ), start = 1 ): print ( i , m [ 0 ], \"=\" , m [ 1 ], \"in French\" ) ('Sun', 'Dim') ('Mon', 'Lun') ('Tue', 'Mar') ('Wed', 'Mer') ('Thu', 'Jeu') ('Fri', 'Ven') ('Sat', 'Sam') 1 Sun = Dim in French 2 Mon = Lun in French 3 Tue = Mar in French 4 Wed = Mer in French 5 Thu = Jeu in French 6 Fri = Ven in French 7 Sat = Sam in French","title":"List Functions"},{"location":"DS/pyTuple/","text":"A tuple is a Python collection that is extremely similar to a list, with some subtle differences. For starters, tuples are indicated using parentheses instead of square brackets. Like lists and dictionaries, tuples can be nested within each other. x = 1 y = 2 coordinates = ( x , y ) The variable coordinates above is a tuple containing the variables x and y. This example was chosen to also demonstrate a difference between the typical usage of tuples versus lists. Whereas lists are frequently used to contain objects whose values are similar in some sense, tuples are frequently used to contain attributes of a coherent unit. For instance, as above, it makes sense to treat the coordinates of a point as a single unit. As another example, consider the following tuple and list concerning dates: year1 = 2011 month1 = \"May\" day1 = 18 date1 = ( month1 , day1 , year1 ) year2 = 2017 month2 = \"June\" day2 = 13 date2 = ( month2 , day2 , year2 ) years_list = [ year1 , year2 ] Notice above that we have collected the attributes of a single date into one tuple: those pieces of information all describe a single \"unit\". By contrast, in the years list we have collected the different years. In the code-snippet: the values in the list have a commonality (they are both years), but they do not describe the same unit. The distinction drawn between tuples and lists is one that many Python programmers recognize in practice, but not one that is strictly enforced (i.e., you won't get any errors if you break this convention!). Another subtle way in which tuples and lists differ involves what is called mutability of Python variables. Mutability refers to the fact that a mutable object can be changed after it is created, and an immutable object can\u2019t. Tuples are not mutable, lists are mutable. Tuples are very similar to lists, except that they are immutable (they cannot be changed). Trying to reassign a value in a tuple causes a TypeError. Objects of built-in types like (int, float, bool, str, tuple, frozenset, unicode) are immutable. Objects of built-in types like (list, set, dict, byte array) are mutable. Custom classes are generally mutable. To simulate immutability in a class, one should override attribute setting and deletion to raise exceptions. To read further. words = ( \"spam\" , \"eggs\" , \"sausages\" ,) print ( words [ 0 ]) words [ 1 ] = \"cheese\" spam --------------------------------------------------------------------------- TypeError Traceback (most recent call last) <ipython-input-85-a8af92c7d33f> in <module>() 1 words = (\"spam\", \"eggs\", \"sausages\",) 2 print(words[0]) ----> 3 words[1]=\"cheese\" TypeError: 'tuple' object does not support item assignment Tuples can be created without the parentheses, by just separating the values with commas. An empty tuple is created using an empty parenthesis pair. Tuples are faster than lists, but they cannot be changed. Slicing can also be done on tuples. my_tp = () tp = \"one\" , \"two\" , \"three\" print ( tp [ 0 ]) print ( len ( my_tp )) print ( tp [ 1 :]) one 0 ('two', 'three') Tuple unpacking Tuple unpacking allows you to assign each item in an iterable (often a tuple) to a variable. This can be also used to swap variables by doing a, b = b, a , since b, a on the right hand side forms the tuple (b, a) which is then unpacked. A variable that is prefaced with an asterisk (*) takes all values from the iterable that are left over from the other variables. numbers = ( 1 , 2 , 3 ) a , b , c = numbers #unpacking print ( a ) print ( b ) print ( c ) 1 2 3 a , b , * c , d = ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ) print ( a ) print ( b ) print ( c ) print ( d ) 1 2 [3, 4, 5, 6, 7, 8] 9","title":"Tuple"},{"location":"DS/pyTuple/#tuple-unpacking","text":"Tuple unpacking allows you to assign each item in an iterable (often a tuple) to a variable. This can be also used to swap variables by doing a, b = b, a , since b, a on the right hand side forms the tuple (b, a) which is then unpacked. A variable that is prefaced with an asterisk (*) takes all values from the iterable that are left over from the other variables. numbers = ( 1 , 2 , 3 ) a , b , c = numbers #unpacking print ( a ) print ( b ) print ( c ) 1 2 3 a , b , * c , d = ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ) print ( a ) print ( b ) print ( c ) print ( d ) 1 2 [3, 4, 5, 6, 7, 8] 9","title":"Tuple unpacking"},{"location":"PR/pyAsser/","text":"An assertion is a sanity-check that you can turn on or turn off when you have finished testing the program. An expression is tested, and if the result comes up false, an exception is raised. Assertions are carried out through use of the assert statement. Programmers often place assertions at the start of a function to check for valid input, and after a function call to check for valid output. print ( 1 ) assert 2 + 2 == 4 print ( 2 ) assert 1 + 1 == 3 print ( 3 ) 1 2 --------------------------------------------------------------------------- AssertionError Traceback (most recent call last) <ipython-input-77-c678df5c3c33> in <module>() 2 assert 2 + 2 == 4 3 print (2) ----> 4 assert 1 + 1 == 3 5 print (3) AssertionError: The assert can take a second argument that is passed to the AssertionError raised if the assertion fails. AssertionError exceptions can be caught and handled like any other exception using the try-except statement, but if not handled, this type of exception will terminate the program. temp =- 10 assert ( temp >= 0 ), \"Colder than absolute zero!\" --------------------------------------------------------------------------- AssertionError Traceback (most recent call last) <ipython-input-78-f713a352d793> in <module>() 1 temp=-10 ----> 2 assert (temp>=0), \"Colder than absolute zero!\" AssertionError: Colder than absolute zero!","title":"Assertions"},{"location":"PR/pyCompr/","text":"Comprehensions are a handy way to run a loop within a single line of code and to collect the results of the loop in a collection such as a list List Comprehension List comprehensions are a useful way of quickly creating lists whose contents obey a simple rule. Python allows for list comprehension in which the elements of a list are iterated over all in one line of code. List comprehensions are inspired by set-builder notation in mathematics. even_list = [ 2 , 4 , 6 , 8 ] odd_list = [ even + 1 for even in even_list ] print ( odd_list ) cubes = [ i ** 3 for i in range ( 5 )] print ( cubes ) [3, 5, 7, 9] [0, 1, 8, 27, 64] Note from above the similarities between list comprehension and a for-loop; Python has list comprehension as a compact, \"pythonic\" way of performing operations that could be done within a for-loop. A list comprehension can also contain an if statement to enforce a condition on values in the list. a = [ i ** 2 for i in range ( 10 )] evens = [ i ** 2 for i in range ( 10 ) if i ** 2 % 2 == 0 ] print ( a ) print ( evens ) [0, 1, 4, 9, 16, 25, 36, 49, 64, 81] [0, 4, 16, 36, 64] Trying to create a list in a very extensive range will result in a MemoryError. This code shows an example where the list comprehension runs out of memory. This issue is solved by generators. results = [] for city , year in zip ( cities , years ): #int () needed because year is a string if int ( year ) > 1945 : results . append ( city + ': ' + year ) To do it better and more Pythonic Use List comprehensions #List comprehension: # [f(element) for element in iterator if condition(element)] results = [( city + ': ' + year ) for city , year in zip ( cities , years ) if int ( year ) > 1945 ] results = [( city + ': ' + year ) for city , year in zip ( cities , years ) if int ( year ) > 1945 ] Dictionary comprehension cities_by_year = { year : city for city , year in zip ( cities , years )} # Demonstrate how to use dictionary comprehensions def main (): # define a list of temperature values ctemps = [ 0 , 12 , 34 , 100 ] # Use a comprehension to build a dictionary tempDict = { t : ( t * 9 / 5 ) + 32 for t in ctemps if t < 100 } print ( tempDict ) print ( tempDict [ 12 ]) # Merge two dictionaries with a comprehension team1 = { \"Jones\" : 24 , \"Jameson\" : 18 , \"Smith\" : 58 , \"Burns\" : 7 } team2 = { \"White\" : 12 , \"Macke\" : 88 , \"Perce\" : 4 } newTeam = { k : v for team in ( team1 , team2 ) for k , v in team . items ()} print ( newTeam ) if __name__ == \"__main__\" : main () {0: 32.0, 12: 53.6, 34: 93.2} 53.6 {'Jones': 24, 'Jameson': 18, 'Smith': 58, 'Burns': 7, 'White': 12, 'Macke': 88, 'Perce': 4} Set Comprehension cities_after_1930 = { city for year , city in cities_by_year . items () if int ( year ) > 1930 } def main (): # define a list of temperature data points ctemps = [ 5 , 10 , 12 , 14 , 10 , 23 , 41 , 30 , 12 , 24 , 12 , 18 , 29 ] # build a set of unique Fahrenheit temperatures ftemps1 = [( t * 9 / 5 ) + 32 for t in ctemps ] ftemps2 = {( t * 9 / 5 ) + 32 for t in ctemps } print ( ftemps1 ) print ( ftemps2 ) # build a set from an input source sTemp = \"The quick brown fox jumped over the lazy dog\" chars = { c . upper () for c in sTemp if not c . isspace ()} print ( chars ) if __name__ == \"__main__\" : main () [41.0, 50.0, 53.6, 57.2, 50.0, 73.4, 105.8, 86.0, 53.6, 75.2, 53.6, 64.4, 84.2] {64.4, 73.4, 41.0, 105.8, 75.2, 50.0, 84.2, 53.6, 86.0, 57.2} {'G', 'M', 'E', 'B', 'J', 'U', 'R', 'N', 'W', 'P', 'Y', 'T', 'O', 'H', 'Z', 'Q', 'V', 'X', 'F', 'K', 'L', 'D', 'I', 'A', 'C'}","title":"Comprehensions"},{"location":"PR/pyCompr/#list-comprehension","text":"List comprehensions are a useful way of quickly creating lists whose contents obey a simple rule. Python allows for list comprehension in which the elements of a list are iterated over all in one line of code. List comprehensions are inspired by set-builder notation in mathematics. even_list = [ 2 , 4 , 6 , 8 ] odd_list = [ even + 1 for even in even_list ] print ( odd_list ) cubes = [ i ** 3 for i in range ( 5 )] print ( cubes ) [3, 5, 7, 9] [0, 1, 8, 27, 64] Note from above the similarities between list comprehension and a for-loop; Python has list comprehension as a compact, \"pythonic\" way of performing operations that could be done within a for-loop. A list comprehension can also contain an if statement to enforce a condition on values in the list. a = [ i ** 2 for i in range ( 10 )] evens = [ i ** 2 for i in range ( 10 ) if i ** 2 % 2 == 0 ] print ( a ) print ( evens ) [0, 1, 4, 9, 16, 25, 36, 49, 64, 81] [0, 4, 16, 36, 64] Trying to create a list in a very extensive range will result in a MemoryError. This code shows an example where the list comprehension runs out of memory. This issue is solved by generators. results = [] for city , year in zip ( cities , years ): #int () needed because year is a string if int ( year ) > 1945 : results . append ( city + ': ' + year ) To do it better and more Pythonic Use List comprehensions #List comprehension: # [f(element) for element in iterator if condition(element)] results = [( city + ': ' + year ) for city , year in zip ( cities , years ) if int ( year ) > 1945 ] results = [( city + ': ' + year ) for city , year in zip ( cities , years ) if int ( year ) > 1945 ]","title":"List Comprehension"},{"location":"PR/pyCompr/#dictionary-comprehension","text":"cities_by_year = { year : city for city , year in zip ( cities , years )} # Demonstrate how to use dictionary comprehensions def main (): # define a list of temperature values ctemps = [ 0 , 12 , 34 , 100 ] # Use a comprehension to build a dictionary tempDict = { t : ( t * 9 / 5 ) + 32 for t in ctemps if t < 100 } print ( tempDict ) print ( tempDict [ 12 ]) # Merge two dictionaries with a comprehension team1 = { \"Jones\" : 24 , \"Jameson\" : 18 , \"Smith\" : 58 , \"Burns\" : 7 } team2 = { \"White\" : 12 , \"Macke\" : 88 , \"Perce\" : 4 } newTeam = { k : v for team in ( team1 , team2 ) for k , v in team . items ()} print ( newTeam ) if __name__ == \"__main__\" : main () {0: 32.0, 12: 53.6, 34: 93.2} 53.6 {'Jones': 24, 'Jameson': 18, 'Smith': 58, 'Burns': 7, 'White': 12, 'Macke': 88, 'Perce': 4}","title":"Dictionary comprehension"},{"location":"PR/pyCompr/#set-comprehension","text":"cities_after_1930 = { city for year , city in cities_by_year . items () if int ( year ) > 1930 } def main (): # define a list of temperature data points ctemps = [ 5 , 10 , 12 , 14 , 10 , 23 , 41 , 30 , 12 , 24 , 12 , 18 , 29 ] # build a set of unique Fahrenheit temperatures ftemps1 = [( t * 9 / 5 ) + 32 for t in ctemps ] ftemps2 = {( t * 9 / 5 ) + 32 for t in ctemps } print ( ftemps1 ) print ( ftemps2 ) # build a set from an input source sTemp = \"The quick brown fox jumped over the lazy dog\" chars = { c . upper () for c in sTemp if not c . isspace ()} print ( chars ) if __name__ == \"__main__\" : main () [41.0, 50.0, 53.6, 57.2, 50.0, 73.4, 105.8, 86.0, 53.6, 75.2, 53.6, 64.4, 84.2] {64.4, 73.4, 41.0, 105.8, 75.2, 50.0, 84.2, 53.6, 86.0, 57.2} {'G', 'M', 'E', 'B', 'J', 'U', 'R', 'N', 'W', 'P', 'Y', 'T', 'O', 'H', 'Z', 'Q', 'V', 'X', 'F', 'K', 'L', 'D', 'I', 'A', 'C'}","title":"Set Comprehension"},{"location":"PR/pyCond/","text":"Oftentimes while programming, one will want to only execute portions of code when certain conditions are met, for instance, when a variable has a certain value. This is accomplished using conditional statements: if, elif, and else. Indentation is used to define the level of nesting, for nested conditionals. Multiple if/else statements make the code long and not very readable. The elif statement is equivalent to an else/if statement. It is used to make the code shorter, more readable, and avoid indentation increase. for i in range ( 10 ): if i % 2 == 0 : # % -- modulus operator -- returns the remainder after division print ( \" {} is even\" . format ( i )) else : print ( \" {} is odd\" . format ( i )) 0 is even 1 is odd 2 is even 3 is odd 4 is even 5 is odd 6 is even 7 is odd 8 is even 9 is odd # Example using elif as well # Print the meteorological season for each month (loosely, of course, and in the Northern Hemisphere) print ( \"In the Northern Hemisphere: \\n \" ) month_integer = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 ] # i.e., January is 1, February is 2, etc... for month in month_integer : if month < 3 : print ( \"Month {} is in Winter\" . format ( month )) elif month < 6 : print ( \"Month {} is in Spring\" . format ( month )) elif month < 9 : print ( \"Month {} is in Summer\" . format ( month )) elif month < 12 : print ( \"Month {} is in Fall\" . format ( month )) else : # This will put 12 (i.e., December) into Winter print ( \"Month {} is in Winter\" . format ( month )) In the Northern Hemisphere: Month 1 is in Winter Month 2 is in Winter Month 3 is in Spring Month 4 is in Spring Month 5 is in Spring Month 6 is in Summer Month 7 is in Summer Month 8 is in Summer Month 9 is in Fall Month 10 is in Fall Month 11 is in Fall Month 12 is in Winter Ternary operator Conditional expressions provide the functionality of if statements while using less code. They shouldn't be overused, as they can easily reduce readability, but they are often useful when assigning variables. Conditional expressions are also known as applications of the ternary operator. The ternary operator checks the condition and returns the corresponding value. The ternary operator is so called because, unlike most operators, it takes three arguments. a = 3 b = 1 if a >= 5 else 42 print ( b ) #42 Match case (Switch) ##For 3.10 up value = \"one\" match value : case \"one\" : result = 1 case \"two\" : result = 2 case \"three\" | \"four\" : result = ( 3 , 4 ) case _ : result =- 1 print ( result )","title":"Conditionals"},{"location":"PR/pyCond/#ternary-operator","text":"Conditional expressions provide the functionality of if statements while using less code. They shouldn't be overused, as they can easily reduce readability, but they are often useful when assigning variables. Conditional expressions are also known as applications of the ternary operator. The ternary operator checks the condition and returns the corresponding value. The ternary operator is so called because, unlike most operators, it takes three arguments. a = 3 b = 1 if a >= 5 else 42 print ( b ) #42","title":"Ternary operator"},{"location":"PR/pyCond/#match-case-switch","text":"##For 3.10 up value = \"one\" match value : case \"one\" : result = 1 case \"two\" : result = 2 case \"three\" | \"four\" : result = ( 3 , 4 ) case _ : result =- 1 print ( result )","title":"Match case (Switch)"},{"location":"PR/pyElse/","text":"The else statement is most commonly used along with the if statement, but it can also follow a for or while loop, which gives it a different meaning. With the for or while loop, the code within it is called if the loop finishes normally (when a break statement does not cause an exit from the loop). for i in range ( 10 ): if i == 999 : break else : print ( \"Unbroken 1\" ) for i in range ( 10 ): if i == 5 : break else : print ( \"Unbroken 2\" ) Unbroken 1 The else statement can also be used with try/except statements. In this case, the code within it is only executed if no error occurs in the try statement. try : print ( 1 ) except ZeroDivisionError : print ( 2 ) else : print ( 3 ) print ( \"*********\" ) try : print ( 1 / 0 ) except ZeroDivisionError : print ( 2 ) else : print ( 3 ) 1 3 ********* 2","title":"Else-4loopsExcep"},{"location":"PR/pyExp/","text":"Exceptions ImportError: an import fails; IndexError: a list is indexed with an out-of-range number; NameError: an unknown variable is used; SyntaxError: the code can't be parsed properly; TypeError: a function is called on a value of an inappropriate type; ValueError: a function is called on a value of the correct type, but with an inappropriate value. Exception Handling To handle exceptions, and to call code when an exception occurs, you can use a try/except statement. Multiple exceptions can also be put into a single except block using parentheses, to have the except block handle all of them. An except statement without any exception specified will catch all errors. Finally To ensure some code runs no matter what errors occur, you can use a finally statement. The finally statement is placed at the bottom of a try/except statement. try : a = 0 b = 1 print ( a / b ) #print(b/a) print ( a + \"a\" ) except ZeroDivisionError : print ( \"Error!\" ) except ( ValueError , TypeError ): print ( \"Error 2!\" ) except : print ( f 'Unknown error: { sys . exc_info () } ' ) else : print ( 'No errors' ) finally : print ( \"Bye bye\" ) 0.0 Error 2! Bye bye Raising Exceptions Use raise statement Exceptions can be raised with arguments that give detail about them. print ( 1 ) raise ValueError print ( 2 ) 1 --------------------------------------------------------------------------- ValueError Traceback (most recent call last) <ipython-input-75-990863ff3a0f> in <module>() 1 print(1) ----> 2 raise ValueError 3 print(2) ValueError: try : name = \"123\" raise NameError ( \"Invalid Name!\" ) except NameError as e : print ( f 'Name error: { e } ' ) print ( 2 ) Name error: Invalid Name! 2","title":"Exceptions"},{"location":"PR/pyExp/#exceptions","text":"ImportError: an import fails; IndexError: a list is indexed with an out-of-range number; NameError: an unknown variable is used; SyntaxError: the code can't be parsed properly; TypeError: a function is called on a value of an inappropriate type; ValueError: a function is called on a value of the correct type, but with an inappropriate value.","title":"Exceptions"},{"location":"PR/pyExp/#exception-handling","text":"To handle exceptions, and to call code when an exception occurs, you can use a try/except statement. Multiple exceptions can also be put into a single except block using parentheses, to have the except block handle all of them. An except statement without any exception specified will catch all errors.","title":"Exception Handling"},{"location":"PR/pyExp/#finally","text":"To ensure some code runs no matter what errors occur, you can use a finally statement. The finally statement is placed at the bottom of a try/except statement. try : a = 0 b = 1 print ( a / b ) #print(b/a) print ( a + \"a\" ) except ZeroDivisionError : print ( \"Error!\" ) except ( ValueError , TypeError ): print ( \"Error 2!\" ) except : print ( f 'Unknown error: { sys . exc_info () } ' ) else : print ( 'No errors' ) finally : print ( \"Bye bye\" ) 0.0 Error 2! Bye bye","title":"Finally"},{"location":"PR/pyExp/#raising-exceptions","text":"Use raise statement Exceptions can be raised with arguments that give detail about them. print ( 1 ) raise ValueError print ( 2 ) 1 --------------------------------------------------------------------------- ValueError Traceback (most recent call last) <ipython-input-75-990863ff3a0f> in <module>() 1 print(1) ----> 2 raise ValueError 3 print(2) ValueError: try : name = \"123\" raise NameError ( \"Invalid Name!\" ) except NameError as e : print ( f 'Name error: { e } ' ) print ( 2 ) Name error: Invalid Name! 2","title":"Raising Exceptions"},{"location":"PR/pyOp1/","text":"Operator Name Description a + b Addition Sum of a and b a - b Subtraction Difference of a and b a * b Multiplication Product of a and b a / b True division Quotient of a and b a // b Floor division Quotient of a and b , removing fractional parts a % b Modulus Integer remainder after division of a by b a ** b Exponentiation a raised to the power of b -a Negation The negative of a a = 3 ** 2 b = 2 ** 2 ** 3 print ( a ) print ( b ) print ( 9 ** ( 1 / 2 )) #result is float print ( 20 // 6 ) # Quotient print ( 20 % 6 ) # Modulo or remainder 9 256 3.0 3 2 For enhanced precision, the decimal module provides support for fast correctly-rounded decimal floating point arithmetic. from decimal import * getcontext () . prec = 6 Decimal ( 1 ) / Decimal ( 7 ) Decimal('0.142857')","title":"Arithmethic"},{"location":"PR/pyOp2/","text":"In Python, bitwise operators are used to performing bitwise calculations on integers. The integers are first converted into binary and then operations are performed on bit by bit, hence the name bitwise operators. Then the result is returned in decimal format. Note: Python bitwise operators work only on integers. Operator Name Description a & b Bitwise AND Returns 1 if both the bits are 1 else 0 a | b Bitwise OR Returns 1 if either of the bit is 1 else 0 a ~ b Bitwise NOT Returns one\u2019s complement of the number a ^ b Bitwise XOR Returns 1 if one of the bits is 1 and the other is 0 else returns false a >> b Bitwise right shift Returns 1 if both the bits are 1 else 0 a << b Bitwise left shift Returns 1 if both the bits are 1 else 0 Shift Operators These operators are used to shift the bits of a number left or right thereby multiplying or dividing the number by two respectively. They can be used when we have to multiply or divide a number by two. Bitwise right shift Shifts the bits of the number to the right and fills 0 on voids left as a result. Similar effect as of dividing the number with some power of two. Bitwise left shift Shifts the bits of the number to the left and fills 0 on voids left as a result. Similar effect as of multiplying the number with some power of two. a = 10 #1010(Binary) b = 4 #0100(Binary) # Print bitwise AND operation print ( \"a & b =\" , a & b ) #0000(Binary) # Print bitwise OR operation print ( \"a | b =\" , a | b ) #1110(Binary)=14(Decimal) # Print bitwise NOT operation print ( \"~a =\" , ~ a ) #-(1010+1)(Binary)=-(1011)=-11(Decimal) # print bitwise XOR operation print ( \"a ^ b =\" , a ^ b ) # 1110(Binary)=14(Decimal) a = 10 b = - 10 # print bitwise right shift operator print ( \"a >> 1 =\" , a >> 1 ) print ( \"b >> 1 =\" , b >> 1 ) a = 5 b = - 10 # print bitwise left shift operator print ( \"a << 1 =\" , a << 1 ) print ( \"b << 1 =\" , b << 1 ) #Hexidecimal x = 0x0a y = 0x02 z = x & y print ( f '(hex) x is { x : 02x } , y is { y : 02x } , z is { z : 02x } ' ) print ( f '(bin) x is { x : 08b } , y is { y : 08b } , z is { z : 08b } ' ) z = x << y print ( f '(bin) x is { x : 08b } , y is { y : 08b } , z is { z : 08b } ' ) a & b = 0 a | b = 14 ~a = -11 a ^ b = 14 a >> 1 = 5 b >> 1 = -5 a << 1 = 10 b << 1 = -20 (hex) x is 0a, y is 02, z is 02 (bin) x is 00001010, y is 00000010, z is 00000010 (bin) x is 00001010, y is 00000010, z is 00101000","title":"Bitwise"},{"location":"PR/pyOp2/#shift-operators","text":"These operators are used to shift the bits of a number left or right thereby multiplying or dividing the number by two respectively. They can be used when we have to multiply or divide a number by two.","title":"Shift Operators"},{"location":"PR/pyOp2/#bitwise-right-shift","text":"Shifts the bits of the number to the right and fills 0 on voids left as a result. Similar effect as of dividing the number with some power of two.","title":"Bitwise right shift"},{"location":"PR/pyOp2/#bitwise-left-shift","text":"Shifts the bits of the number to the left and fills 0 on voids left as a result. Similar effect as of multiplying the number with some power of two. a = 10 #1010(Binary) b = 4 #0100(Binary) # Print bitwise AND operation print ( \"a & b =\" , a & b ) #0000(Binary) # Print bitwise OR operation print ( \"a | b =\" , a | b ) #1110(Binary)=14(Decimal) # Print bitwise NOT operation print ( \"~a =\" , ~ a ) #-(1010+1)(Binary)=-(1011)=-11(Decimal) # print bitwise XOR operation print ( \"a ^ b =\" , a ^ b ) # 1110(Binary)=14(Decimal) a = 10 b = - 10 # print bitwise right shift operator print ( \"a >> 1 =\" , a >> 1 ) print ( \"b >> 1 =\" , b >> 1 ) a = 5 b = - 10 # print bitwise left shift operator print ( \"a << 1 =\" , a << 1 ) print ( \"b << 1 =\" , b << 1 ) #Hexidecimal x = 0x0a y = 0x02 z = x & y print ( f '(hex) x is { x : 02x } , y is { y : 02x } , z is { z : 02x } ' ) print ( f '(bin) x is { x : 08b } , y is { y : 08b } , z is { z : 08b } ' ) z = x << y print ( f '(bin) x is { x : 08b } , y is { y : 08b } , z is { z : 08b } ' ) a & b = 0 a | b = 14 ~a = -11 a ^ b = 14 a >> 1 = 5 b >> 1 = -5 a << 1 = 10 b << 1 = -20 (hex) x is 0a, y is 02, z is 02 (bin) x is 00001010, y is 00000010, z is 00000010 (bin) x is 00001010, y is 00000010, z is 00101000","title":"Bitwise left shift"},{"location":"PR/pyOp3/","text":"In-place operators allow you to write code like 'x = x + 3' more concisely, as 'x += 3'. In-place operators can be used for any numerical operation (+, -, , /, %, *, //). These operators can be used on types other than numbers, as well, such as strings. x = 2 x += 3 print ( x ) x *= 7 print ( x ) y = \"spam \" y *= 3 print ( y ) 5 35 spam spam spam","title":"In-Place"},{"location":"PR/pyOp4/","text":"Walrus operator := allows you to assign values to variables within an expression, including variables that do not exist yet. Let's suppose we want to take an integer from the user, assign it to a variable num and output it. The walrus operator accomplishes these operations at once. The walrus operator makes code more readable and can be useful in many situations. num = int ( input ()) print ( num ) #The same but using Walrus operator #Python 3.8 up print ( num := int ( input ()))","title":"Walrus"},{"location":"PR/pyOp5/","text":"Boolean type . There are two Boolean values: True and False. They can be created by comparing values, for instance by using the equal operator ==. a = True print ( a ) b = ( 1 == 3 ) print ( b ) True False -1 Comparison operators are also called Relational operators . There are != , <, <=, >, >=. Used to compare strings lexicographically print ( 3 != 2 ) print ( 8 <= 9.0 ) #different types, no problem! print ( 'Carlos' > 'Ana' ) True True True Boolean logic is used to make more complicated conditions for if statements that rely on more than one condition. Python's Boolean operators are and , or , not , in , not in , is and, is not . print ( 1 == 1 and 3 > 4 ) print ( 1 == 1 or 3 > 4 ) print ( 1 == 2 and not 3 > 4 ) x = ( 'bear' , 'bunny' , 'tree' ) y = 'bear' print ( y in x ) print ( y not in x ) print ( y is x [ 0 ]) #same id print ( id ( y )) print ( id ( x [ 0 ])) False True False True False True 140097849021808 140097849021808","title":"Comparison"},{"location":"PR/pyOp6/","text":"The Operator, @ In the context of matrix multiplication, a @ b invokes a.__matmul__(b) - making this syntax: a @ b equivalent to dot(a, b) and a @= b equivalent to a = dot(a, b) where dot is, for example, the numpy matrix multiplication function and a and b are matrices.","title":"/@"},{"location":"PR/pyOp7/","text":"(Star) * Operator The single star * unpacks the sequence/collection into positional arguments, so you can do this: def sum ( a , b ): return a + b values = ( 1 , 2 ) s = sum ( * values ) print ( s ) s = sum ( 1 , 2 ) #The same print ( s ) 3 3 The double star ** does the same, only using a dictionary and thus named arguments: values = { 'a' : 1 , 'b' : 2 } s = sum ( ** values ) print ( s ) 3 Combining the two: def sum ( a , b , c , d ): return a + b + c + d values1 = ( 1 , 2 ) values2 = { 'c' : 10 , 'd' : 15 } s = sum ( * values1 , ** values2 ) print ( s ) # the same as s = sum ( 1 , 2 , c = 10 , d = 15 ) print ( s ) 28 28 Additionally you can define functions to take x and *y arguments, this allows a function to accept any number of positional and/or named arguments that aren't specifically named in the declaration. def sum ( * values ): s = 0 for v in values : s = s + v return s s = sum ( 1 , 2 , 3 , 4 , 5 ) print ( s ) 15 or with ** def get_a ( ** values ): return values [ 'a' ] s = get_a ( a = 1 , b = 2 ) # returns 1 print ( s ) 1 this can allow you to specify a large number of optional parameters without having to declare them. And again, you can combine: def sum ( * values , ** options ): s = 0 for i in values : s = s + i if \"neg\" in options : if options [ \"neg\" ]: s = - s return s s = sum ( 1 , 2 , 3 , 4 , 5 ) # returns 15 s = sum ( 1 , 2 , 3 , 4 , 5 , neg = True ) # returns -15 s = sum ( 1 , 2 , 3 , 4 , 5 , neg = False ) # returns 15","title":"(star) *"},{"location":"PR/pyOp7/#star-operator","text":"The single star * unpacks the sequence/collection into positional arguments, so you can do this: def sum ( a , b ): return a + b values = ( 1 , 2 ) s = sum ( * values ) print ( s ) s = sum ( 1 , 2 ) #The same print ( s ) 3 3 The double star ** does the same, only using a dictionary and thus named arguments: values = { 'a' : 1 , 'b' : 2 } s = sum ( ** values ) print ( s ) 3 Combining the two: def sum ( a , b , c , d ): return a + b + c + d values1 = ( 1 , 2 ) values2 = { 'c' : 10 , 'd' : 15 } s = sum ( * values1 , ** values2 ) print ( s ) # the same as s = sum ( 1 , 2 , c = 10 , d = 15 ) print ( s ) 28 28 Additionally you can define functions to take x and *y arguments, this allows a function to accept any number of positional and/or named arguments that aren't specifically named in the declaration. def sum ( * values ): s = 0 for v in values : s = s + v return s s = sum ( 1 , 2 , 3 , 4 , 5 ) print ( s ) 15 or with ** def get_a ( ** values ): return values [ 'a' ] s = get_a ( a = 1 , b = 2 ) # returns 1 print ( s ) 1 this can allow you to specify a large number of optional parameters without having to declare them. And again, you can combine: def sum ( * values , ** options ): s = 0 for i in values : s = s + i if \"neg\" in options : if options [ \"neg\" ]: s = - s return s s = sum ( 1 , 2 , 3 , 4 , 5 ) # returns 15 s = sum ( 1 , 2 , 3 , 4 , 5 , neg = True ) # returns -15 s = sum ( 1 , 2 , 3 , 4 , 5 , neg = False ) # returns 15","title":"(Star) * Operator"},{"location":"PR/pyStr1/","text":"Backslashes can also be used to escape tabs or arbitrary Unicode characters. \\n represents a new line. Similarly, \\t represents a tab. Newlines will be automatically added for strings that are created using three quotes. This makes it easier to format long, multi-line texts without the need to explicitly put \\n for line breaks. print ( \"Hugo \\' s house \\n Jane \\' s mother \\t Diana \\' s dog\" ) print ( \"\"\"This is multline text\"\"\" ) print ( \"That's \\\" cool \\\" \" ) print ( \"Look, a mountain: / \\\\ \" ) print ( \"1 \\n 2 3\" ) Hugo's house Jane's mother Diana's dog This is multline text That's \"cool\" Look, a mountain: /\\ 1 2 3","title":"Backslashes"},{"location":"PR/pyStr2/","text":"String Operations : (+) concatenation (*) multiplication - Strings can also be multiplied by integers. This produces a repeated version of the original string. User Input : The input function prompts the user for input, and returns what they enter as a string print ( \"spam\" + \" eggs\" ) print ( \"spam \" * 3 ) name = input ( \"your name is?\" ) print ( \"Hello \" + name ) spam eggs spam spam spam your name is?Carlos Hello Carlos","title":"String operations"},{"location":"PR/pyStr3/","text":"str.format() String formatting uses a string's format method to substitute a number of arguments in the string. Each argument of the format function is placed in the string at the corresponding position, which is determined using the curly braces { }. # String formatting nums = [ 1 , 2 , 3 ] msg = \"Numbers {0} {1} {2} \" . format ( nums [ 1 ], nums [ 0 ], nums [ 2 ]) print ( msg ) Numbers 2 1 3 String formatting can also be done with named arguments. a = \" {x} , {y} \" . format ( y = 12 , x = 4 ) print ( a ) 4 , 12 x = 42 print ( 'The number is {:b} ' . format ( x )) The number is 101010 count(str) returns how many times the str substring appears in the given string. upper() converts the string to uppercase. lower() converts the string to lowercase. replace(old, new) replaces all occurrences of old with new. len(str) returns the length of the string (number of characters). Note, that these functions return a new string with the corresponding manipulation Fstrings (Literal String Interpolation) After Python 3.6, to create an f-string, prefix the string with the letter \u201c f \u201d. The string itself can be formatted in much the same way that you would with str.format(). F-strings provide a concise and convenient way to embed python expressions inside string literals for formatting. Simply it is a shortcut for the format method. # Prints today's date with help # of datetime library import datetime today = datetime . datetime . today () print ( f \" { today : %B %d, %Y } \" ) July 30, 2021 name = \"Eric Idle\" f \" { name . lower () } is funny.\" eric idle is funny. x = 42 print ( f 'The number is { x : b } ' ) The number is 101010 name = 'CarPool' age = 23 print ( f \"Hello, My name is { name } and I'm { age } years old.\" ) Hello, My name is CarPool and I'm 23 years old. Template string from string import Template def main (): # Usual string formatting with format() str1 = \"Love {0} and {1} \" . format ( \"Pollo\" , \"Pitas\" ) print ( str1 ) # create a template with placeholders templ = Template ( \"Love $ {title} and $ {author} \" ) # use the substitute method with keyword arguments str2 = templ . substitute ( title = \"Pollo\" , author = \"Pitas\" ) print ( str2 ) # use the substitute method with a dictionary data = { \"author\" : \"Pitas\" , \"title\" : \"Pollo\" } str3 = templ . substitute ( data ) print ( str3 ) if __name__ == \"__main__\" : main () Love Pollo and Pitas Love Pollo and Pitas Love Pollo and Pitas","title":"String formatting"},{"location":"PR/pyStr3/#strformat","text":"String formatting uses a string's format method to substitute a number of arguments in the string. Each argument of the format function is placed in the string at the corresponding position, which is determined using the curly braces { }. # String formatting nums = [ 1 , 2 , 3 ] msg = \"Numbers {0} {1} {2} \" . format ( nums [ 1 ], nums [ 0 ], nums [ 2 ]) print ( msg ) Numbers 2 1 3 String formatting can also be done with named arguments. a = \" {x} , {y} \" . format ( y = 12 , x = 4 ) print ( a ) 4 , 12 x = 42 print ( 'The number is {:b} ' . format ( x )) The number is 101010 count(str) returns how many times the str substring appears in the given string. upper() converts the string to uppercase. lower() converts the string to lowercase. replace(old, new) replaces all occurrences of old with new. len(str) returns the length of the string (number of characters). Note, that these functions return a new string with the corresponding manipulation","title":"str.format()"},{"location":"PR/pyStr3/#fstrings-literal-string-interpolation","text":"After Python 3.6, to create an f-string, prefix the string with the letter \u201c f \u201d. The string itself can be formatted in much the same way that you would with str.format(). F-strings provide a concise and convenient way to embed python expressions inside string literals for formatting. Simply it is a shortcut for the format method. # Prints today's date with help # of datetime library import datetime today = datetime . datetime . today () print ( f \" { today : %B %d, %Y } \" ) July 30, 2021 name = \"Eric Idle\" f \" { name . lower () } is funny.\" eric idle is funny. x = 42 print ( f 'The number is { x : b } ' ) The number is 101010 name = 'CarPool' age = 23 print ( f \"Hello, My name is { name } and I'm { age } years old.\" ) Hello, My name is CarPool and I'm 23 years old.","title":"Fstrings (Literal String Interpolation)"},{"location":"PR/pyStr3/#template-string","text":"from string import Template def main (): # Usual string formatting with format() str1 = \"Love {0} and {1} \" . format ( \"Pollo\" , \"Pitas\" ) print ( str1 ) # create a template with placeholders templ = Template ( \"Love $ {title} and $ {author} \" ) # use the substitute method with keyword arguments str2 = templ . substitute ( title = \"Pollo\" , author = \"Pitas\" ) print ( str2 ) # use the substitute method with a dictionary data = { \"author\" : \"Pitas\" , \"title\" : \"Pollo\" } str3 = templ . substitute ( data ) print ( str3 ) if __name__ == \"__main__\" : main () Love Pollo and Pitas Love Pollo and Pitas Love Pollo and Pitas","title":"Template string"},{"location":"PR/pyStr4/","text":"\u201c Format specifications \u201d are used within replacement fields contained within a format string to define how individual values are presented A general convention is that an empty format specification produces the same result as if you had called str() on the value. A non-empty format specification typically modifies the result. The general form of a standard format specifier is: format_spec [[fill]align][sign][#][0][width][grouping_option][.precision][type] fill any character align \"<\" , \">\" , \"=\" , \"^\" sign \"+\" , \"-\" , \" \" width digit+ grouping_option \"_\" , \",\" precision digit+ type \"b\", \"c\" , \"d\" , \"e\" , \"E\" , \"f\" , \"F\" , \"g\" , \"G\" , \"n\" , \"o\" , \"s\" , \"x\" , \"X\" , \"%\" Fill If a valid align value is specified, it can be preceded by a fill character that can be any character and defaults to a space if omitted. It is not possible to use a literal curly brace (\u201c{\u201d or \u201c}\u201d) as the fill character in a formatted string literal or when using the str.format() method. However, it is possible to insert a curly brace with a nested replacement field. This limitation doesn\u2019t affect the format() function. Align The meaning of the various alignment options is as follows: Option Meaning '<' Forces the field to be left-aligned within the available space (this is the default for most objects) '>' Forces the field to be right-aligned within the available space (this is the default for numbers) '=' Forces the padding to be placed after the sign (if any) but before the digits. This is used for printing fields in the form \u2018+000000120\u2019. This alignment option is only valid for numeric types. It becomes the default for numbers when \u20180\u2019 immediately precedes the field width '^' Forces the field to be centered within the available space ' {:>30} ' . format ( 'right aligned' ) right aligned ' {:*^30} ' . format ( 'centered' ) # use '*' as a fill char ***********centered*********** Sign Note that unless a minimum field width is defined, the field width will always be the same size as the data to fill it, so that the alignment option has no meaning in this case. The sign option is only valid for number types, and can be one of the following: Option Meaning '+' indicates that a sign should be used for both positive as well as negative numbers. '-' indicates that a sign should be used only for negative numbers (this is the default behavior). space indicates that a leading space should be used on positive numbers, and a minus sign on negative numbers. ' {:+f} ; {:+f} ' . format ( 3.14 , - 3.14 ) # show it always +3.140000; -3.140000 ' {: f} ; {: f} ' . format ( 3.14 , - 3.14 ) # show a space for positive numbers 3.140000; -3.140000 ' {:-f} ; {:-f} ' . format ( 3.14 , - 3.14 ) # show only the minus -- same as '{:f}; {:f}' 3.140000; -3.140000 # and , and _ Option '#' option The '#' option causes the \u201calternate form\u201d to be used for the conversion. The alternate form is defined differently for different types. This option is only valid for integer, float and complex types. For integers, when binary, octal, or hexadecimal output is used, this option adds the respective prefix '0b', '0o', '0x', or '0X' to the output value. For float and complex the alternate form causes the result of the conversion to always contain a decimal-point character, even if no digits follow it. Normally, a decimal-point character appears in the result of these conversions only if a digit follows it. In addition, for 'g' and 'G' conversions, trailing zeros are not removed from the result. 'Integer in Octal: {:#o} ' . format ( 1234567 ) Correct answers: 0o4553207 'Integer in Octal: {:o} ' . format ( 1234567 ) Correct answers: 4553207 ',' option The ',' option signals the use of a comma for a thousands separator. For a locale aware separator, use the 'n' integer presentation type instead. see PEP378 ' {:,} ' . format ( 1234567890 ) 1,234,567,890 format ( 1234.5 , \"08,.1f\" ) 01,234.5 '_' option The '_' option signals the use of an underscore for a thousands separator for floating point presentation types and for integer presentation type 'd'. For integer presentation types 'b', 'o', 'x', and 'X', underscores will be inserted every 4 digits. For other presentation types, specifying this option is an error. #{:10_} for a width of 10 with _ separator. format ( 1234.5 , \"08_.1f\" ) 01_234.5 Width width is a decimal integer defining the minimum total field width, including any prefixes, separators, and other formatting characters. If not specified, then the field width will be determined by the content. When no explicit alignment is given, preceding the width field by a zero ('0') character enables sign-aware zero-padding for numeric types. This is equivalent to a fill character of '0' with an alignment type of '='. Changed in version 3.10: Preceding the width field by '0' no longer affects the default alignment for strings. Precision The precision is a decimal integer indicating how many digits should be displayed after the decimal point for presentation types 'f' and 'F', or before and after the decimal point for presentation types 'g' or 'G'. For string presentation types the field indicates the maximum field size - in other words, how many characters will be used from the field content. The precision is not allowed for integer presentation types. points = 19 total = 22 'Correct answers: {:.2%} ' . format ( points / total ) Correct answers: 86.36% Type The type determines how the data should be presented. for strings The available string presentation types are: Type Meaning 's' String format. This is the default type for strings and may be omitted. None The same as 's'. for integers The available integer presentation types are: Type Meaning 'b' Binary format. Outputs the number in base 2. 'c' Character. Converts the integer to the corresponding unicode character before printing. 'd' Octal format. Outputs the number in base 8. 'o' Character. Converts the integer to the corresponding unicode character before printing. 'x' Hex format. Outputs the number in base 16, using lower-case letters for the digits above 9. 'X' Hex format. Outputs the number in base 16, using upper-case letters for the digits above 9. In case '#' is specified, the prefix '0x' will be upper-cased to '0X' as well. 'n' Number. This is the same as 'd', except that it uses the current locale setting to insert the appropriate number separator characters. None The same as 'd'. In addition to the above presentation types, integers can be formatted with the floating point presentation types listed below (except 'n' and None). When doing so, float() is used to convert the integer to a floating point number before formatting. for float and decimal The available presentation types for float and Decimal values are: Type Meaning 'e' Scientific notation. For a given precision p, formats the number in scientific notation with the letter \u2018e\u2019 separating the coefficient from the exponent. The coefficient has one digit before and p digits after the decimal point, for a total of p + 1 significant digits. With no precision given, uses a precision of 6 digits after the decimal point for float, and shows all coefficient digits for Decimal. If no digits follow the decimal point, the decimal point is also removed unless the # option is used. 'E' Scientific notation. Same as 'e' except it uses an upper case \u2018E\u2019 as the separator character. 'f' Fixed-point notation. For a given precision p, formats the number as a decimal number with exactly p digits following the decimal point. With no precision given, uses a precision of 6 digits after the decimal point for float, and uses a precision large enough to show all coefficient digits for Decimal. If no digits follow the decimal point, the decimal point is also removed unless the # option is used. 'F' Fixed-point notation. Same as 'f', but converts nan to NAN and inf to INF. 'g' General format. For a given precision p >= 1, this rounds the number to p significant digits and then formats the result in either fixed-point format or in scientific notation, depending on its magnitude. A precision of 0 is treated as equivalent to a precision of 1. The precise rules are as follows: suppose that the result formatted with presentation type 'e' and precision p-1 would have exponent exp. Then, if m <= exp < p, where m is -4 for floats and -6 for Decimals, the number is formatted with presentation type 'f' and precision p-1-exp. Otherwise, the number is formatted with presentation type 'e' and precision p-1. In both cases insignificant trailing zeros are removed from the significand, and the decimal point is also removed if there are no remaining digits following it, unless the '#' option is used. With no precision given, uses a precision of 6 significant digits for float. For Decimal, the coefficient of the result is formed from the coefficient digits of the value; scientific notation is used for values smaller than 1e-6 in absolute value and values where the place value of the least significant digit is larger than 1, and fixed-point notation is used otherwise. Positive and negative infinity, positive and negative zero, and nans, are formatted as inf, -inf, 0, -0 and nan respectively, regardless of the precision. 'G' General format. Same as 'g' except switches to 'E' if the number gets too large. The representations of infinity and NaN are uppercased, too. 'n' Number. This is the same as 'g', except that it uses the current locale setting to insert the appropriate number separator characters. '%' Percentage. Multiplies the number by 100 and displays in fixed ('f') format, followed by a percent sign. None For float this is the same as 'g', except that when fixed-point notation is used to format the result, it always includes at least one digit past the decimal point. The precision used is as large as needed to represent the given value faithfully. For Decimal, this is the same as either 'g' or 'G' depending on the value of context.capitals for the current decimal context. The overall effect is to match the output of str() as altered by the other format modifiers.","title":"String formatting specifications"},{"location":"PR/pyStr4/#fill","text":"If a valid align value is specified, it can be preceded by a fill character that can be any character and defaults to a space if omitted. It is not possible to use a literal curly brace (\u201c{\u201d or \u201c}\u201d) as the fill character in a formatted string literal or when using the str.format() method. However, it is possible to insert a curly brace with a nested replacement field. This limitation doesn\u2019t affect the format() function.","title":"Fill"},{"location":"PR/pyStr4/#align","text":"The meaning of the various alignment options is as follows: Option Meaning '<' Forces the field to be left-aligned within the available space (this is the default for most objects) '>' Forces the field to be right-aligned within the available space (this is the default for numbers) '=' Forces the padding to be placed after the sign (if any) but before the digits. This is used for printing fields in the form \u2018+000000120\u2019. This alignment option is only valid for numeric types. It becomes the default for numbers when \u20180\u2019 immediately precedes the field width '^' Forces the field to be centered within the available space ' {:>30} ' . format ( 'right aligned' ) right aligned ' {:*^30} ' . format ( 'centered' ) # use '*' as a fill char ***********centered***********","title":"Align"},{"location":"PR/pyStr4/#sign","text":"Note that unless a minimum field width is defined, the field width will always be the same size as the data to fill it, so that the alignment option has no meaning in this case. The sign option is only valid for number types, and can be one of the following: Option Meaning '+' indicates that a sign should be used for both positive as well as negative numbers. '-' indicates that a sign should be used only for negative numbers (this is the default behavior). space indicates that a leading space should be used on positive numbers, and a minus sign on negative numbers. ' {:+f} ; {:+f} ' . format ( 3.14 , - 3.14 ) # show it always +3.140000; -3.140000 ' {: f} ; {: f} ' . format ( 3.14 , - 3.14 ) # show a space for positive numbers 3.140000; -3.140000 ' {:-f} ; {:-f} ' . format ( 3.14 , - 3.14 ) # show only the minus -- same as '{:f}; {:f}' 3.140000; -3.140000","title":"Sign"},{"location":"PR/pyStr4/#and-and-_-option","text":"","title":"# and , and _ Option"},{"location":"PR/pyStr4/#option","text":"The '#' option causes the \u201calternate form\u201d to be used for the conversion. The alternate form is defined differently for different types. This option is only valid for integer, float and complex types. For integers, when binary, octal, or hexadecimal output is used, this option adds the respective prefix '0b', '0o', '0x', or '0X' to the output value. For float and complex the alternate form causes the result of the conversion to always contain a decimal-point character, even if no digits follow it. Normally, a decimal-point character appears in the result of these conversions only if a digit follows it. In addition, for 'g' and 'G' conversions, trailing zeros are not removed from the result. 'Integer in Octal: {:#o} ' . format ( 1234567 ) Correct answers: 0o4553207 'Integer in Octal: {:o} ' . format ( 1234567 ) Correct answers: 4553207","title":"'#' option"},{"location":"PR/pyStr4/#option_1","text":"The ',' option signals the use of a comma for a thousands separator. For a locale aware separator, use the 'n' integer presentation type instead. see PEP378 ' {:,} ' . format ( 1234567890 ) 1,234,567,890 format ( 1234.5 , \"08,.1f\" ) 01,234.5","title":"',' option"},{"location":"PR/pyStr4/#_-option","text":"The '_' option signals the use of an underscore for a thousands separator for floating point presentation types and for integer presentation type 'd'. For integer presentation types 'b', 'o', 'x', and 'X', underscores will be inserted every 4 digits. For other presentation types, specifying this option is an error. #{:10_} for a width of 10 with _ separator. format ( 1234.5 , \"08_.1f\" ) 01_234.5","title":"'_' option"},{"location":"PR/pyStr4/#width","text":"width is a decimal integer defining the minimum total field width, including any prefixes, separators, and other formatting characters. If not specified, then the field width will be determined by the content. When no explicit alignment is given, preceding the width field by a zero ('0') character enables sign-aware zero-padding for numeric types. This is equivalent to a fill character of '0' with an alignment type of '='. Changed in version 3.10: Preceding the width field by '0' no longer affects the default alignment for strings.","title":"Width"},{"location":"PR/pyStr4/#precision","text":"The precision is a decimal integer indicating how many digits should be displayed after the decimal point for presentation types 'f' and 'F', or before and after the decimal point for presentation types 'g' or 'G'. For string presentation types the field indicates the maximum field size - in other words, how many characters will be used from the field content. The precision is not allowed for integer presentation types. points = 19 total = 22 'Correct answers: {:.2%} ' . format ( points / total ) Correct answers: 86.36%","title":"Precision"},{"location":"PR/pyStr4/#type","text":"The type determines how the data should be presented.","title":"Type"},{"location":"PR/pyStr4/#for-strings","text":"The available string presentation types are: Type Meaning 's' String format. This is the default type for strings and may be omitted. None The same as 's'.","title":"for strings"},{"location":"PR/pyStr4/#for-integers","text":"The available integer presentation types are: Type Meaning 'b' Binary format. Outputs the number in base 2. 'c' Character. Converts the integer to the corresponding unicode character before printing. 'd' Octal format. Outputs the number in base 8. 'o' Character. Converts the integer to the corresponding unicode character before printing. 'x' Hex format. Outputs the number in base 16, using lower-case letters for the digits above 9. 'X' Hex format. Outputs the number in base 16, using upper-case letters for the digits above 9. In case '#' is specified, the prefix '0x' will be upper-cased to '0X' as well. 'n' Number. This is the same as 'd', except that it uses the current locale setting to insert the appropriate number separator characters. None The same as 'd'. In addition to the above presentation types, integers can be formatted with the floating point presentation types listed below (except 'n' and None). When doing so, float() is used to convert the integer to a floating point number before formatting.","title":"for integers"},{"location":"PR/pyStr4/#for-float-and-decimal","text":"The available presentation types for float and Decimal values are: Type Meaning 'e' Scientific notation. For a given precision p, formats the number in scientific notation with the letter \u2018e\u2019 separating the coefficient from the exponent. The coefficient has one digit before and p digits after the decimal point, for a total of p + 1 significant digits. With no precision given, uses a precision of 6 digits after the decimal point for float, and shows all coefficient digits for Decimal. If no digits follow the decimal point, the decimal point is also removed unless the # option is used. 'E' Scientific notation. Same as 'e' except it uses an upper case \u2018E\u2019 as the separator character. 'f' Fixed-point notation. For a given precision p, formats the number as a decimal number with exactly p digits following the decimal point. With no precision given, uses a precision of 6 digits after the decimal point for float, and uses a precision large enough to show all coefficient digits for Decimal. If no digits follow the decimal point, the decimal point is also removed unless the # option is used. 'F' Fixed-point notation. Same as 'f', but converts nan to NAN and inf to INF. 'g' General format. For a given precision p >= 1, this rounds the number to p significant digits and then formats the result in either fixed-point format or in scientific notation, depending on its magnitude. A precision of 0 is treated as equivalent to a precision of 1. The precise rules are as follows: suppose that the result formatted with presentation type 'e' and precision p-1 would have exponent exp. Then, if m <= exp < p, where m is -4 for floats and -6 for Decimals, the number is formatted with presentation type 'f' and precision p-1-exp. Otherwise, the number is formatted with presentation type 'e' and precision p-1. In both cases insignificant trailing zeros are removed from the significand, and the decimal point is also removed if there are no remaining digits following it, unless the '#' option is used. With no precision given, uses a precision of 6 significant digits for float. For Decimal, the coefficient of the result is formed from the coefficient digits of the value; scientific notation is used for values smaller than 1e-6 in absolute value and values where the place value of the least significant digit is larger than 1, and fixed-point notation is used otherwise. Positive and negative infinity, positive and negative zero, and nans, are formatted as inf, -inf, 0, -0 and nan respectively, regardless of the precision. 'G' General format. Same as 'g' except switches to 'E' if the number gets too large. The representations of infinity and NaN are uppercased, too. 'n' Number. This is the same as 'g', except that it uses the current locale setting to insert the appropriate number separator characters. '%' Percentage. Multiplies the number by 100 and displays in fixed ('f') format, followed by a percent sign. None For float this is the same as 'g', except that when fixed-point notation is used to format the result, it always includes at least one digit past the decimal point. The precision used is as large as needed to represent the given value faithfully. For Decimal, this is the same as either 'g' or 'G' depending on the value of context.capitals for the current decimal context. The overall effect is to match the output of str() as altered by the other format modifiers.","title":"for float and decimal"},{"location":"PR/pyStr5/","text":"Python contains many useful built-in functions and methods to accomplish common tasks. join joins a list of strings with another string as a separator. print ( \", \" . join ([ \"spam\" , \"eggs\" , \"ham\" ])) spam, eggs, ham replace replaces one substring in a string with another. print ( \"Hello Me\" . replace ( \"Me\" , \"Ham\" )) Hello Ham startswith and endswith determine if there is a substring at the start and end of a string, respectively. find and rfind search for a substr in a larger str. returns the index or -1 if not found. rfind starts from the right end to search. (Use the in operator for boolean result) print ( \"Hello Me\" . find ( 'lo' )) print ( \"Hello Me\" . find ( 'lop' )) print ( \"Hello Me\" . rfind ( 'lo' )) print ( \"lo\" in \"Hello Me\" ) 3 -1 3 True lower and upper To change the case of a string, you can use lower and upper. split is the opposite of join turning a string with a certain separator into a list. print ( \"spam, eggs, ham\" . split ( \", \" )) ['spam', 'eggs', 'ham'] count to count the number of times a substring is present. print ( \"Me Hello Me\" . count ( \"Me\" )) print ( \"Me Hello Me\" . count ( \"Meh\" )) 2 0","title":"String functions"},{"location":"PR/pyStr5/#join","text":"joins a list of strings with another string as a separator. print ( \", \" . join ([ \"spam\" , \"eggs\" , \"ham\" ])) spam, eggs, ham","title":"join"},{"location":"PR/pyStr5/#replace","text":"replaces one substring in a string with another. print ( \"Hello Me\" . replace ( \"Me\" , \"Ham\" )) Hello Ham","title":"replace"},{"location":"PR/pyStr5/#startswith-and-endswith","text":"determine if there is a substring at the start and end of a string, respectively.","title":"startswith and endswith"},{"location":"PR/pyStr5/#find-and-rfind","text":"search for a substr in a larger str. returns the index or -1 if not found. rfind starts from the right end to search. (Use the in operator for boolean result) print ( \"Hello Me\" . find ( 'lo' )) print ( \"Hello Me\" . find ( 'lop' )) print ( \"Hello Me\" . rfind ( 'lo' )) print ( \"lo\" in \"Hello Me\" ) 3 -1 3 True","title":"find and rfind"},{"location":"PR/pyStr5/#lower-and-upper","text":"To change the case of a string, you can use lower and upper.","title":"lower and upper"},{"location":"PR/pyStr5/#split","text":"is the opposite of join turning a string with a certain separator into a list. print ( \"spam, eggs, ham\" . split ( \", \" )) ['spam', 'eggs', 'ham']","title":"split"},{"location":"PR/pyStr5/#count","text":"to count the number of times a substring is present. print ( \"Me Hello Me\" . count ( \"Me\" )) print ( \"Me Hello Me\" . count ( \"Meh\" )) 2 0","title":"count"},{"location":"PR/pyVar1/","text":"In Python, we store all pieces of data -- numbers, characters, strings, everything -- as objects, and we refer to these objects using variables. As a simple case, we can assign a variable a value using the assignment operator, which is the \"equals\" sign. Python's order of operations is the same as that of normal mathematics: parentheses first, then exponentiation, then multiplication/division, and then addition/subtraction. x = 4 y = 5 z = x + y print ( z ) stri = \"Hello\" # or stri='Hello' No difference in python between \"\" and '' print ( stri + str ( z )) a = True print ( a ) b = ( 1 == 3 ) print ( b ) 9 Hello9 True False Three tools for understanding strange objects type() function type() (what is this thing?) To inspect which type is a variable use type(). dir() function dir() (what can I do with it?) help() function help() (tell me more) print ( type ( z )) print ( type ( a )) print ( type ( stri )) print ( dir ( 2 )) #print(help(2)) <class 'int'> <class 'int'> <class 'str'> ['__abs__', '__add__', '__and__', '__bool__', '__ceil__', '__class__', '__delattr__', '__dir__', '__divmod__', '__doc__', '__eq__', '__float__', '__floor__', '__floordiv__', '__format__', '__ge__', '__getattribute__', '__getnewargs__', '__gt__', '__hash__', '__index__', '__init__', '__init_subclass__', '__int__', '__invert__', '__le__', '__lshift__', '__lt__', '__mod__', '__mul__', '__ne__', '__neg__', '__new__', '__or__', '__pos__', '__pow__', '__radd__', '__rand__', '__rdivmod__', '__reduce__', '__reduce_ex__', '__repr__', '__rfloordiv__', '__rlshift__', '__rmod__', '__rmul__', '__ror__', '__round__', '__rpow__', '__rrshift__', '__rshift__', '__rsub__', '__rtruediv__', '__rxor__', '__setattr__', '__sizeof__', '__str__', '__sub__', '__subclasshook__', '__truediv__', '__trunc__', '__xor__', 'bit_length', 'conjugate', 'denominator', 'from_bytes', 'imag', 'numerator', 'real', 'to_bytes'] Python supports addition (+), substraction(-), multiplication( ), division(/),exponentiation( *), quotient (//) and remainder(%). You can chain exponentiations together. In other words, you can rise a number to multiple powers. id() function The id() function returns identity (unique integer) of an object. print ( 'id of 5 =' , id ( 5 )) a = 5 print ( 'id of a =' , id ( a )) b = a print ( 'id of b =' , id ( b )) c = 5.0 print ( 'id of c =' , id ( c )) id of 5 = 94364870744704 id of a = 94364870744704 id of b = 94364870744704 id of c = 140097885531312 It's important to note that everything in Python is an object, even numbers, and Classes. Hence, integer 5 has a unique id. The id of the integer 5 remains constant during the lifetime. Similar is the case for float 5.5 and other objects. isinstance() function To verify the type of an object, the isinstance() function checks if the object (first argument) is an instance or subclass of classinfo class (second argument). The None Object The None object is used to represent the absence of a value. It is similar to null in other programming languages. The None object is returned by any function that doesn't explicitly return anything else.","title":"Variables"},{"location":"PR/pyVar1/#three-tools-for-understanding-strange-objects","text":"","title":"Three tools for understanding strange objects"},{"location":"PR/pyVar1/#type-function","text":"type() (what is this thing?) To inspect which type is a variable use type().","title":"type() function"},{"location":"PR/pyVar1/#dir-function","text":"dir() (what can I do with it?)","title":"dir() function"},{"location":"PR/pyVar1/#help-function","text":"help() (tell me more) print ( type ( z )) print ( type ( a )) print ( type ( stri )) print ( dir ( 2 )) #print(help(2)) <class 'int'> <class 'int'> <class 'str'> ['__abs__', '__add__', '__and__', '__bool__', '__ceil__', '__class__', '__delattr__', '__dir__', '__divmod__', '__doc__', '__eq__', '__float__', '__floor__', '__floordiv__', '__format__', '__ge__', '__getattribute__', '__getnewargs__', '__gt__', '__hash__', '__index__', '__init__', '__init_subclass__', '__int__', '__invert__', '__le__', '__lshift__', '__lt__', '__mod__', '__mul__', '__ne__', '__neg__', '__new__', '__or__', '__pos__', '__pow__', '__radd__', '__rand__', '__rdivmod__', '__reduce__', '__reduce_ex__', '__repr__', '__rfloordiv__', '__rlshift__', '__rmod__', '__rmul__', '__ror__', '__round__', '__rpow__', '__rrshift__', '__rshift__', '__rsub__', '__rtruediv__', '__rxor__', '__setattr__', '__sizeof__', '__str__', '__sub__', '__subclasshook__', '__truediv__', '__trunc__', '__xor__', 'bit_length', 'conjugate', 'denominator', 'from_bytes', 'imag', 'numerator', 'real', 'to_bytes'] Python supports addition (+), substraction(-), multiplication( ), division(/),exponentiation( *), quotient (//) and remainder(%). You can chain exponentiations together. In other words, you can rise a number to multiple powers.","title":"help() function"},{"location":"PR/pyVar1/#id-function","text":"The id() function returns identity (unique integer) of an object. print ( 'id of 5 =' , id ( 5 )) a = 5 print ( 'id of a =' , id ( a )) b = a print ( 'id of b =' , id ( b )) c = 5.0 print ( 'id of c =' , id ( c )) id of 5 = 94364870744704 id of a = 94364870744704 id of b = 94364870744704 id of c = 140097885531312 It's important to note that everything in Python is an object, even numbers, and Classes. Hence, integer 5 has a unique id. The id of the integer 5 remains constant during the lifetime. Similar is the case for float 5.5 and other objects.","title":"id() function"},{"location":"PR/pyVar1/#isinstance-function","text":"To verify the type of an object, the isinstance() function checks if the object (first argument) is an instance or subclass of classinfo class (second argument).","title":"isinstance() function"},{"location":"PR/pyVar1/#the-none-object","text":"The None object is used to represent the absence of a value. It is similar to null in other programming languages. The None object is returned by any function that doesn't explicitly return anything else.","title":"The None Object"},{"location":"PR/pyVar2/","text":"int() function:To convert it to a number str() function:To convert it to a string float() function: To convert it to a float bool() function: To convert it to a bool age = int ( input ()) print ( \"Your age is \" + str ( age ) + \" years old\" ) 15 Your age is 15 years old numbers = [ 1 , 2 , 3 , 4 , 2 , 5 ] # check if numbers is instance of list result = isinstance ( numbers , list ) print ( result ) True","title":"Type Casting"},{"location":"PR/pyVar3/","text":"The location where we can find a variable and also access it if required is called the scope of a variable. Python resolves names using the so-called LEGB rule, which is named after the Python scope for names. The letters in LEGB stand for Local, Enclosing, Global, and Built-in. When you use nested functions, names are resolved by first checking the local scope or the innermost function\u2019s local scope. Then, Python looks at all enclosing scopes of outer functions from the innermost scope to the outermost scope. If no match is found, then Python looks at the global and built-in scopes. If it can\u2019t find the name, then you\u2019ll get an error. Global Keyword Global variables are the ones that are defined and declared outside any function and are not specified to any function. They can be used by any part of the program. We only need to use the global keyword in a function if we want to do assignments or change the global variable. global is not needed for printing and accessing. Python \u201cassumes\u201d that we want a local variable due to the assignment to s inside of f(), so the first statement throws the error message. Any variable which is changed or created inside of a function is local if it hasn\u2019t been declared as a global variable. To tell Python, that we want to use the global variable, we have to use the keyword \u201cglobal\u201d a = 1 # Uses global because there is no local 'a' def f (): print ( 'Inside f() : ' , a ) # Variable 'a' is redefined as a local def g (): a = 2 print ( 'Inside g() : ' , a ) # Uses global keyword to modify global 'a' def h (): global a a = 3 print ( 'Inside h() : ' , a ) # Global scope print ( 'global : ' , a ) f () print ( 'global : ' , a ) g () print ( 'global : ' , a ) h () print ( 'global : ' , a ) global : 1 Inside f() : 1 global : 1 Inside g() : 2 global : 1 Inside h() : 3 global : 3 Nonlocal Keyword In Python, nonlocal keyword is used in the case of nested functions. This keyword works similar to the global, but rather than global, this keyword declares a variable to point to the variable of outside enclosing function, in case of nested functions. # Python program to demonstrate # nonlocal keyword print ( \"Value of a using nonlocal is : \" , end = \"\" ) def outer (): a = 5 def inner (): nonlocal a a = 10 inner () print ( a ) outer () # demonstrating without non local # inner loop not changing the value of outer a # prints 5 print ( \"Value of a without using nonlocal is : \" , end = \"\" ) def outer (): a = 5 def inner (): a = 10 inner () print ( a ) outer () Value of a using nonlocal is : 10 Value of a without using nonlocal is : 5","title":"Scope of Variables"},{"location":"PR/pyVar3/#global-keyword","text":"Global variables are the ones that are defined and declared outside any function and are not specified to any function. They can be used by any part of the program. We only need to use the global keyword in a function if we want to do assignments or change the global variable. global is not needed for printing and accessing. Python \u201cassumes\u201d that we want a local variable due to the assignment to s inside of f(), so the first statement throws the error message. Any variable which is changed or created inside of a function is local if it hasn\u2019t been declared as a global variable. To tell Python, that we want to use the global variable, we have to use the keyword \u201cglobal\u201d a = 1 # Uses global because there is no local 'a' def f (): print ( 'Inside f() : ' , a ) # Variable 'a' is redefined as a local def g (): a = 2 print ( 'Inside g() : ' , a ) # Uses global keyword to modify global 'a' def h (): global a a = 3 print ( 'Inside h() : ' , a ) # Global scope print ( 'global : ' , a ) f () print ( 'global : ' , a ) g () print ( 'global : ' , a ) h () print ( 'global : ' , a ) global : 1 Inside f() : 1 global : 1 Inside g() : 2 global : 1 Inside h() : 3 global : 3","title":"Global Keyword"},{"location":"PR/pyVar3/#nonlocal-keyword","text":"In Python, nonlocal keyword is used in the case of nested functions. This keyword works similar to the global, but rather than global, this keyword declares a variable to point to the variable of outside enclosing function, in case of nested functions. # Python program to demonstrate # nonlocal keyword print ( \"Value of a using nonlocal is : \" , end = \"\" ) def outer (): a = 5 def inner (): nonlocal a a = 10 inner () print ( a ) outer () # demonstrating without non local # inner loop not changing the value of outer a # prints 5 print ( \"Value of a without using nonlocal is : \" , end = \"\" ) def outer (): a = 5 def inner (): a = 10 inner () print ( a ) outer () Value of a using nonlocal is : 10 Value of a without using nonlocal is : 5","title":"Nonlocal Keyword"},{"location":"PR/pyVar4/","text":"del is used in Python to unset a variable or name. You can use it on variable names, but a more common use is to remove indexes from a list or dictionary. my_list1 = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] print ( my_list1 ) # delete second element of my_list1 del my_list1 [ 1 ] print ( my_list1 ) # slice my_list1 from index 3 to 5 del my_list1 [ 3 : 5 ] print ( my_list1 ) [1, 2, 3, 4, 5, 6, 7, 8, 9] [1, 3, 4, 5, 6, 7, 8, 9] [1, 3, 4, 7, 8, 9] my_dict1 = { \"small\" : \"big\" , \"black\" : \"white\" , \"up\" : \"down\" } print ( my_dict1 ) # delete key-value pair with key \"black\" from my_dict1 del my_dict1 [ \"black\" ] print ( my_dict1 ) {'small': 'big', 'black': 'white', 'up': 'down'} {'small': 'big', 'up': 'down'}","title":"del Keyword"},{"location":"PR/pyWhile/","text":"A while loop is used to repeat a block of code multiple times. The while loop is used in cases when the number of iterations is not known and depends on some calculations and conditions in the code block of the loop. To end a while loop prematurely, the break statement can be used. Another statement that can be used within loops is continue. Unlike break, continue jumps back to the top of the loop, rather than stopping it. Basically, the continue statement stops the current iteration and continues with the next one. i = 1 while i <= 5 : print ( i ) i += 1 print ( \"the end\" ) 1 2 3 4 5 the end","title":"While-loops"},{"location":"PR/pyfor/","text":"Looping statements allow for the repeated execution of a section of code. For instance, suppose we wanted to add up all of the integers between zero (0) and ten (10), not including ten. We could, of course, do this in one line, but we could also use a loop to add each integer one at a time. Below is the code for a simple accumulator that accomplishes this: sum = 0 for i in range ( 10 ): sum = sum + i print ( sum ) alternative_sum = 0 + 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 print ( alternative_sum == sum ) 45 True Range function The range () built-in function generates the sequence of values that we loop over, and notice that range(10) does not include 10 itself. In order to output the range as a list, we need to explicitly convert it to a list, using the list() function. If range is called with one argument, it produces an object with values from 0 to that argument. If it is called with two arguments, it produces values from the first to the second. range can have a third argument, which determines the interval of the sequence produced, also called the step. We can also create list of decreasing numbers, using a negative number as the third argument. numbers = list ( range ( 10 )) print ( numbers ) numbers = list ( range ( 5 , 10 )) print ( numbers ) numbers = list ( range ( 5 , 10 , 2 )) print ( numbers ) print ( list ( range ( 20 , 5 , - 2 ))) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] [5, 6, 7, 8, 9] [5, 7, 9] [20, 18, 16, 14, 12, 10, 8, 6] elements in lists In addition to looping over a sequence of integers using the range() function, we can also loop over the elements in a list, which is shown below: ingredients = [ \"flour\" , \"sugar\" , \"eggs\" , \"oil\" , \"baking soda\" ] for ingredient in ingredients : print ( ingredient ) flour sugar eggs oil baking soda Above, the for-loop iterates over the elements of the list ingredients , and within the loop each of those elements is referred to as ingredient . The use of singular/plural nouns to handle this iteration is a common Python motif, but is by no means necessary to use in your own programming. Break and Continue Similar to while loops, the break and continue statements can be used in for loops, to stop the loop or jump to the next iteration. # use the break and continue statements for x in range ( 5 , 10 ): if ( x == 7 ): break if ( x % 2 == 0 ): continue print ( x ) #using the enumerate() function to get index days = [ \"Mon\" , \"Tue\" , \"Wed\" , \"Thu\" , \"Fri\" , \"Sat\" , \"Sun\" ] for i , d in enumerate ( days ): print ( i , d ) 5 0 Mon 1 Tue 2 Wed 3 Thu 4 Fri 5 Sat 6 Sun","title":"For-loops"},{"location":"PR/pyfor/#range-function","text":"The range () built-in function generates the sequence of values that we loop over, and notice that range(10) does not include 10 itself. In order to output the range as a list, we need to explicitly convert it to a list, using the list() function. If range is called with one argument, it produces an object with values from 0 to that argument. If it is called with two arguments, it produces values from the first to the second. range can have a third argument, which determines the interval of the sequence produced, also called the step. We can also create list of decreasing numbers, using a negative number as the third argument. numbers = list ( range ( 10 )) print ( numbers ) numbers = list ( range ( 5 , 10 )) print ( numbers ) numbers = list ( range ( 5 , 10 , 2 )) print ( numbers ) print ( list ( range ( 20 , 5 , - 2 ))) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] [5, 6, 7, 8, 9] [5, 7, 9] [20, 18, 16, 14, 12, 10, 8, 6]","title":"Range function"},{"location":"PR/pyfor/#elements-in-lists","text":"In addition to looping over a sequence of integers using the range() function, we can also loop over the elements in a list, which is shown below: ingredients = [ \"flour\" , \"sugar\" , \"eggs\" , \"oil\" , \"baking soda\" ] for ingredient in ingredients : print ( ingredient ) flour sugar eggs oil baking soda Above, the for-loop iterates over the elements of the list ingredients , and within the loop each of those elements is referred to as ingredient . The use of singular/plural nouns to handle this iteration is a common Python motif, but is by no means necessary to use in your own programming.","title":"elements in lists"},{"location":"PR/pyfor/#break-and-continue","text":"Similar to while loops, the break and continue statements can be used in for loops, to stop the loop or jump to the next iteration. # use the break and continue statements for x in range ( 5 , 10 ): if ( x == 7 ): break if ( x % 2 == 0 ): continue print ( x ) #using the enumerate() function to get index days = [ \"Mon\" , \"Tue\" , \"Wed\" , \"Thu\" , \"Fri\" , \"Sat\" , \"Sun\" ] for i , d in enumerate ( days ): print ( i , d ) 5 0 Mon 1 Tue 2 Wed 3 Thu 4 Fri 5 Sat 6 Sun","title":"Break and Continue"}]}