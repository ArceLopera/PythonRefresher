{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Python Refresher Everyone can forget about grammar and vocabulary. The most important think is to know where to look. Sections Basics Data Structures Functions Machine Learning Algorithms Exercises","title":"Home"},{"location":"#welcome-to-python-refresher","text":"Everyone can forget about grammar and vocabulary. The most important think is to know where to look.","title":"Welcome to Python Refresher"},{"location":"#sections","text":"Basics Data Structures Functions Machine Learning Algorithms Exercises","title":"Sections"},{"location":"pythonRefresh/","text":"Python is strongly typed (i.e. types are enforced), dynamically, implicitly typed (i.e. you don\u2019t have to declare variables), case sensitive (i.e. var and VAR are two different variables) and object-oriented (i.e. everything is an object, Like C# and Java). A unique aspect of the Python language: indentation. While a language like C uses curly braces to contain code statements within loops or conditionals, Python indicates these statements through indentation. This feature lends Python code readability. Notice the colon at the end of the expression in the for, while and if statement. Python Resources Free e-book Python Like You Mean It , by Ryan Soklaski, will provide a more comprehensive introduction to Python for scientific computing. The website http://www.python.org , Tutorial and doc","title":"General"},{"location":"pythonRefresh/#python-resources","text":"Free e-book Python Like You Mean It , by Ryan Soklaski, will provide a more comprehensive introduction to Python for scientific computing. The website http://www.python.org , Tutorial and doc","title":"Python Resources"},{"location":"DS/pyArray/","text":"An array is a collection of items stored at contiguous memory locations. The idea is to store multiple items of the same type together. This makes it easier to calculate the position of each element by simply adding an offset to a base value, i.e., the memory location of the first element of the array # Python program to demonstrate # Creation of Array # importing \"array\" for array creations import array as arr # creating an array with integer type a = arr . array ( 'i' , [ 1 , 2 , 3 ]) # printing original array print ( \"The new created array is : \" , end = \" \" ) for i in range ( 0 , 3 ): print ( a [ i ], end = \" \" ) print () # creating an array with float type b = arr . array ( 'd' , [ 2.5 , 3.2 , 3.3 ]) # printing original array print ( \"The new created array is : \" , end = \" \" ) for i in range ( 0 , 3 ): print ( b [ i ], end = \" \" ) The new created array is : 1 2 3 The new created array is : 2.5 3.2 3.3 Here are the differences between List and Array in Python : List Array Can consist of elements belonging to different data types Only consists of elements belonging to the same data type No need to explicitly import a module for declaration Need to explicitly import a module for declaration Cannot directly handle arithmetic operations Can directly handle arithmetic operations Can be nested to contain different type of elements Must contain either all nested elements of same size Preferred for shorter sequence of data items Preferred for longer sequence of data items Greater flexibility allows easy modification (addition, deletion) of data Less flexibility since addition, deletion has to be done element wise The entire list can be printed without any explicit looping A loop has to be formed to print or access the components of array Consume larger memory for easy addition of elements Comparatively more compact in memory size","title":"Array"},{"location":"DS/pyChainMap/","text":"A ChainMap encapsulates many dictionaries into a single unit and returns a list of dictionaries. # Python program to demonstrate ChainMap from collections import ChainMap d1 = { 'a' : 1 , 'b' : 2 } d2 = { 'c' : 3 , 'd' : 4 } d3 = { 'e' : 5 , 'f' : 6 } # Defining the chainmap c = ChainMap ( d1 , d2 , d3 ) print ( c ) ChainMap({'a': 1, 'b': 2}, {'c': 3, 'd': 4}, {'e': 5, 'f': 6}) Accessing Keys and Values from ChainMap Values from ChainMap can be accessed using the key name. They can also be accessed by using the keys() and values() method. from collections import ChainMap d1 = { 'a' : 1 , 'b' : 2 } d2 = { 'c' : 3 , 'd' : 4 } d3 = { 'e' : 5 , 'f' : 6 } # Defining the chainmap c = ChainMap ( d1 , d2 , d3 ) # Accessing Values using key name print ( c [ 'a' ]) # Accessing values using values() # method print ( c . values ()) # Accessing keys using keys() # method print ( c . keys ()) 1 ValuesView(ChainMap({'a': 1, 'b': 2}, {'c': 3, 'd': 4}, {'e': 5, 'f': 6})) KeysView(ChainMap({'a': 1, 'b': 2}, {'c': 3, 'd': 4}, {'e': 5, 'f': 6})) Adding new dictionary A new dictionary can be added by using the new_child() method. The newly added dictionary is added at the beginning of the ChainMap. import collections # initializing dictionaries dic1 = { 'a' : 1 , 'b' : 2 } dic2 = { 'b' : 3 , 'c' : 4 } dic3 = { 'f' : 5 } # initializing ChainMap chain = collections . ChainMap ( dic1 , dic2 ) # printing chainMap print ( \"All the ChainMap contents are : \" ) print ( chain ) # using new_child() to add new dictionary chain1 = chain . new_child ( dic3 ) # printing chainMap print ( \"Displaying new ChainMap : \" ) print ( chain1 ) All the ChainMap contents are : ChainMap({'a': 1, 'b': 2}, {'b': 3, 'c': 4}) Displaying new ChainMap : ChainMap({'f': 5}, {'a': 1, 'b': 2}, {'b': 3, 'c': 4})","title":"ChainMap"},{"location":"DS/pyChainMap/#adding-new-dictionary","text":"A new dictionary can be added by using the new_child() method. The newly added dictionary is added at the beginning of the ChainMap. import collections # initializing dictionaries dic1 = { 'a' : 1 , 'b' : 2 } dic2 = { 'b' : 3 , 'c' : 4 } dic3 = { 'f' : 5 } # initializing ChainMap chain = collections . ChainMap ( dic1 , dic2 ) # printing chainMap print ( \"All the ChainMap contents are : \" ) print ( chain ) # using new_child() to add new dictionary chain1 = chain . new_child ( dic3 ) # printing chainMap print ( \"Displaying new ChainMap : \" ) print ( chain1 ) All the ChainMap contents are : ChainMap({'a': 1, 'b': 2}, {'b': 3, 'c': 4}) Displaying new ChainMap : ChainMap({'f': 5}, {'a': 1, 'b': 2}, {'b': 3, 'c': 4})","title":"Adding new dictionary"},{"location":"DS/pyCounter/","text":"A Counter is a subclass of dict. Therefore it is an unordered collection where elements and their respective count are stored as a dictionary. This is equivalent to a bag or multiset of other languages. It is used to keep the count of the elements in an iterable in the form of an unordered dictionary where the key represents the element in the iterable and value represents the count of that element in the iterable. Counter class is a special type of object data-set provided with the collections module in Python3. Collections module provides the user with specialized container datatypes, thus, providing an alternative to Python\u2019s general-purpose built-ins like dictionaries, lists and tuples. Counter is a sub-class that is used to count hashable objects. It implicitly creates a hash table of an iterable when invoked. Counter object along with its functions are used collectively for processing huge amounts of data. Initialization The constructor of counter can be called in any one of the following ways : With sequence of items With dictionary containing keys and counts With keyword arguments mapping string names to counts # A Python program to show different ways to create # Counter from collections import Counter # With sequence of items print ( Counter ([ 'B' , 'B' , 'A' , 'B' , 'C' , 'A' , 'B' , 'B' , 'A' , 'C' ])) # with dictionary print ( Counter ({ 'A' : 3 , 'B' : 5 , 'C' : 2 })) # with keyword arguments print ( Counter ( A = 3 , B = 5 , C = 2 )) Counter({'B': 5, 'A': 3, 'C': 2}) Counter({'B': 5, 'A': 3, 'C': 2}) Counter({'B': 5, 'A': 3, 'C': 2}) Updation We can also create an empty counter and can be updated via update() method # A Python program to demonstrate update() from collections import Counter coun = Counter () coun . update ([ 1 , 2 , 3 , 1 , 2 , 1 , 1 , 2 ]) print ( coun ) coun . update ([ 1 , 2 , 4 ]) print ( coun ) Counter({1: 4, 2: 3, 3: 1}) Counter({1: 5, 2: 4, 3: 1, 4: 1}) Data can be provided in any of the three ways as mentioned in initialization and the counter\u2019s data will be increased not replaced. Counts can be zero and negative also. # Python program to demonstrate that counts in # Counter can be 0 and negative from collections import Counter c1 = Counter ( A = 4 , B = 3 , C = 10 ) c2 = Counter ( A = 10 , B = 3 , C = 4 ) c1 . subtract ( c2 ) print ( c1 ) Counter({'C': 6, 'B': 0, 'A': -6}) We can use Counter to count distinct elements of a list or other collections. # An example program where different list items are # counted using counter from collections import Counter # Create a list z = [ 'blue' , 'red' , 'blue' , 'yellow' , 'blue' , 'red' ] # Count distinct elements and print Counter object print ( Counter ( z )) Counter({'blue': 3, 'red': 2, 'yellow': 1}) Once initialized, counters are accessed just like dictionaries. Also, it does not raise the KeyValue error (if key is not present) instead the value\u2019s count is shown as 0. # Python program to demonstrate accessing of # Counter elements from collections import Counter # Create a list z = [ 'blue' , 'red' , 'blue' , 'yellow' , 'blue' , 'red' ] col_count = Counter ( z ) print ( col_count ) col = [ 'blue' , 'red' , 'yellow' , 'green' ] # Here green is not in col_count # so count of green will be zero for color in col : print ( color , col_count [ color ]) Counter({'blue': 3, 'red': 2, 'yellow': 1}) blue 3 red 2 yellow 1 green 0 items() The Counter.items() method helps to see the elements of the list along with their respective frequencies in a tuple. # importing the module from collections import Counter # making a list list = [ 1 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 9 , 2 , 3 , 4 , 8 ] # instantiating a Counter object ob = Counter ( list ) # Counter.items() items = ob . items () print ( \"The datatype is \" + str ( type ( items ))) # displaying the dict_items print ( items ) # iterating over the dict_items for i in items : print ( i ) The datatype is <class 'dict_items'> dict_items([(1, 2), (2, 2), (3, 2), (4, 2), (5, 1), (6, 1), (7, 1), (9, 1), (8, 1)]) (1, 2) (2, 2) (3, 2) (4, 2) (5, 1) (6, 1) (7, 1) (9, 1) (8, 1) keys() The Counter.keys() method helps to see the unique elements in the list. # importing the module from collections import Counter # making a list list = [ 1 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 9 , 2 , 3 , 4 , 8 ] # instantiating a Counter object ob = Counter ( list ) # Counter.keys() keys = ob . keys () print ( \"The datatype is \" + str ( type ( keys ))) # displaying the dict_items print ( keys ) # iterating over the dict_items for i in keys : print ( i ) The datatype is <class 'dict_keys'> dict_keys([1, 2, 3, 4, 5, 6, 7, 9, 8]) 1 2 3 4 5 6 7 9 8 values() The Counter.values() method helps to see the frequencies of each unique element. # importing the module from collections import Counter # making a list list = [ 1 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 9 , 2 , 3 , 4 , 8 ] # instantiating a Counter object ob = Counter ( list ) # Counter.values() values = ob . values () print ( \"The datatype is \" + str ( type ( values ))) # displaying the dict_items print ( values ) # iterating over the dict_items for i in values : print ( i ) The datatype is <class 'dict_values'> dict_values([2, 2, 2, 2, 1, 1, 1, 1, 1]) 2 2 2 2 1 1 1 1 1 elements() elements() is one of the functions of Counter class, when invoked on the Counter object will return an itertool of all the known elements in the Counter object. The elements() method returns an iterator that produces all of the items known to the Counter. Note : Elements with count <= 0 are not included. # import counter class from collections module from collections import Counter # Creation of a Counter Class object using # a string as an iterable data container # Example - 1 a = Counter ( \"treatortrips\" ) # Elements of counter object for i in a . elements (): print ( i , end = \" \" ) print () # Example - 2 b = Counter ({ 'trips' : 4 , 'for' : 1 , 'gfg' : 2 , 'Trean' : 3 }) for i in b . elements (): print ( i , end = \" \" ) print () # Example - 3 c = Counter ([ 1 , 2 , 21 , 12 , 2 , 44 , 5 , 13 , 15 , 5 , 19 , 21 , 5 ]) for i in c . elements (): print ( i , end = \" \" ) print () # Example - 4 d = Counter ( a = 2 , b = 3 , c = 6 , d = 1 , e = 5 ) for i in d . elements (): print ( i , end = \" \" ) t t t r r r e a o i p s trips trips trips trips for gfg gfg Trean Trean Trean 1 2 2 21 21 12 44 5 5 5 13 15 19 a a b b b c c c c c c d e e e e e most_common() most_common() is used to produce a sequence of the n most frequently encountered input values and their respective counts. # Python example to demonstrate most_elements() on # Counter from collections import Counter coun = Counter ( a = 1 , b = 2 , c = 3 , d = 120 , e = 1 , f = 219 ) # This prints 3 most frequent characters for letter , count in coun . most_common ( 3 ): print ( ' %s : %d ' % ( letter , count )) f: 219 d: 120 c: 3","title":"Counter"},{"location":"DS/pyCounter/#initialization","text":"The constructor of counter can be called in any one of the following ways : With sequence of items With dictionary containing keys and counts With keyword arguments mapping string names to counts # A Python program to show different ways to create # Counter from collections import Counter # With sequence of items print ( Counter ([ 'B' , 'B' , 'A' , 'B' , 'C' , 'A' , 'B' , 'B' , 'A' , 'C' ])) # with dictionary print ( Counter ({ 'A' : 3 , 'B' : 5 , 'C' : 2 })) # with keyword arguments print ( Counter ( A = 3 , B = 5 , C = 2 )) Counter({'B': 5, 'A': 3, 'C': 2}) Counter({'B': 5, 'A': 3, 'C': 2}) Counter({'B': 5, 'A': 3, 'C': 2})","title":"Initialization"},{"location":"DS/pyCounter/#updation","text":"We can also create an empty counter and can be updated via update() method # A Python program to demonstrate update() from collections import Counter coun = Counter () coun . update ([ 1 , 2 , 3 , 1 , 2 , 1 , 1 , 2 ]) print ( coun ) coun . update ([ 1 , 2 , 4 ]) print ( coun ) Counter({1: 4, 2: 3, 3: 1}) Counter({1: 5, 2: 4, 3: 1, 4: 1}) Data can be provided in any of the three ways as mentioned in initialization and the counter\u2019s data will be increased not replaced. Counts can be zero and negative also. # Python program to demonstrate that counts in # Counter can be 0 and negative from collections import Counter c1 = Counter ( A = 4 , B = 3 , C = 10 ) c2 = Counter ( A = 10 , B = 3 , C = 4 ) c1 . subtract ( c2 ) print ( c1 ) Counter({'C': 6, 'B': 0, 'A': -6}) We can use Counter to count distinct elements of a list or other collections. # An example program where different list items are # counted using counter from collections import Counter # Create a list z = [ 'blue' , 'red' , 'blue' , 'yellow' , 'blue' , 'red' ] # Count distinct elements and print Counter object print ( Counter ( z )) Counter({'blue': 3, 'red': 2, 'yellow': 1}) Once initialized, counters are accessed just like dictionaries. Also, it does not raise the KeyValue error (if key is not present) instead the value\u2019s count is shown as 0. # Python program to demonstrate accessing of # Counter elements from collections import Counter # Create a list z = [ 'blue' , 'red' , 'blue' , 'yellow' , 'blue' , 'red' ] col_count = Counter ( z ) print ( col_count ) col = [ 'blue' , 'red' , 'yellow' , 'green' ] # Here green is not in col_count # so count of green will be zero for color in col : print ( color , col_count [ color ]) Counter({'blue': 3, 'red': 2, 'yellow': 1}) blue 3 red 2 yellow 1 green 0","title":"Updation"},{"location":"DS/pyCounter/#items","text":"The Counter.items() method helps to see the elements of the list along with their respective frequencies in a tuple. # importing the module from collections import Counter # making a list list = [ 1 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 9 , 2 , 3 , 4 , 8 ] # instantiating a Counter object ob = Counter ( list ) # Counter.items() items = ob . items () print ( \"The datatype is \" + str ( type ( items ))) # displaying the dict_items print ( items ) # iterating over the dict_items for i in items : print ( i ) The datatype is <class 'dict_items'> dict_items([(1, 2), (2, 2), (3, 2), (4, 2), (5, 1), (6, 1), (7, 1), (9, 1), (8, 1)]) (1, 2) (2, 2) (3, 2) (4, 2) (5, 1) (6, 1) (7, 1) (9, 1) (8, 1)","title":"items()"},{"location":"DS/pyCounter/#keys","text":"The Counter.keys() method helps to see the unique elements in the list. # importing the module from collections import Counter # making a list list = [ 1 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 9 , 2 , 3 , 4 , 8 ] # instantiating a Counter object ob = Counter ( list ) # Counter.keys() keys = ob . keys () print ( \"The datatype is \" + str ( type ( keys ))) # displaying the dict_items print ( keys ) # iterating over the dict_items for i in keys : print ( i ) The datatype is <class 'dict_keys'> dict_keys([1, 2, 3, 4, 5, 6, 7, 9, 8]) 1 2 3 4 5 6 7 9 8","title":"keys()"},{"location":"DS/pyCounter/#values","text":"The Counter.values() method helps to see the frequencies of each unique element. # importing the module from collections import Counter # making a list list = [ 1 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 9 , 2 , 3 , 4 , 8 ] # instantiating a Counter object ob = Counter ( list ) # Counter.values() values = ob . values () print ( \"The datatype is \" + str ( type ( values ))) # displaying the dict_items print ( values ) # iterating over the dict_items for i in values : print ( i ) The datatype is <class 'dict_values'> dict_values([2, 2, 2, 2, 1, 1, 1, 1, 1]) 2 2 2 2 1 1 1 1 1","title":"values()"},{"location":"DS/pyCounter/#elements","text":"elements() is one of the functions of Counter class, when invoked on the Counter object will return an itertool of all the known elements in the Counter object. The elements() method returns an iterator that produces all of the items known to the Counter. Note : Elements with count <= 0 are not included. # import counter class from collections module from collections import Counter # Creation of a Counter Class object using # a string as an iterable data container # Example - 1 a = Counter ( \"treatortrips\" ) # Elements of counter object for i in a . elements (): print ( i , end = \" \" ) print () # Example - 2 b = Counter ({ 'trips' : 4 , 'for' : 1 , 'gfg' : 2 , 'Trean' : 3 }) for i in b . elements (): print ( i , end = \" \" ) print () # Example - 3 c = Counter ([ 1 , 2 , 21 , 12 , 2 , 44 , 5 , 13 , 15 , 5 , 19 , 21 , 5 ]) for i in c . elements (): print ( i , end = \" \" ) print () # Example - 4 d = Counter ( a = 2 , b = 3 , c = 6 , d = 1 , e = 5 ) for i in d . elements (): print ( i , end = \" \" ) t t t r r r e a o i p s trips trips trips trips for gfg gfg Trean Trean Trean 1 2 2 21 21 12 44 5 5 5 13 15 19 a a b b b c c c c c c d e e e e e","title":"elements()"},{"location":"DS/pyCounter/#most_common","text":"most_common() is used to produce a sequence of the n most frequently encountered input values and their respective counts. # Python example to demonstrate most_elements() on # Counter from collections import Counter coun = Counter ( a = 1 , b = 2 , c = 3 , d = 120 , e = 1 , f = 219 ) # This prints 3 most frequent characters for letter , count in coun . most_common ( 3 ): print ( ' %s : %d ' % ( letter , count )) f: 219 d: 120 c: 3","title":"most_common()"},{"location":"DS/pyDS/","text":"Python Collections Iterable Anything that you can loop over using a for loop e.g: list, tuples, strings, set and dictionaries Sequence a subset of Iterables that have: 1. A length 2. An Index 3. Can be sliced e.g: Strings, list, tuples Not dictionaries, sets, files and generators Data Structures Python supports the following data structures: lists, dictionaries, tuples, sets. For arrays, see numpy array. When to use a dictionary: - When you need a logical association between a key:value pair. - When you need fast lookup for your data, based on a custom key. - When your data is being constantly modified. Remember, dictionaries are mutable. When to use the other types: - Use lists if you have a collection of data that does not need random access. Try to choose lists when you need a simple, iterable collection that is modified frequently. - Use a set if you need uniqueness for the elements. - Use tuples when your data cannot change. Many times, a tuple is used in combination with a dictionary, for example, a tuple might represent a key, because it's immutable. Tuples Lists Dict Sets ( ) [ ] {k:v} { } Immutable Mutable Mutable Mutable Ordered Ordered Ordered(>3.7) Unordered Iterable Iterable Iterable Iterable Constant time Linear time Constant time Constant time mytuple[0] mylist[0] mydict['somekey'] myset[0] Allow repetition Allow repetition Allow repetition Unique data len(mytuple) len(mylist) len(mydict) len(myset) .count() .append() and .insert() .keys(), .values() and .items() .add() and .update() .index() .pop() and .remove() .pop() or del mydict['somekey'] .remove() .reverse() and sort()","title":"General"},{"location":"DS/pyDS/#python-collections","text":"","title":"Python Collections"},{"location":"DS/pyDS/#iterable","text":"Anything that you can loop over using a for loop e.g: list, tuples, strings, set and dictionaries","title":"Iterable"},{"location":"DS/pyDS/#sequence","text":"a subset of Iterables that have: 1. A length 2. An Index 3. Can be sliced e.g: Strings, list, tuples Not dictionaries, sets, files and generators","title":"Sequence"},{"location":"DS/pyDS/#data-structures","text":"Python supports the following data structures: lists, dictionaries, tuples, sets. For arrays, see numpy array. When to use a dictionary: - When you need a logical association between a key:value pair. - When you need fast lookup for your data, based on a custom key. - When your data is being constantly modified. Remember, dictionaries are mutable. When to use the other types: - Use lists if you have a collection of data that does not need random access. Try to choose lists when you need a simple, iterable collection that is modified frequently. - Use a set if you need uniqueness for the elements. - Use tuples when your data cannot change. Many times, a tuple is used in combination with a dictionary, for example, a tuple might represent a key, because it's immutable. Tuples Lists Dict Sets ( ) [ ] {k:v} { } Immutable Mutable Mutable Mutable Ordered Ordered Ordered(>3.7) Unordered Iterable Iterable Iterable Iterable Constant time Linear time Constant time Constant time mytuple[0] mylist[0] mydict['somekey'] myset[0] Allow repetition Allow repetition Allow repetition Unique data len(mytuple) len(mylist) len(mydict) len(myset) .count() .append() and .insert() .keys(), .values() and .items() .add() and .update() .index() .pop() and .remove() .pop() or del mydict['somekey'] .remove() .reverse() and sort()","title":"Data Structures"},{"location":"DS/pyDefaultdict/","text":"Dictionary in Python is an unordered collection of data values that are used to store data values like a map. Unlike other Data Types that hold only single value as an element, the Dictionary holds key-value pair. In Dictionary, the key must be unique and immutable. This means that a Python Tuple can be a key whereas a Python List can not. A Dictionary can be created by placing a sequence of elements within curly {} braces, separated by \u2018comma\u2019. # Python program to demonstrate # dictionary Dict = { 1 : 'Treats' , 2 : 'For' , 3 : 'Pricks' } print ( \"Dictionary:\" ) print ( Dict ) print ( Dict [ 1 ]) # Uncommenting this print(Dict[4]) # will raise a KeyError as the # 4 is not present in the dictionary Dictionary: {1: 'Treats', 2: 'For', 3: 'Pricks'} Treats Sometimes, when the KeyError is raised, it might become a problem. To overcome this Python introduces another dictionary like container known as Defaultdict which is present inside the collections module. Defaultdict is a container like dictionaries present in the module collections. Defaultdict is a sub-class of the dictionary class that returns a dictionary-like object. The functionality of both dictionaries and defaultdict are almost same except for the fact that defaultdict never raises a KeyError. It provides a default value for the key that does not exists. # Python program to demonstrate defaultdict from collections import defaultdict # Function to return a default # values for keys that are not present def def_value (): return \"Not Present\" # Defining the dict d = defaultdict ( def_value ) d [ \"a\" ] = 1 d [ \"b\" ] = 2 print ( d [ \"a\" ]) print ( d [ \"b\" ]) print ( d [ \"c\" ]) 1 2 Not Present Inner Working of defaultdict Defaultdict adds one writable instance variable and one method in addition to the standard dictionary operations. The instance variable is the default_factory parameter and the method provided is missing. Default_factory: It is a function returning the default value for the dictionary defined. If this argument is absent then the dictionary raises a KeyError. # Python program to demonstrate # default_factory argument of # defaultdict from collections import defaultdict # Defining the dict and passing # lambda as default_factory argument d = defaultdict ( lambda : \"Not Present\" ) d [ \"a\" ] = 1 d [ \"b\" ] = 2 print ( d [ \"a\" ]) print ( d [ \"b\" ]) print ( d [ \"c\" ]) 1 2 Not Present from collections import defaultdict # Correct instantiation def_dict = defaultdict ( list ) # Pass list to .default_factory def_dict [ 'one' ] = 1 # Add a key-value pair def_dict [ 'missing' ] # Access a missing key returns an empty list [] def_dict [ 'another_missing' ] . append ( 4 ) # Modify a missing key def_dict defaultdict(list, {'another_missing': [4], 'missing': [], 'one': 1}) dep = [( 'Sales' , 'John Doe' ), ( 'Sales' , 'Martin Smith' ), ( 'Accounting' , 'Jane Doe' ), ( 'Marketing' , 'Elizabeth Smith' ), ( 'Marketing' , 'Adam Doe' )] from collections import defaultdict dep_dd = defaultdict ( list ) #For uniqueness instead of list use set for department , employee in dep : dep_dd [ department ] . append ( employee ) print ( dep_dd ) defaultdict(<class 'list'>, {'Sales': ['John Doe', 'Martin Smith'], 'Accounting': ['Jane Doe'], 'Marketing': ['Elizabeth Smith', 'Adam Doe']}) In this example, you group the employees by their department using a defaultdict with .default_factory set to list. To do this with a regular dictionary, you can use dict.setdefault() as follows: dep_d = dict () for department , employee in dep : dep_d . setdefault ( department , []) . append ( employee ) print ( dep_d ) {'Sales': ['John Doe', 'Martin Smith'], 'Accounting': ['Jane Doe'], 'Marketing': ['Elizabeth Smith', 'Adam Doe']} This code is straightforward, and you\u2019ll find similar code quite often in your work as a Python coder. However, the defaultdict version is arguably more readable, and for large datasets, it can also be a lot faster and more efficient. So, if speed is a concern for you, then you should consider using a defaultdict instead of a standard dict. Auto-vivification Defauldict are used to easily make nested dicts. It is called Auto-vivification. from collections import defaultdict import json def turtles (): return defaultdict ( turtles ) data = turtles () data [ \"Hello\" ] = \"Hey!\" data [ \"Foo\" ][ \"bar\" ][ \"baz\" ] = \"hmmm\" print ( json . dumps ( data , indent = 1 )) { \"Hello\": \"Hey!\", \"Foo\": { \"bar\": { \"baz\": \"hmmm\" } } }","title":"Defaultdict"},{"location":"DS/pyDefaultdict/#inner-working-of-defaultdict","text":"Defaultdict adds one writable instance variable and one method in addition to the standard dictionary operations. The instance variable is the default_factory parameter and the method provided is missing. Default_factory: It is a function returning the default value for the dictionary defined. If this argument is absent then the dictionary raises a KeyError. # Python program to demonstrate # default_factory argument of # defaultdict from collections import defaultdict # Defining the dict and passing # lambda as default_factory argument d = defaultdict ( lambda : \"Not Present\" ) d [ \"a\" ] = 1 d [ \"b\" ] = 2 print ( d [ \"a\" ]) print ( d [ \"b\" ]) print ( d [ \"c\" ]) 1 2 Not Present from collections import defaultdict # Correct instantiation def_dict = defaultdict ( list ) # Pass list to .default_factory def_dict [ 'one' ] = 1 # Add a key-value pair def_dict [ 'missing' ] # Access a missing key returns an empty list [] def_dict [ 'another_missing' ] . append ( 4 ) # Modify a missing key def_dict defaultdict(list, {'another_missing': [4], 'missing': [], 'one': 1}) dep = [( 'Sales' , 'John Doe' ), ( 'Sales' , 'Martin Smith' ), ( 'Accounting' , 'Jane Doe' ), ( 'Marketing' , 'Elizabeth Smith' ), ( 'Marketing' , 'Adam Doe' )] from collections import defaultdict dep_dd = defaultdict ( list ) #For uniqueness instead of list use set for department , employee in dep : dep_dd [ department ] . append ( employee ) print ( dep_dd ) defaultdict(<class 'list'>, {'Sales': ['John Doe', 'Martin Smith'], 'Accounting': ['Jane Doe'], 'Marketing': ['Elizabeth Smith', 'Adam Doe']}) In this example, you group the employees by their department using a defaultdict with .default_factory set to list. To do this with a regular dictionary, you can use dict.setdefault() as follows: dep_d = dict () for department , employee in dep : dep_d . setdefault ( department , []) . append ( employee ) print ( dep_d ) {'Sales': ['John Doe', 'Martin Smith'], 'Accounting': ['Jane Doe'], 'Marketing': ['Elizabeth Smith', 'Adam Doe']} This code is straightforward, and you\u2019ll find similar code quite often in your work as a Python coder. However, the defaultdict version is arguably more readable, and for large datasets, it can also be a lot faster and more efficient. So, if speed is a concern for you, then you should consider using a defaultdict instead of a standard dict.","title":"Inner Working of defaultdict"},{"location":"DS/pyDefaultdict/#auto-vivification","text":"Defauldict are used to easily make nested dicts. It is called Auto-vivification. from collections import defaultdict import json def turtles (): return defaultdict ( turtles ) data = turtles () data [ \"Hello\" ] = \"Hey!\" data [ \"Foo\" ][ \"bar\" ][ \"baz\" ] = \"hmmm\" print ( json . dumps ( data , indent = 1 )) { \"Hello\": \"Hey!\", \"Foo\": { \"bar\": { \"baz\": \"hmmm\" } } }","title":"Auto-vivification"},{"location":"DS/pyDict/","text":"Since you've seen parenthesis (for tuples) and square brackets (for lists), you may be wondering what curly braces are used for in Python. The answer: Python dictionaries. The defining feature of a Python dictionary is that it has keys and values that are associated with each other. When defining a dictionary, this association may be accomplished using the colon (:) as is done below. Dictionaries are data structures used to map arbitrary keys to values. Lists can be thought of as dictionaries with integer keys within a certain range. Dictionaries can be indexed in the same way as lists, using square brackets containing keys. Dict Creation An empty dictionary is defined as {}. Dictionary can also be created by the built-in function dict(). # Creating an empty Dictionary Dict = {} print ( \"Empty Dictionary: \" ) print ( Dict ) # Creating a Dictionary # with dict() method Dict = dict ({ 1 : 'Trips' , 2 : 'For' , 3 : 'chips' }) print ( \" \\n Dictionary with the use of dict(): \" ) print ( Dict ) # Creating a Dictionary # with each item as a Pair Dict = dict ([( 1 , 'Trips' ), ( 2 , 'For' )]) print ( \" \\n Dictionary with each item as a pair: \" ) print ( Dict ) Empty Dictionary: {} Dictionary with the use of dict(): {1: 'Trips', 2: 'For', 3: 'chips'} Dictionary with each item as a pair: {1: 'Trips', 2: 'For'} Dict = {} #Set default value Dict . setdefault ( 1 , 'Trips' ) Dict . setdefault ( 3 , 'chips' ) print ( Dict ) {1: 'Trips', 3: 'chips'} empty_dic = {} book_dictionary = { \"Title\" : \"Frankenstein\" , \"Author\" : \"Mary Shelley\" , \"Year\" : 1818 } print ( book_dictionary [ \"Author\" ]) Mary Shelley Above, the keys of the book_dictionary are \"Title\", \"Author\", and \"Year\", and each of these keys has a corresponding value associated with it. Notice that the key-value pairs are separated by a comma. Using keys allows us to access a piece of the dictionary by its name, rather than needing to know the index of the piece that we want, as is the case with lists and tuples. For instance, above we could get the author of Frankenstein using the \"Author\" key, rather than using an index. In fact, unlike in a list or tuple, the order of elements in a dictionary doesn't matter, and dictionaries cannot be indexed using integers, which we see below when we try to access the second element of the dictionary using an integer: print ( book_dictionary [ 1 ]) --------------------------------------------------------------------------- KeyError Traceback (most recent call last) <ipython-input-11-43bbaea82a52> in <module>() ----> 1 print(book_dictionary[1]) KeyError: 1 Just like lists, dictionary keys can be assigned to different values. However, unlike lists, a new dictionary key can also be assigned a value, not just ones that already exist. squares = { 1 : 1 , 2 : 4 , 3 : \"Error\" , 4 : 16 ,} squares [ 8 ] = 64 squares [ 3 ] = 9 print ( squares ) {1: 1, 2: 4, 3: 9, 4: 16, 8: 64} in operator To determine whether a key is in a dictionary, you can use in and not in, just as you can for a list. nums = { 1 : \"one\" , 2 : \"two\" , 3 : \"three\" ,} print ( 1 in nums ) print ( \"three\" in nums ) print ( 4 not in nums ) True False True Dictionary Functions get() A useful dictionary method is get. It does the same thing as indexing, but if the key is not found in the dictionary it returns another specified value instead ('None', by default). pairs = { 1 : \"apple\" , \"orange\" :[ 2 , 3 , 4 ], True : False , None : \"True\" } print ( pairs . get ( \"orange\" )) print ( pairs . get ( 7 )) print ( pairs . get ( 12345 , \"not in dictionary\" )) ##Default message when not found fib = { 1 : 1 , 2 : 1 , 3 : 2 , 4 : 3 ,} print ( fib . get ( 4 , 0 ) + fib . get ( 7 , 5 )) [2, 3, 4] None not in dictionary 8 values() To iterate over the values of a dictionary, you can use the .values() function: for value in data . values (): pass Other funtions: copy() They copy() method returns a shallow copy of the dictionary. clear() The clear() method removes all items from the dictionary. pop() Removes and returns an element from a dictionary having the given key. popitem() Removes the arbitrary key-value pair from the dictionary and returns it as tuple. get() It is a conventional method to access a value for a key. dictionary_name.values() returns a list of all the values available in a given dictionary. str() Produces a printable string representation of a dictionary. update() Adds dictionary dict2\u2019s key-values pairs to dict setdefault() Set dict[key]=default if key is not already in dict keys() Returns list of dictionary dict\u2019s keys items() Returns a list of dict\u2019s (key, value) tuple pairs has_key() Returns true if key in dictionary dict, false otherwise fromkeys() Create a new dictionary with keys from seq and values set to value. type() Returns the type of the passed variable. cmp() Compares elements of both dict.","title":"Dictionary"},{"location":"DS/pyDict/#dict-creation","text":"An empty dictionary is defined as {}. Dictionary can also be created by the built-in function dict(). # Creating an empty Dictionary Dict = {} print ( \"Empty Dictionary: \" ) print ( Dict ) # Creating a Dictionary # with dict() method Dict = dict ({ 1 : 'Trips' , 2 : 'For' , 3 : 'chips' }) print ( \" \\n Dictionary with the use of dict(): \" ) print ( Dict ) # Creating a Dictionary # with each item as a Pair Dict = dict ([( 1 , 'Trips' ), ( 2 , 'For' )]) print ( \" \\n Dictionary with each item as a pair: \" ) print ( Dict ) Empty Dictionary: {} Dictionary with the use of dict(): {1: 'Trips', 2: 'For', 3: 'chips'} Dictionary with each item as a pair: {1: 'Trips', 2: 'For'} Dict = {} #Set default value Dict . setdefault ( 1 , 'Trips' ) Dict . setdefault ( 3 , 'chips' ) print ( Dict ) {1: 'Trips', 3: 'chips'} empty_dic = {} book_dictionary = { \"Title\" : \"Frankenstein\" , \"Author\" : \"Mary Shelley\" , \"Year\" : 1818 } print ( book_dictionary [ \"Author\" ]) Mary Shelley Above, the keys of the book_dictionary are \"Title\", \"Author\", and \"Year\", and each of these keys has a corresponding value associated with it. Notice that the key-value pairs are separated by a comma. Using keys allows us to access a piece of the dictionary by its name, rather than needing to know the index of the piece that we want, as is the case with lists and tuples. For instance, above we could get the author of Frankenstein using the \"Author\" key, rather than using an index. In fact, unlike in a list or tuple, the order of elements in a dictionary doesn't matter, and dictionaries cannot be indexed using integers, which we see below when we try to access the second element of the dictionary using an integer: print ( book_dictionary [ 1 ]) --------------------------------------------------------------------------- KeyError Traceback (most recent call last) <ipython-input-11-43bbaea82a52> in <module>() ----> 1 print(book_dictionary[1]) KeyError: 1 Just like lists, dictionary keys can be assigned to different values. However, unlike lists, a new dictionary key can also be assigned a value, not just ones that already exist. squares = { 1 : 1 , 2 : 4 , 3 : \"Error\" , 4 : 16 ,} squares [ 8 ] = 64 squares [ 3 ] = 9 print ( squares ) {1: 1, 2: 4, 3: 9, 4: 16, 8: 64}","title":"Dict Creation"},{"location":"DS/pyDict/#in-operator","text":"To determine whether a key is in a dictionary, you can use in and not in, just as you can for a list. nums = { 1 : \"one\" , 2 : \"two\" , 3 : \"three\" ,} print ( 1 in nums ) print ( \"three\" in nums ) print ( 4 not in nums ) True False True","title":"in operator"},{"location":"DS/pyDict/#dictionary-functions","text":"","title":"Dictionary Functions"},{"location":"DS/pyDict/#get","text":"A useful dictionary method is get. It does the same thing as indexing, but if the key is not found in the dictionary it returns another specified value instead ('None', by default). pairs = { 1 : \"apple\" , \"orange\" :[ 2 , 3 , 4 ], True : False , None : \"True\" } print ( pairs . get ( \"orange\" )) print ( pairs . get ( 7 )) print ( pairs . get ( 12345 , \"not in dictionary\" )) ##Default message when not found fib = { 1 : 1 , 2 : 1 , 3 : 2 , 4 : 3 ,} print ( fib . get ( 4 , 0 ) + fib . get ( 7 , 5 )) [2, 3, 4] None not in dictionary 8","title":"get()"},{"location":"DS/pyDict/#values","text":"To iterate over the values of a dictionary, you can use the .values() function: for value in data . values (): pass","title":"values()"},{"location":"DS/pyDict/#other-funtions","text":"copy() They copy() method returns a shallow copy of the dictionary. clear() The clear() method removes all items from the dictionary. pop() Removes and returns an element from a dictionary having the given key. popitem() Removes the arbitrary key-value pair from the dictionary and returns it as tuple. get() It is a conventional method to access a value for a key. dictionary_name.values() returns a list of all the values available in a given dictionary. str() Produces a printable string representation of a dictionary. update() Adds dictionary dict2\u2019s key-values pairs to dict setdefault() Set dict[key]=default if key is not already in dict keys() Returns list of dictionary dict\u2019s keys items() Returns a list of dict\u2019s (key, value) tuple pairs has_key() Returns true if key in dictionary dict, false otherwise fromkeys() Create a new dictionary with keys from seq and values set to value. type() Returns the type of the passed variable. cmp() Compares elements of both dict.","title":"Other funtions:"},{"location":"DS/pyGen/","text":"Generators are a type of iterable, like lists or tuples. Unlike lists, they don't allow indexing with arbitrary indices, but they can still be iterated through with for loops. They can be created using functions and the yield statement. The yield statement is used to define a generator, replacing the return of a function to provide a result to its caller without destroying local variables. Generators are a shortcut to write functions that implement iterators. def countdown (): i = 5 while i > 0 : yield i i -= 1 for i in countdown (): print ( i ) 5 4 3 2 1 Due to the fact that they yield one item at a time, generators don't have the memory restrictions of lists. In fact, they can be infinite! generators allow you to declare a function that behaves like an iterator, i.e. it can be used in a for loop. Finite generators can be converted into lists by passing them as arguments to the list function.Using generators results in improved performance, which is the result of the lazy (on demand) generation of values, which translates to lower memory usage. Furthermore, we do not need to wait until all the elements have been generated before we start to use them. def numbers ( x ): for i in range ( x ): if i % 2 == 0 : yield i print ( list ( numbers ( 11 ))) [0, 2, 4, 6, 8, 10]","title":"Generators"},{"location":"DS/pyGenX/","text":"These are almost comprehension, but we don\u00b4t want to collect the results in a list, dict or set. Rather, we want to consume them inmediately, one by one. No data structure is created so we save memory and time. Sum the squares of the first 10 even numbers sum ( i ** 2 for i in range ( 20 ) if i % 2 == 0 ) 1140 even = i ** 2 for i in range ( 20 ) if i % 2 == 0 even = i**2 for i in range(20) if i%2 == 0 ^ SyntaxError: invalid syntax It needs parentheses!! even = ( i ** 2 for i in range ( 20 ) if i % 2 == 0 ) What is even? It is a generator object. So it implements the iterator protocol. Therefore, we can used it in loops or feed it to functions like sum that accept iterators. even <generator object <genexpr> at 0x7f8ff8005cd0> even . __next__ () 0 even . __next__ () 4 even . __next__ () 16 When one line is not sufficient but you still want the convinience of iterators. You can write a function called generator which has the special keyword yield def fibonacci () : print ( \"Let's get set!\" ) f1 , f2 = 0 , 1 while True : yield f2 f1 , f2 = f2 , f1 + f2 f = fibonacci () f <generator object fibonacci at 0x7f2ec8ba3550> f . __next__ () f . __next__ () f . __next__ () #the same as next ( f ) next ( f ) for x in fibonacci (): if x > 1000 : break print ( x ) Let's get set! 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 def fibonacci ( fmax ) : print ( \"Let's get set!\" ) f1 , f2 = 0 , 1 while True : yield f2 f1 , f2 = f2 , f1 + f2 if f2 > fmax : return [ x for x in fibonacci ( 1000 )] Let's get set! [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987] Advance concepts for generators Context Managers Coroutines","title":"Generator Expressions"},{"location":"DS/pyGenX/#advance-concepts-for-generators","text":"Context Managers Coroutines","title":"Advance concepts for generators"},{"location":"DS/pyGraph/","text":"Graphs are used to represent many real-life applications like networks, transportation paths of a city, and social network connections. A graph is a set of connected nodes where each node is called a Vertex and the connection between two of them is called an Edge. A graph can be represented using a square matrix, where each element represents the edges: 0 indicates no edge, while 1 indicates an edge. The rows and columns represent the vertices. This type of matrix is called an adjacency matrix, because it shows if the corresponding vertices are adjacent or not. class Graph (): def __init__ ( self , size ): self . adj = [ [ 0 ] * size for i in range ( size )] self . size = size def add_edge ( self , orig , dest ): if orig > self . size or dest > self . size or orig < 0 or dest < 0 : print ( \"Invalid Edge\" ) else : self . adj [ orig - 1 ][ dest - 1 ] = 1 self . adj [ dest - 1 ][ orig - 1 ] = 1 def remove_edge ( self , orig , dest ): if orig > self . size or dest > self . size or orig < 0 or dest < 0 : print ( \"Invalid Edge\" ) else : self . adj [ orig - 1 ][ dest - 1 ] = 0 self . adj [ dest - 1 ][ orig - 1 ] = 0 def display ( self ): for row in self . adj : print () for val in row : print ( ' {:4} ' . format ( val ), end = \"\" ) A graph is a collection of nodes and edges, where nodes often represent objects or ideas, and edges represent relationships among them. For example, in a graph that represents a social network, nodes might represent people and edges might represent friendships between them. NetworkX provides data structures to represent graphs and function that implement graph algorithms. To show how it works, we\u2019ll make a small graph that represents a social network. Here\u2019s how we make a graph and add nodes. import networkx as nx G = nx . Graph () G . add_node ( 'Alice' ) G . add_node ( 'Bob' , age = 23 ) G . add_node ( 'Carol' , cat = 'mittens' ) list ( G . nodes ()) ['Alice', 'Bob', 'Carol'] Optionally, you can provide attributes that are associated with the node. In this example, Bob has an age attribute and Carol has a cat. Here\u2019s how we add edges between nodes. G . add_edge ( 'Alice' , 'Bob' ) G . add_edge ( 'Alice' , 'Carol' , type = 'enemy' ) list ( G . edges ()) [('Alice', 'Bob'), ('Alice', 'Carol')] Optionally, you can provide attributes that are associated with the edge. In this example, the second edge has an attribute called type that indicates the nature of the relationship. Here\u2019s how to draw the graph. def draw_graph ( G ): nx . draw_circular ( G , node_size = 1500 , with_labels = True ) draw_graph ( G ) Graph Representation NetworkX represents graphs using a dictionary that maps from each node to a dictionary that maps from nodes to edges. If we select an element from the top-level dictionary, the result is a dictionary-like object. G [ 'Alice' ] AtlasView({'Bob': {}, 'Carol': {'type': 'enemy'}}) So we can iterate through the neighbors of a node like this: for neighbor in G [ 'Alice' ]: print ( neighbor ) Bob Carol Or enumerate the neighbors and edges like this: for key , value in G [ 'Alice' ] . items (): print ( key , value ) Bob {} Carol {'type': 'enemy'} Edges are represented by dictionaries of attributes. In this example, the first edge has no attributes and the second has an attribute named type. We can select an edge like this: G [ 'Alice' ][ 'Carol' ] {'type': 'enemy'} To check whether there is an edge from one node to another, we can use the in operator: def has_edge ( G , u , v ): return v in G [ u ] has_edge ( G , 'Alice' , 'Bob' ) True But there\u2019s a method that does the same thing. G . has_edge ( 'Alice' , 'Bob' ) True Complete Graphs In a complete graph, all nodes are connected to each other. To make a complete graph, we\u2019ll use the following generator function, iterates through all pairs of nodes. def all_pairs ( nodes ): for i , u in enumerate ( nodes ): for j , v in enumerate ( nodes ): if i < j : yield u , v Here\u2019s a complete graph with 10 nodes: def make_complete_graph ( n ): nodes = range ( n ) G = nx . Graph () G . add_nodes_from ( nodes ) G . add_edges_from ( all_pairs ( nodes )) return G complete = make_complete_graph ( 10 ) And here\u2019s what it looks like. draw_graph ( complete ) Random Graphs Next we\u2019ll make an Erdos-Renyi graph, which is a random graph where the probability of an edge between each pair of nodes is . The helper function flip returns True with probability p and False with probability 1-p import random def flip ( p ): return random . random () < p random_pairs is a generator function that enumerates all possible pairs of nodes and yields each one with probability p def random_pairs ( nodes , p ): for edge in all_pairs ( nodes ): if flip ( p ): yield edge make_random_graph makes an ER graph where the probability of an edge between each pair of nodes is p. def make_random_graph ( n , p ): nodes = range ( n ) G = nx . Graph () G . add_nodes_from ( nodes ) G . add_edges_from ( random_pairs ( nodes , p )) return G Here\u2019s an example with n=10 and p=0.3 random_graph = make_random_graph ( 10 , 0.3 ) len ( random_graph . edges ()) 10 And here\u2019s what it looks like: draw_graph ( random_graph ) Connectivity A graph is connected if you can start from any node and follow a sequence of edges to reach any other node. To check whether a graph is connected, we\u2019ll use a version of a depth-first search. For most graphs, the basic version of DFS runs forever, because it visits the same nodes over and over. The solution is to keep track of the nodes we\u2019ve seen and avoid visiting them more than once. In the complete graph, starting from node 0, we can reach all nodes. In a random graph, it may or may not be possible to reach all nodes. Watts-Strogatz Graphs A Watts-Strogatz (WS) graph is a random graph, like an Erdos-Renyi graph, but the construction process is different. A WS graph starts with a ring lattice and randomly \u201crewires\u201d some of the edges. NetworkX provides a function that makes a WS graph, so we can see what it looks like. Here\u2019s an example with n=10 nodes, each connected to k=2 neighbors, with probability p=0 of rewiring each edge. import networkx as nx G = nx . watts_strogatz_graph ( n = 10 , k = 3 , p = 0 ) G . nodes () NodeView((0, 1, 2, 3, 4, 5, 6, 7, 8, 9)) The result is a ring where each node holds hands with its immediate neighbors. def draw_graph ( G ): nx . draw_circular ( G , node_size = 1000 , with_labels = True ) draw_graph ( G ) Note: If k is odd, it gets \u201crounded down\u201d to an even number. Depth-First Search def reachable_nodes ( G , start ): seen = set () stack = [ start ] while stack : node = stack . pop () if node not in seen : seen . add ( node ) stack . extend ( G [ node ]) return seen reachable_nodes ( G , 0 ) {0, 1, 2, 3, 4, 5, 6, 7, 8, 9} Fast Breadth-First Search NetworkX provides a simple, fast implementation of BFS, available from the NetworkX repository on GitHub. Here is a version I modified to return a set of nodes: def plain_bfs ( G , start ): seen = set () nextlevel = { start } while nextlevel : thislevel = nextlevel nextlevel = set () for v in thislevel : if v not in seen : seen . add ( v ) nextlevel . update ( G [ v ]) return seen Let\u2019s compare this function to reachable_nodes_bfs and see which is faster. G = nx . watts_strogatz_graph ( 1000 , 10 , 0.01 ) % timeit plain_bfs ( G , 0 ) 100 loops, best of 5: 1.98 ms per loop","title":"Graphs"},{"location":"DS/pyGraph/#graph-representation","text":"NetworkX represents graphs using a dictionary that maps from each node to a dictionary that maps from nodes to edges. If we select an element from the top-level dictionary, the result is a dictionary-like object. G [ 'Alice' ] AtlasView({'Bob': {}, 'Carol': {'type': 'enemy'}}) So we can iterate through the neighbors of a node like this: for neighbor in G [ 'Alice' ]: print ( neighbor ) Bob Carol Or enumerate the neighbors and edges like this: for key , value in G [ 'Alice' ] . items (): print ( key , value ) Bob {} Carol {'type': 'enemy'} Edges are represented by dictionaries of attributes. In this example, the first edge has no attributes and the second has an attribute named type. We can select an edge like this: G [ 'Alice' ][ 'Carol' ] {'type': 'enemy'} To check whether there is an edge from one node to another, we can use the in operator: def has_edge ( G , u , v ): return v in G [ u ] has_edge ( G , 'Alice' , 'Bob' ) True But there\u2019s a method that does the same thing. G . has_edge ( 'Alice' , 'Bob' ) True","title":"Graph Representation"},{"location":"DS/pyGraph/#complete-graphs","text":"In a complete graph, all nodes are connected to each other. To make a complete graph, we\u2019ll use the following generator function, iterates through all pairs of nodes. def all_pairs ( nodes ): for i , u in enumerate ( nodes ): for j , v in enumerate ( nodes ): if i < j : yield u , v Here\u2019s a complete graph with 10 nodes: def make_complete_graph ( n ): nodes = range ( n ) G = nx . Graph () G . add_nodes_from ( nodes ) G . add_edges_from ( all_pairs ( nodes )) return G complete = make_complete_graph ( 10 ) And here\u2019s what it looks like. draw_graph ( complete )","title":"Complete Graphs"},{"location":"DS/pyGraph/#random-graphs","text":"Next we\u2019ll make an Erdos-Renyi graph, which is a random graph where the probability of an edge between each pair of nodes is . The helper function flip returns True with probability p and False with probability 1-p import random def flip ( p ): return random . random () < p random_pairs is a generator function that enumerates all possible pairs of nodes and yields each one with probability p def random_pairs ( nodes , p ): for edge in all_pairs ( nodes ): if flip ( p ): yield edge make_random_graph makes an ER graph where the probability of an edge between each pair of nodes is p. def make_random_graph ( n , p ): nodes = range ( n ) G = nx . Graph () G . add_nodes_from ( nodes ) G . add_edges_from ( random_pairs ( nodes , p )) return G Here\u2019s an example with n=10 and p=0.3 random_graph = make_random_graph ( 10 , 0.3 ) len ( random_graph . edges ()) 10 And here\u2019s what it looks like: draw_graph ( random_graph )","title":"Random Graphs"},{"location":"DS/pyGraph/#connectivity","text":"A graph is connected if you can start from any node and follow a sequence of edges to reach any other node. To check whether a graph is connected, we\u2019ll use a version of a depth-first search. For most graphs, the basic version of DFS runs forever, because it visits the same nodes over and over. The solution is to keep track of the nodes we\u2019ve seen and avoid visiting them more than once. In the complete graph, starting from node 0, we can reach all nodes. In a random graph, it may or may not be possible to reach all nodes.","title":"Connectivity"},{"location":"DS/pyGraph/#watts-strogatz-graphs","text":"A Watts-Strogatz (WS) graph is a random graph, like an Erdos-Renyi graph, but the construction process is different. A WS graph starts with a ring lattice and randomly \u201crewires\u201d some of the edges. NetworkX provides a function that makes a WS graph, so we can see what it looks like. Here\u2019s an example with n=10 nodes, each connected to k=2 neighbors, with probability p=0 of rewiring each edge. import networkx as nx G = nx . watts_strogatz_graph ( n = 10 , k = 3 , p = 0 ) G . nodes () NodeView((0, 1, 2, 3, 4, 5, 6, 7, 8, 9)) The result is a ring where each node holds hands with its immediate neighbors. def draw_graph ( G ): nx . draw_circular ( G , node_size = 1000 , with_labels = True ) draw_graph ( G ) Note: If k is odd, it gets \u201crounded down\u201d to an even number.","title":"Watts-Strogatz Graphs"},{"location":"DS/pyGraph/#depth-first-search","text":"def reachable_nodes ( G , start ): seen = set () stack = [ start ] while stack : node = stack . pop () if node not in seen : seen . add ( node ) stack . extend ( G [ node ]) return seen reachable_nodes ( G , 0 ) {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}","title":"Depth-First Search"},{"location":"DS/pyGraph/#fast-breadth-first-search","text":"NetworkX provides a simple, fast implementation of BFS, available from the NetworkX repository on GitHub. Here is a version I modified to return a set of nodes: def plain_bfs ( G , start ): seen = set () nextlevel = { start } while nextlevel : thislevel = nextlevel nextlevel = set () for v in thislevel : if v not in seen : seen . add ( v ) nextlevel . update ( G [ v ]) return seen Let\u2019s compare this function to reachable_nodes_bfs and see which is faster. G = nx . watts_strogatz_graph ( 1000 , 10 , 0.01 ) % timeit plain_bfs ( G , 0 ) 100 loops, best of 5: 1.98 ms per loop","title":"Fast Breadth-First Search"},{"location":"DS/pyHeapQueue/","text":"Heap data structure is mainly used to represent a priority queue. In Python, it is available using \u201cheapq\u201d module. The property of this data structure in Python is that each time the smallest of heap element is popped(min heap). Whenever elements are pushed or popped, heap structure is maintained. The heap[0] element also returns the smallest element each time. If the list is a heap, the tree should have the heap property: Every parent is less than or equal to its children. heapify(iterable) This function is used to convert the iterable into a heap data structure. i.e. in heap order. heappush(heap, ele) This function is used to insert the element mentioned in its arguments into heap. The order is adjusted, so as heap structure is maintained. heappop(heap) This function is used to remove and return the smallest element from heap. The order is adjusted, so as heap structure is maintained. # Python code to demonstrate working of # heapify(), heappush() and heappop() # importing \"heapq\" to implement heap queue import heapq # initializing list li = [ 5 , 7 , 9 , 1 , 3 ] # using heapify to convert list into heap heapq . heapify ( li ) # printing created heap print ( \"The created heap is : \" , end = \"\" ) print ( list ( li )) # using heappush() to push elements into heap # pushes 4 heapq . heappush ( li , 4 ) # printing modified heap print ( \"The modified heap after push is : \" , end = \"\" ) print ( list ( li )) # using heappop() to pop smallest element print ( \"The popped and smallest element is : \" , end = \"\" ) print ( heapq . heappop ( li )) The created heap is : [1, 3, 9, 7, 5] The modified heap after push is : [1, 3, 4, 7, 5, 9] The popped and smallest element is : 1 heappushpop(heap, ele) This function combines the functioning of both push and pop operations in one statement, increasing efficiency. Heap order is maintained after this operation. heapreplace(heap, ele) This function also inserts and pops element in one statement, but it is different from above function. In this, element is first popped, then the element is pushed.i.e, the value larger than the pushed value can be returned. heapreplace() returns the smallest value originally in heap regardless of the pushed element as opposed to heappushpop(). # Python code to demonstrate working of # heappushpop() and heapreplce() # importing \"heapq\" to implement heap queue import heapq # initializing list 1 li1 = [ 5 , 7 , 9 , 4 , 3 ] # initializing list 2 li2 = [ 5 , 7 , 9 , 4 , 3 ] # using heapify() to convert list into heap heapq . heapify ( li1 ) heapq . heapify ( li2 ) # using heappushpop() to push and pop items simultaneously # pops 2 print ( \"The popped item using heappushpop() is : \" , end = \"\" ) print ( heapq . heappushpop ( li1 , 2 )) # using heapreplace() to push and pop items simultaneously # pops 3 print ( \"The popped item using heapreplace() is : \" , end = \"\" ) print ( heapq . heapreplace ( li2 , 2 )) The popped item using heappushpop() is : 2 The popped item using heapreplace() is : 3 nlargest(k, iterable, key = fun) This function is used to return the k largest elements from the iterable specified and satisfying the key if mentioned. nsmallest(k, iterable, key = fun) This function is used to return the k smallest elements from the iterable specified and satisfying the key if mentioned. # Python code to demonstrate working of # nlargest() and nsmallest() # importing \"heapq\" to implement heap queue import heapq # initializing list li1 = [ 6 , 7 , 9 , 4 , 3 , 5 , 8 , 10 , 1 ] # using heapify() to convert list into heap heapq . heapify ( li1 ) # using nlargest to print 3 largest numbers # prints 10, 9 and 8 print ( \"The 3 largest numbers in list are : \" , end = \"\" ) print ( heapq . nlargest ( 3 , li1 )) # using nsmallest to print 3 smallest numbers # prints 1, 3 and 4 print ( \"The 3 smallest numbers in list are : \" , end = \"\" ) print ( heapq . nsmallest ( 3 , li1 )) The 3 largest numbers in list are : [10, 9, 8] The 3 smallest numbers in list are : [1, 3, 4]","title":"HeapQueue"},{"location":"DS/pyHeapQueue/#heapifyiterable","text":"This function is used to convert the iterable into a heap data structure. i.e. in heap order.","title":"heapify(iterable)"},{"location":"DS/pyHeapQueue/#heappushheap-ele","text":"This function is used to insert the element mentioned in its arguments into heap. The order is adjusted, so as heap structure is maintained.","title":"heappush(heap, ele)"},{"location":"DS/pyHeapQueue/#heappopheap","text":"This function is used to remove and return the smallest element from heap. The order is adjusted, so as heap structure is maintained. # Python code to demonstrate working of # heapify(), heappush() and heappop() # importing \"heapq\" to implement heap queue import heapq # initializing list li = [ 5 , 7 , 9 , 1 , 3 ] # using heapify to convert list into heap heapq . heapify ( li ) # printing created heap print ( \"The created heap is : \" , end = \"\" ) print ( list ( li )) # using heappush() to push elements into heap # pushes 4 heapq . heappush ( li , 4 ) # printing modified heap print ( \"The modified heap after push is : \" , end = \"\" ) print ( list ( li )) # using heappop() to pop smallest element print ( \"The popped and smallest element is : \" , end = \"\" ) print ( heapq . heappop ( li )) The created heap is : [1, 3, 9, 7, 5] The modified heap after push is : [1, 3, 4, 7, 5, 9] The popped and smallest element is : 1","title":"heappop(heap)"},{"location":"DS/pyHeapQueue/#heappushpopheap-ele","text":"This function combines the functioning of both push and pop operations in one statement, increasing efficiency. Heap order is maintained after this operation.","title":"heappushpop(heap, ele)"},{"location":"DS/pyHeapQueue/#heapreplaceheap-ele","text":"This function also inserts and pops element in one statement, but it is different from above function. In this, element is first popped, then the element is pushed.i.e, the value larger than the pushed value can be returned. heapreplace() returns the smallest value originally in heap regardless of the pushed element as opposed to heappushpop(). # Python code to demonstrate working of # heappushpop() and heapreplce() # importing \"heapq\" to implement heap queue import heapq # initializing list 1 li1 = [ 5 , 7 , 9 , 4 , 3 ] # initializing list 2 li2 = [ 5 , 7 , 9 , 4 , 3 ] # using heapify() to convert list into heap heapq . heapify ( li1 ) heapq . heapify ( li2 ) # using heappushpop() to push and pop items simultaneously # pops 2 print ( \"The popped item using heappushpop() is : \" , end = \"\" ) print ( heapq . heappushpop ( li1 , 2 )) # using heapreplace() to push and pop items simultaneously # pops 3 print ( \"The popped item using heapreplace() is : \" , end = \"\" ) print ( heapq . heapreplace ( li2 , 2 )) The popped item using heappushpop() is : 2 The popped item using heapreplace() is : 3","title":"heapreplace(heap, ele)"},{"location":"DS/pyHeapQueue/#nlargestk-iterable-key-fun","text":"This function is used to return the k largest elements from the iterable specified and satisfying the key if mentioned.","title":"nlargest(k, iterable, key = fun)"},{"location":"DS/pyHeapQueue/#nsmallestk-iterable-key-fun","text":"This function is used to return the k smallest elements from the iterable specified and satisfying the key if mentioned. # Python code to demonstrate working of # nlargest() and nsmallest() # importing \"heapq\" to implement heap queue import heapq # initializing list li1 = [ 6 , 7 , 9 , 4 , 3 , 5 , 8 , 10 , 1 ] # using heapify() to convert list into heap heapq . heapify ( li1 ) # using nlargest to print 3 largest numbers # prints 10, 9 and 8 print ( \"The 3 largest numbers in list are : \" , end = \"\" ) print ( heapq . nlargest ( 3 , li1 )) # using nsmallest to print 3 smallest numbers # prints 1, 3 and 4 print ( \"The 3 smallest numbers in list are : \" , end = \"\" ) print ( heapq . nsmallest ( 3 , li1 )) The 3 largest numbers in list are : [10, 9, 8] The 3 smallest numbers in list are : [1, 3, 4]","title":"nsmallest(k, iterable, key = fun)"},{"location":"DS/pyIterAllAny/","text":"Often used in conditional statements, all and any take a list as an argument, and return True if all or any (respectively) of their arguments evaluate to True (and False otherwise). nums = [ 55 , 44 , 33 , 22 , 11 ,] if all ([ i > 5 for i in nums ]): print ( \"All larger than 5\" ) if any ([ i % 2 == 0 for i in nums ]): print ( \"At least one is even\" ) All larger than 5 At least one is even","title":"All & Any"},{"location":"DS/pyIterEnumerate/","text":"The function enumerate can be used to iterate through the values and indices of a list simultaneously. Enumerate() method adds a counter to an iterable and returns it in a form of enumerating object. This enumerated object can then be used directly for loops or converted into a list of tuples using the list() method. nums = [ 55 , 44 , 33 , 22 , 11 ,] #Without enumerate use index variable index = 0 for value in nums : print ( index , value ) index += 1 0 55 1 44 2 33 3 22 4 11 nums = [ 55 , 44 , 33 , 22 , 11 ,] #Using range and len for index in range ( len ( nums )): value = nums [ index ] print ( index , value ) 0 55 1 44 2 33 3 22 4 11 #using enumarate nums = [ 55 , 44 , 33 , 22 , 11 ,] for v in enumerate ( nums ): print ( v ) (0, 55) (1, 44) (2, 33) (3, 22) (4, 11) nums = [ 55 , 44 , 33 , 22 , 11 ,] for i , v in enumerate ( nums ): print ( f \"value { v } is at { i } position\" ) value 55 is at 0 position value 44 is at 1 position value 33 is at 2 position value 22 is at 3 position value 11 is at 4 position nums = [ 55 , 44 , 33 , 22 , 11 ,] for i , v in enumerate ( nums , start = 10 ): print ( f \"value { v } is at { i } position\" ) value 55 is at 10 position value 44 is at 11 position value 33 is at 12 position value 22 is at 13 position value 11 is at 14 position","title":"Enumerate"},{"location":"DS/pyIterMapFilter/","text":"The built-in functions map and filter are very useful higher-order functions that operate on lists (or similar objects called iterables). Map The function map takes a function and an iterable as arguments, and returns a new iterable with the function applied to each argument. def add_five ( x ): return x + 5 nums = [ 11 , 22 , 33 , 44 , 55 ] result = list ( map ( add_five , nums )) print ( result ) <class 'list'> [16, 27, 38, 49, 60] #the same using lambda syntax result = list ( map ( lambda x : x + 5 , nums )) print ( result ) [16, 27, 38, 49, 60] Filter The function filter filters an iterable by removing items that don't match a predicate (a function that returns a Boolean). Like map, the result has to be explicitly converted to a list if you want to print it. nums = [ 11 , 22 , 33 , 44 , 55 ] res = list ( filter ( lambda x : x % 2 == 0 , nums )) print ( res ) [22, 44] # use transform functions like sorted, filter, map def filterFunc ( x ): if x % 2 == 0 : return False return True def filterFunc2 ( x ): if x . isupper (): return False return True def squareFunc ( x ): return x ** 2 def toGrade ( x ): if ( x >= 90 ): return \"A\" elif ( x >= 80 and x < 90 ): return \"B\" elif ( x >= 70 and x < 80 ): return \"C\" elif ( x >= 65 and x < 70 ): return \"D\" return \"F\" def main (): # define some sample sequences to operate on nums = ( 1 , 8 , 4 , 5 , 13 , 26 , 381 , 410 , 58 , 47 ) chars = \"abcDeFGHiJklmnoP\" grades = ( 81 , 89 , 94 , 78 , 61 , 66 , 99 , 74 ) # use filter to remove items from a list odds = list ( filter ( filterFunc , nums )) print ( odds ) # use filter on non-numeric sequence lowers = list ( filter ( filterFunc2 , chars )) print ( lowers ) # use map to create a new sequence of values squares = list ( map ( squareFunc , nums )) print ( squares ) # use sorted and map to change numbers to grades grades = sorted ( grades ) letters = list ( map ( toGrade , grades )) print ( letters ) if __name__ == \"__main__\" : main () [1, 5, 13, 381, 47] ['a', 'b', 'c', 'e', 'i', 'k', 'l', 'm', 'n', 'o'] [1, 64, 16, 25, 169, 676, 145161, 168100, 3364, 2209] ['F', 'D', 'C', 'C', 'B', 'B', 'A', 'A']","title":"Map & Filter"},{"location":"DS/pyIterMapFilter/#map","text":"The function map takes a function and an iterable as arguments, and returns a new iterable with the function applied to each argument. def add_five ( x ): return x + 5 nums = [ 11 , 22 , 33 , 44 , 55 ] result = list ( map ( add_five , nums )) print ( result ) <class 'list'> [16, 27, 38, 49, 60] #the same using lambda syntax result = list ( map ( lambda x : x + 5 , nums )) print ( result ) [16, 27, 38, 49, 60]","title":"Map"},{"location":"DS/pyIterMapFilter/#filter","text":"The function filter filters an iterable by removing items that don't match a predicate (a function that returns a Boolean). Like map, the result has to be explicitly converted to a list if you want to print it. nums = [ 11 , 22 , 33 , 44 , 55 ] res = list ( filter ( lambda x : x % 2 == 0 , nums )) print ( res ) [22, 44] # use transform functions like sorted, filter, map def filterFunc ( x ): if x % 2 == 0 : return False return True def filterFunc2 ( x ): if x . isupper (): return False return True def squareFunc ( x ): return x ** 2 def toGrade ( x ): if ( x >= 90 ): return \"A\" elif ( x >= 80 and x < 90 ): return \"B\" elif ( x >= 70 and x < 80 ): return \"C\" elif ( x >= 65 and x < 70 ): return \"D\" return \"F\" def main (): # define some sample sequences to operate on nums = ( 1 , 8 , 4 , 5 , 13 , 26 , 381 , 410 , 58 , 47 ) chars = \"abcDeFGHiJklmnoP\" grades = ( 81 , 89 , 94 , 78 , 61 , 66 , 99 , 74 ) # use filter to remove items from a list odds = list ( filter ( filterFunc , nums )) print ( odds ) # use filter on non-numeric sequence lowers = list ( filter ( filterFunc2 , chars )) print ( lowers ) # use map to create a new sequence of values squares = list ( map ( squareFunc , nums )) print ( squares ) # use sorted and map to change numbers to grades grades = sorted ( grades ) letters = list ( map ( toGrade , grades )) print ( letters ) if __name__ == \"__main__\" : main () [1, 5, 13, 381, 47] ['a', 'b', 'c', 'e', 'i', 'k', 'l', 'm', 'n', 'o'] [1, 64, 16, 25, 169, 676, 145161, 168100, 3364, 2209] ['F', 'D', 'C', 'C', 'B', 'B', 'A', 'A']","title":"Filter"},{"location":"DS/pyIterReversed/","text":"Returns an iterator Python reversed() method returns an iterator that accesses the given sequence in the reverse order. 3 ways to reverse a sequence: iter.reverse() reverses a mutable sequence in place and is not available for inmutable sequences Slicing [::-1] creates a reversed copy of a sequence, it is the fastest but creates a copy of the sequence. Memory considerations to reverse millions of items. Used for both mutable and inmutable sequences. reversed() returns a reversed iterator, scales well to millions of items. Used for both mutable and inmutable sequences. # Python code to demonstrate working of # reversed() # For tuple seqTuple = ( 'm' , 'o' , 'r' , 'p' , 's' ) print ( list ( reversed ( seqTuple ))) # For range seqRange = range ( 1 , 5 ) print ( list ( reversed ( seqRange ))) ['s', 'p', 'r', 'o', 'm'] [4, 3, 2, 1] class pyp : vowels = [ 'a' , 'e' , 'i' , 'o' , 'u' ] # Function to reverse the list def __reversed__ ( self ): return reversed ( self . vowels ) ['u', 'o', 'i', 'e', 'a']","title":"Reversed"},{"location":"DS/pyIterSorted/","text":"Python sorted() function returns a sorted list from the iterable object. Sorted() sorts any sequence (list, tuple) and always returns a list with the elements in a sorted manner, without modifying the original sequence. x = [ 2 , 8 , 1 , 4 , 6 , 3 , 7 ] print ( \"Sorted List returned :\" ), print ( sorted ( x )) print ( \" \\n Reverse sort :\" ), print ( sorted ( x , reverse = True )) print ( \" \\n Original list not modified :\" ), print ( x ) Sorted List returned : [1, 2, 3, 4, 6, 7, 8] Reverse sort : [8, 7, 6, 4, 3, 2, 1] Original list not modified : [2, 8, 1, 4, 6, 3, 7] # List x = [ 'q' , 'w' , 'r' , 'e' , 't' , 'y' ] print ( f 'List : { sorted ( x ) } ' ) # Tuple x = ( 'q' , 'w' , 'e' , 'r' , 't' , 'y' ) print ( f 'Tuple : { sorted ( x ) } ' ) # String-sorted based on ASCII translations x = \"python\" print ( f 'String : { sorted ( x ) } ' ) # Dictionary x = { 'q' : 1 , 'w' : 2 , 'e' : 3 , 'r' : 4 , 't' : 5 , 'y' : 6 } print ( f 'Dict : { sorted ( x ) } ' ) # Set x = { 'q' , 'w' , 'e' , 'r' , 't' , 'y' } print ( f 'Set : { sorted ( x ) } ' ) # Frozen Set x = frozenset (( 'q' , 'w' , 'e' , 'r' , 't' , 'y' )) print ( f 'Frozen Set : { sorted ( x ) } ' ) List : ['e', 'q', 'r', 't', 'w', 'y'] Tuple : ['e', 'q', 'r', 't', 'w', 'y'] String : ['h', 'n', 'o', 'p', 't', 'y'] Dict : ['e', 'q', 'r', 't', 'w', 'y'] Set : ['e', 'q', 'r', 't', 'w', 'y'] Frozen Set : ['e', 'q', 'r', 't', 'w', 'y'] L = [ \"cccc\" , \"b\" , \"dd\" , \"aaa\" ] print ( \"Normal sort :\" , sorted ( L )) print ( \"Sort with len :\" , sorted ( L , key = len )) Normal sort : ['aaa', 'b', 'cccc', 'dd'] Sort with len : ['b', 'dd', 'aaa', 'cccc'] # Sort a list of integers based on # their remainder on dividing from 7 def func ( x ): return x % 7 L = [ 15 , 3 , 11 , 7 ] print ( \"Normal sort :\" , sorted ( L )) print ( \"Sorted with key:\" , sorted ( L , key = func )) Normal sort : [3, 7, 11, 15] Sorted with key: [7, 15, 3, 11]","title":"Sorted"},{"location":"DS/pyIterZip/","text":"Zip Python zip() method takes iterable or containers and returns a single iterator object, having mapped values from all the containers. It is used to map the similar index of multiple containers so that they can be used just using a single entity. name = [ \"Manjeet\" , \"Nikhil\" , \"Shambhavi\" , \"Astha\" ] roll_no = [ 4 , 1 , 3 , 2 ] # using zip() to map values mapped = zip ( name , roll_no ) print ( set ( mapped )) {('Shambhavi', 3), ('Nikhil', 1), ('Astha', 2), ('Manjeet', 4)} names = [ 'Mukesh' , 'Roni' , 'Chari' ] ages = [ 24 , 50 , 18 ] for i , ( name , age ) in enumerate ( zip ( names , ages )): print ( i , name , age ) 0 Mukesh 24 1 Roni 50 2 Chari 18 stocks = [ 'reliance' , 'infosys' , 'tcs' ] prices = [ 2175 , 1127 , 2750 ] new_dict = { stocks : prices for stocks , prices in zip ( stocks , prices )} print ( new_dict ) {'reliance': 2175, 'infosys': 1127, 'tcs': 2750} Unzip How to unzip? Unzipping means converting the zipped values back to the individual self as they were. This is done with the help of \u201c*\u201d operator. # Python code to demonstrate the working of # unzip # initializing lists name = [ \"Manjeet\" , \"Nikhil\" , \"Shambhavi\" , \"Astha\" ] roll_no = [ 4 , 1 , 3 , 2 ] marks = [ 40 , 50 , 60 , 70 ] # using zip() to map values mapped = zip ( name , roll_no , marks ) # converting values to print as list mapped = list ( mapped ) # printing resultant values print ( \"The zipped result is : \" , end = \"\" ) print ( mapped ) print ( \" \\n \" ) # unzipping values namz , roll_noz , marksz = zip ( * mapped ) print ( \"The unzipped result: \\n \" , end = \"\" ) # printing initial lists print ( \"The name list is : \" , end = \"\" ) print ( namz ) print ( \"The roll_no list is : \" , end = \"\" ) print ( roll_noz ) print ( \"The marks list is : \" , end = \"\" ) print ( marksz ) The zipped result is : [('Manjeet', 4, 40), ('Nikhil', 1, 50), ('Shambhavi', 3, 60), ('Astha', 2, 70)] The unzipped result: The name list is : ('Manjeet', 'Nikhil', 'Shambhavi', 'Astha') The roll_no list is : (4, 1, 3, 2) The marks list is : (40, 50, 60, 70)","title":"Zip"},{"location":"DS/pyIterZip/#zip","text":"Python zip() method takes iterable or containers and returns a single iterator object, having mapped values from all the containers. It is used to map the similar index of multiple containers so that they can be used just using a single entity. name = [ \"Manjeet\" , \"Nikhil\" , \"Shambhavi\" , \"Astha\" ] roll_no = [ 4 , 1 , 3 , 2 ] # using zip() to map values mapped = zip ( name , roll_no ) print ( set ( mapped )) {('Shambhavi', 3), ('Nikhil', 1), ('Astha', 2), ('Manjeet', 4)} names = [ 'Mukesh' , 'Roni' , 'Chari' ] ages = [ 24 , 50 , 18 ] for i , ( name , age ) in enumerate ( zip ( names , ages )): print ( i , name , age ) 0 Mukesh 24 1 Roni 50 2 Chari 18 stocks = [ 'reliance' , 'infosys' , 'tcs' ] prices = [ 2175 , 1127 , 2750 ] new_dict = { stocks : prices for stocks , prices in zip ( stocks , prices )} print ( new_dict ) {'reliance': 2175, 'infosys': 1127, 'tcs': 2750}","title":"Zip"},{"location":"DS/pyIterZip/#unzip","text":"How to unzip? Unzipping means converting the zipped values back to the individual self as they were. This is done with the help of \u201c*\u201d operator. # Python code to demonstrate the working of # unzip # initializing lists name = [ \"Manjeet\" , \"Nikhil\" , \"Shambhavi\" , \"Astha\" ] roll_no = [ 4 , 1 , 3 , 2 ] marks = [ 40 , 50 , 60 , 70 ] # using zip() to map values mapped = zip ( name , roll_no , marks ) # converting values to print as list mapped = list ( mapped ) # printing resultant values print ( \"The zipped result is : \" , end = \"\" ) print ( mapped ) print ( \" \\n \" ) # unzipping values namz , roll_noz , marksz = zip ( * mapped ) print ( \"The unzipped result: \\n \" , end = \"\" ) # printing initial lists print ( \"The name list is : \" , end = \"\" ) print ( namz ) print ( \"The roll_no list is : \" , end = \"\" ) print ( roll_noz ) print ( \"The marks list is : \" , end = \"\" ) print ( marksz ) The zipped result is : [('Manjeet', 4, 40), ('Nikhil', 1, 50), ('Shambhavi', 3, 60), ('Astha', 2, 70)] The unzipped result: The name list is : ('Manjeet', 'Nikhil', 'Shambhavi', 'Astha') The roll_no list is : (4, 1, 3, 2) The marks list is : (40, 50, 60, 70)","title":"Unzip"},{"location":"DS/pyLinkedList/","text":"A linked list is a sequence of nodes where each node stores its own data and a link to the next node. One node links to another forming what can be thought of as a linked chain. The first node is called the head, and it's used as the starting point for any iteration through the list. The last node must have its link pointing to None to determine the end of the list. Unlike stacks and queues, you can insert and remove nodes in any position of the linked list (similar to a standard list). Applications Linked lists are useful when your data is linked. For example when you need undo/redo functionality, the nodes can represent the state with links to the previous and next states. Another example would be a playlist of music, where each clip is linked with the next one. Linked lists can also be used to create other data structures, such as stack, queues and graphs. class Node : def __init__ ( self , data , next ): self . data = data self . next = next class LinkedList : def __init__ ( self ): self . head = None def add_at_front ( self , data ): self . head = Node ( data , self . head ) def add_at_end ( self , data ): if not self . head : self . head = Node ( data , None ) return curr = self . head while curr . next : curr = curr . next curr . next = Node ( data , None ) def get_last_node ( self ): n = self . head while ( n . next != None ): n = n . next return n . data def print_list ( self ): n = self . head while n != None : print ( n . data , end = \" => \" ) n = n . next print () There are two types of linked list: Single-Linked List: In this, the nodes point to the node immediately after it Doubly Linked List: In this, the nodes not only reference the node next to it but also the node before it. To start with Python, it does not have a linked list library built into it like the classical programming languages. Python does have an inbuilt type list that works as a dynamic array but its operation shouldn\u2019t be confused with a typical function of a linked list. This doesn\u2019t mean one cannot implement a linked list in Python, they can but it will not be straight up. Using deque() package When to use deque() as a linked list? Inserting and deleting elements at front and back respectively is the only need. Inserting and removing elements from the middle becomes time-consuming. In-place reversal since Python now allows elements to be reversed in the place itself. Storage is preferred over performance and not all elements get a separate node of their own # importing module import collections # initialising a deque() of arbitrary length linked_lst = collections . deque () # filling deque() with elements linked_lst . append ( 'first' ) linked_lst . append ( 'second' ) linked_lst . append ( 'third' ) print ( \"elements in the linked_list:\" ) print ( linked_lst ) # adding element at an arbitrary position linked_lst . insert ( 1 , 'fourth' ) print ( \"elements in the linked_list:\" ) print ( linked_lst ) # deleting the last element linked_lst . pop () print ( \"elements in the linked_list:\" ) print ( linked_lst ) # removing a specific element linked_lst . remove ( 'fourth' ) print ( \"elements in the linked_list:\" ) print ( linked_lst ) elements in the linked_list: deque(['first', 'second', 'third']) elements in the linked_list: deque(['first', 'fourth', 'second', 'third']) elements in the linked_list: deque(['first', 'fourth', 'second']) elements in the linked_list: deque(['first', 'second']) Using llist package The llist is an extension module for CPython providing basic linked list data structures. pip install llist # importing packages import llist from llist import sllist , sllistnode # creating a singly linked list lst = sllist ([ 'first' , 'second' , 'third' ]) print ( lst ) print ( lst . first ) print ( lst . last ) print ( lst . size ) print () # adding and inserting values lst . append ( 'fourth' ) node = lst . nodeat ( 2 ) lst . insertafter ( 'fifth' , node ) print ( lst ) print ( lst . first ) print ( lst . last ) print ( lst . size ) print () # poping a value #i.e. removing the last entry # of the list lst . pop () print ( lst ) print ( lst . first ) print ( lst . last ) print ( lst . size ) print () # removing a specific element node = lst . nodeat ( 1 ) lst . remove ( node ) print ( lst ) print ( lst . first ) print ( lst . last ) print ( lst . size ) print () sllist([first, second, third]) sllistnode(first) sllistnode(third) 3 sllist([first, second, third, fifth, fourth]) sllistnode(first) sllistnode(fourth) 5 sllist([first, second, third, fifth]) sllistnode(first) sllistnode(fifth) 4 sllist([first, third, fifth]) sllistnode(first) sllistnode(fifth) 3 Using StructLinks package StructLinks is used to easily Access and visualize different Data structures including Linked lists, Doubly Linked lists, Binary trees, Graphs, Stacks, and Queues. The structlinks.LinkedList and structlinks.DoublyLikedList modules could be used to make linked lists. All the operations that could be performed with a list could also be performed with structlinks.LinkedList class. # 1. Download the repo and set it as the current directory git clone https : // github . com / eeshannarula29 / structlinks # 2. Add the project directory to the path import os , sys sys . path . append ( os . getcwd ()) cd LinkedList / import LinkedList as ll # create an empty linked list lst = ll . LinkedList () # create a linked list with initial values lst = ll . LinkedList ([ 1 , 10.0 , 'string' ]) print ( lst ) print () print ( 'Elements of list:' ) # elements of the list element0 = lst [ 0 ] element1 = lst [ 1 ] element2 = lst [ 2 ] print ( f 'first element : { element0 } ' ) print ( f 'second element : { element1 } ' ) print ( f 'third element : { element2 } ' ) print () print ( 'Length of list:' ) # Length of the list length = len ( lst ) print ( f 'size of the list : { length } ' ) print () print ( 'Set item:' ) # Set item lst [ 0 ] = 10 print ( f 'list after setting lst[0] to 10 : { lst } ' ) print () print ( 'Append And Insert:' ) # Append And Insert lst . append ( 'another string' ) lst . insert ( 1 , 0.0 ) print ( f 'list after appedning and inserting: { lst } ' ) print () print ( 'Pop and Remove' ) # Pop and Remove element = lst . pop ( 0 ) lst . remove ( 10.0 ) print ( f 'list after poping and removing : { lst } ' ) print ( f 'pop function also returns the element : { element } ' ) [1 -> 10 -> -3 -> 5] Elements of list: first element : 1 second element : 10 third element : -3 Length of list: size of the list : 4 Set item: list after setting lst[0] to 10 : [10 -> 10 -> -3 -> 5] Append And Insert: list after appedning and inserting: [10 -> 0.0 -> 10 -> -3 -> 5 -> another string] Pop and Remove list after poping and removing : [0.0 -> -3 -> 5 -> another string] pop function also returns the element : 10","title":"LinkedList"},{"location":"DS/pyLinkedList/#using-deque-package","text":"When to use deque() as a linked list? Inserting and deleting elements at front and back respectively is the only need. Inserting and removing elements from the middle becomes time-consuming. In-place reversal since Python now allows elements to be reversed in the place itself. Storage is preferred over performance and not all elements get a separate node of their own # importing module import collections # initialising a deque() of arbitrary length linked_lst = collections . deque () # filling deque() with elements linked_lst . append ( 'first' ) linked_lst . append ( 'second' ) linked_lst . append ( 'third' ) print ( \"elements in the linked_list:\" ) print ( linked_lst ) # adding element at an arbitrary position linked_lst . insert ( 1 , 'fourth' ) print ( \"elements in the linked_list:\" ) print ( linked_lst ) # deleting the last element linked_lst . pop () print ( \"elements in the linked_list:\" ) print ( linked_lst ) # removing a specific element linked_lst . remove ( 'fourth' ) print ( \"elements in the linked_list:\" ) print ( linked_lst ) elements in the linked_list: deque(['first', 'second', 'third']) elements in the linked_list: deque(['first', 'fourth', 'second', 'third']) elements in the linked_list: deque(['first', 'fourth', 'second']) elements in the linked_list: deque(['first', 'second'])","title":"Using deque() package"},{"location":"DS/pyLinkedList/#using-llist-package","text":"The llist is an extension module for CPython providing basic linked list data structures. pip install llist # importing packages import llist from llist import sllist , sllistnode # creating a singly linked list lst = sllist ([ 'first' , 'second' , 'third' ]) print ( lst ) print ( lst . first ) print ( lst . last ) print ( lst . size ) print () # adding and inserting values lst . append ( 'fourth' ) node = lst . nodeat ( 2 ) lst . insertafter ( 'fifth' , node ) print ( lst ) print ( lst . first ) print ( lst . last ) print ( lst . size ) print () # poping a value #i.e. removing the last entry # of the list lst . pop () print ( lst ) print ( lst . first ) print ( lst . last ) print ( lst . size ) print () # removing a specific element node = lst . nodeat ( 1 ) lst . remove ( node ) print ( lst ) print ( lst . first ) print ( lst . last ) print ( lst . size ) print () sllist([first, second, third]) sllistnode(first) sllistnode(third) 3 sllist([first, second, third, fifth, fourth]) sllistnode(first) sllistnode(fourth) 5 sllist([first, second, third, fifth]) sllistnode(first) sllistnode(fifth) 4 sllist([first, third, fifth]) sllistnode(first) sllistnode(fifth) 3","title":"Using llist package"},{"location":"DS/pyLinkedList/#using-structlinks-package","text":"StructLinks is used to easily Access and visualize different Data structures including Linked lists, Doubly Linked lists, Binary trees, Graphs, Stacks, and Queues. The structlinks.LinkedList and structlinks.DoublyLikedList modules could be used to make linked lists. All the operations that could be performed with a list could also be performed with structlinks.LinkedList class. # 1. Download the repo and set it as the current directory git clone https : // github . com / eeshannarula29 / structlinks # 2. Add the project directory to the path import os , sys sys . path . append ( os . getcwd ()) cd LinkedList / import LinkedList as ll # create an empty linked list lst = ll . LinkedList () # create a linked list with initial values lst = ll . LinkedList ([ 1 , 10.0 , 'string' ]) print ( lst ) print () print ( 'Elements of list:' ) # elements of the list element0 = lst [ 0 ] element1 = lst [ 1 ] element2 = lst [ 2 ] print ( f 'first element : { element0 } ' ) print ( f 'second element : { element1 } ' ) print ( f 'third element : { element2 } ' ) print () print ( 'Length of list:' ) # Length of the list length = len ( lst ) print ( f 'size of the list : { length } ' ) print () print ( 'Set item:' ) # Set item lst [ 0 ] = 10 print ( f 'list after setting lst[0] to 10 : { lst } ' ) print () print ( 'Append And Insert:' ) # Append And Insert lst . append ( 'another string' ) lst . insert ( 1 , 0.0 ) print ( f 'list after appedning and inserting: { lst } ' ) print () print ( 'Pop and Remove' ) # Pop and Remove element = lst . pop ( 0 ) lst . remove ( 10.0 ) print ( f 'list after poping and removing : { lst } ' ) print ( f 'pop function also returns the element : { element } ' ) [1 -> 10 -> -3 -> 5] Elements of list: first element : 1 second element : 10 third element : -3 Length of list: size of the list : 4 Set item: list after setting lst[0] to 10 : [10 -> 10 -> -3 -> 5] Append And Insert: list after appedning and inserting: [10 -> 0.0 -> 10 -> -3 -> 5 -> another string] Pop and Remove list after poping and removing : [0.0 -> -3 -> 5 -> another string] pop function also returns the element : 10","title":"Using StructLinks package"},{"location":"DS/pyList/","text":"A list comprises a sequence of objects, usually represented using square brackets with commas between the items in the sequence as is done below: my_list = [ 'a' , 'b' , 'c' , 'd' ] print ( my_list ) ['a', 'b', 'c', 'd'] Above, my_list contains a sequence of character objects. Lists, however, accomodate items of varying types of objects: varied_list = [ 'a' , 1 , 'b' , 3.14159 ] # a list with elements of char, integer, and float types nested_list = [ 'hello' , 'governor' , [ 1.618 , 42 ]] # a list within a list! Lists allow for what is called indexing, in which a specified element of the list may be obtained. For instance, say you wanted to grab the second element of varied_list above. Then you could index the list as so: second_element = varied_list [ 1 ] # Grab second element of varied_list print ( second_element ) Now is a good time to mention that Python is what's called a zero-indexed programming language. This simply means that the \"first\" element in a list or other collection of data items is indexed using \"0\" (zero) rather than \"1\". This is why, above, we grab the second element of varied_list using the integer index \"1\" instead of \"2\" as some might expect from a one-indexed language (like MATLab). Another feature of python indexing that comes in handy is the use of negative indexing. As we discussed above, the \"first\" element of a python list is denoted by index \"0\"; thus, it is almost natural to consider the last element of the list as being indexed by \"-1\". Observe the following examples of negative indexing: last_element = my_list [ - 1 ] # the last element of my_list last_element_2 = my_list [ len ( my_list ) - 1 ] # also the last element of my_list, obtained differently second_to_last_element = my_list [ - 2 ] Similar to indexing is list slicing, in which a contiguous section of list may be accessed. The colon (:) is used to perform slicing, with integers denoting the positions at which to begin and end the slice. Below, we show that the beginning or ending integer for a slice may be omited when one is slicing from the beginning or to the end of the list. Also note below that the index for slice beginning is included in the slice, but the index for the slice end is not included. NFL_list = [ \"Chargers\" , \"Broncos\" , \"Raiders\" , \"Chiefs\" , \"Panthers\" , \"Falcons\" , \"Cowboys\" , \"Eagles\" ] AFC_west_list = NFL_list [: 4 ] # Slice to grab list indices 0, 1, 2, 3 -- \"Chargers\", \"Broncos\", \"Raiders\", \"Chiefs\" NFC_south_list = NFL_list [ 4 : 6 ] # Slice list indices 4, 5 -- \"Panthers\", \"Falcons\" NFC_east_list = NFL_list [ 6 :] # Slice list indices 6, 7 -- \"Cowboys\", \"Eagles\" List slices can also have a third number, representing the step, to include only alternate values in the slice. NFL_list = [ \"Chargers\" , \"Broncos\" , \"Raiders\" , \"Chiefs\" , \"Panthers\" , \"Falcons\" , \"Cowboys\" , \"Eagles\" ] list1 = NFL_list [ 3 :: 2 ] print ( list1 ) ['Chiefs', 'Falcons', 'Eagles'] Negative values can be used in list slicing (and normal list indexing). When negative values are used for the first and second values in a slice (or a normal index), they count from the end of the list. If a negative value is used for the step, the slice is done backwards. Using [::-1] as a slice is a common and idiomatic way to reverse a list. squares = [ 0 , 1 , 4 , 9 , 16 , 25 , 36 , 49 , 64 , 81 ] print ( squares [ 1 : - 3 ]) print ( squares [:: - 1 ]) print ( squares [: 4 : - 1 ]) [1, 4, 9, 16, 25, 36] [81, 64, 49, 36, 25, 16, 9, 4, 1, 0] [81, 64, 49, 36, 25] Sometimes you need to create an empty list and populate it later during the program. For example, if you are creating a queue management program, the queue is going to be empty in the beginning and get populated with people data later. An empty list is created with an empty pair of square brackets. Nested lists can be used to represent 2D grids, such as matrices. Indexing strings behaves as though you are indexing a list containing each character in the string. empty_list = [] print ( empty_list ) m = [ [ 1 , 2 , 3 ], [ 4 , 5 , 6 ] ] print ( m ) s = \"Hello world\" print ( s [ 6 ]) [] [[1, 2, 3], [4, 5, 6]] w List Operations The item at a certain index in a list can be reassigned. Lists can be added and multiplied in the same way as strings. To check if an item is in a list, the in operator can be used. It returns True if the item occurs one or more times in the list, and False if it doesn't. The in operator is also used to determine whether or not a string is a substring of another string. M = [ 1 , 1 , 1 ] M [ 1 ] = \"hello\" print ( M ) print ( M * 3 ) print ( M + [ 1 , 2 ]) print ( 1 in M ) print ( \"Spam\" in M ) print ( not \"hello\" in M ) [1, 'hello', 1] [1, 'hello', 1, 1, 'hello', 1, 1, 'hello', 1] [1, 'hello', 1, 1, 2] True False False List Functions len(list): to get the number of items in a list. max(list): Returns the list item with the maximum value min(list): Returns the list item with minimum value list.append(item): adds an item to the end of an existing list. list.insert(index, item): is similar to append, except that it allows you to insert a new item at any position in the list, as opposed to just at the end. list.index(item): finds the first occurrence of a list item and returns its index. If the item isn't in the list, it raises a ValueError. list.count(item): Returns a count of how many times an item occurs in a list list.remove(item): Removes an object from a list list.pop(index) removes the item at the given index. list.reverse(): Reverses items in a list. list.sort() sorts the list. By default, the list is sorted ascending. You can specify reverse=True as the parameter, to sort descending. nums = [ 1 , 2 , 3 ] nums . append ( 4 ) print ( nums ) nums . insert ( 2 , \"hello\" ) print ( nums ) print ( len ( nums )) print ( nums . index ( 3 )) nums += [ 1 , 2 , 1 ] print ( nums . count ( 1 )) nums . remove ( \"hello\" ) print ( nums . reverse ()) print ( max ( nums )) print ( min ( nums )) [1, 2, 3, 4] [1, 2, 'hello', 3, 4] 5 3 3 None 4 1 # use iterator functions like enumerate, zip, iter, next # define a list of days in English and French days = [ \"Sun\" , \"Mon\" , \"Tue\" , \"Wed\" , \"Thu\" , \"Fri\" , \"Sat\" ] daysFr = [ \"Dim\" , \"Lun\" , \"Mar\" , \"Mer\" , \"Jeu\" , \"Ven\" , \"Sam\" ] # use iter to create an iterator over a collection i = iter ( days ) print ( next ( i )) # Sun print ( next ( i )) # Mon print ( next ( i )) # Tue # iterate using a function and a sentinel with open ( \"game.txt\" , \"r\" ) as fp : for line in iter ( fp . readline , '' ): print ( line ) # use regular interation over the days for m in range ( len ( days )): print ( m + 1 , days [ m ]) 1 Sun 2 Mon 3 Tue 4 Wed 5 Thu 6 Fri 7 Sat # using enumerate reduces code and provides a counter for i , m in enumerate ( days , start = 1 ): print ( i , m ) 1 Sun 2 Mon 3 Tue 4 Wed 5 Thu 6 Fri 7 Sat # use zip to combine sequences for m in zip ( days , daysFr ): print ( m ) for i , m in enumerate ( zip ( days , daysFr ), start = 1 ): print ( i , m [ 0 ], \"=\" , m [ 1 ], \"in French\" ) ('Sun', 'Dim') ('Mon', 'Lun') ('Tue', 'Mar') ('Wed', 'Mer') ('Thu', 'Jeu') ('Fri', 'Ven') ('Sat', 'Sam') 1 Sun = Dim in French 2 Mon = Lun in French 3 Tue = Mar in French 4 Wed = Mer in French 5 Thu = Jeu in French 6 Fri = Ven in French 7 Sat = Sam in French","title":"Lists"},{"location":"DS/pyList/#list-operations","text":"The item at a certain index in a list can be reassigned. Lists can be added and multiplied in the same way as strings. To check if an item is in a list, the in operator can be used. It returns True if the item occurs one or more times in the list, and False if it doesn't. The in operator is also used to determine whether or not a string is a substring of another string. M = [ 1 , 1 , 1 ] M [ 1 ] = \"hello\" print ( M ) print ( M * 3 ) print ( M + [ 1 , 2 ]) print ( 1 in M ) print ( \"Spam\" in M ) print ( not \"hello\" in M ) [1, 'hello', 1] [1, 'hello', 1, 1, 'hello', 1, 1, 'hello', 1] [1, 'hello', 1, 1, 2] True False False","title":"List Operations"},{"location":"DS/pyList/#list-functions","text":"len(list): to get the number of items in a list. max(list): Returns the list item with the maximum value min(list): Returns the list item with minimum value list.append(item): adds an item to the end of an existing list. list.insert(index, item): is similar to append, except that it allows you to insert a new item at any position in the list, as opposed to just at the end. list.index(item): finds the first occurrence of a list item and returns its index. If the item isn't in the list, it raises a ValueError. list.count(item): Returns a count of how many times an item occurs in a list list.remove(item): Removes an object from a list list.pop(index) removes the item at the given index. list.reverse(): Reverses items in a list. list.sort() sorts the list. By default, the list is sorted ascending. You can specify reverse=True as the parameter, to sort descending. nums = [ 1 , 2 , 3 ] nums . append ( 4 ) print ( nums ) nums . insert ( 2 , \"hello\" ) print ( nums ) print ( len ( nums )) print ( nums . index ( 3 )) nums += [ 1 , 2 , 1 ] print ( nums . count ( 1 )) nums . remove ( \"hello\" ) print ( nums . reverse ()) print ( max ( nums )) print ( min ( nums )) [1, 2, 3, 4] [1, 2, 'hello', 3, 4] 5 3 3 None 4 1 # use iterator functions like enumerate, zip, iter, next # define a list of days in English and French days = [ \"Sun\" , \"Mon\" , \"Tue\" , \"Wed\" , \"Thu\" , \"Fri\" , \"Sat\" ] daysFr = [ \"Dim\" , \"Lun\" , \"Mar\" , \"Mer\" , \"Jeu\" , \"Ven\" , \"Sam\" ] # use iter to create an iterator over a collection i = iter ( days ) print ( next ( i )) # Sun print ( next ( i )) # Mon print ( next ( i )) # Tue # iterate using a function and a sentinel with open ( \"game.txt\" , \"r\" ) as fp : for line in iter ( fp . readline , '' ): print ( line ) # use regular interation over the days for m in range ( len ( days )): print ( m + 1 , days [ m ]) 1 Sun 2 Mon 3 Tue 4 Wed 5 Thu 6 Fri 7 Sat # using enumerate reduces code and provides a counter for i , m in enumerate ( days , start = 1 ): print ( i , m ) 1 Sun 2 Mon 3 Tue 4 Wed 5 Thu 6 Fri 7 Sat # use zip to combine sequences for m in zip ( days , daysFr ): print ( m ) for i , m in enumerate ( zip ( days , daysFr ), start = 1 ): print ( i , m [ 0 ], \"=\" , m [ 1 ], \"in French\" ) ('Sun', 'Dim') ('Mon', 'Lun') ('Tue', 'Mar') ('Wed', 'Mer') ('Thu', 'Jeu') ('Fri', 'Ven') ('Sat', 'Sam') 1 Sun = Dim in French 2 Mon = Lun in French 3 Tue = Mar in French 4 Wed = Mer in French 5 Thu = Jeu in French 6 Fri = Ven in French 7 Sat = Sam in French","title":"List Functions"},{"location":"DS/pyNamedTuple/","text":"Named tuples are basically easy-to-create, lightweight object types. Named tuple instances can be referenced using object-like variable dereferencing or the standard tuple syntax. They can be used similarly to struct or other common record types, except that they are immutable. It is common to represent a point as a tuple (x, y). This leads to code like the following: pt1 = ( 1.0 , 5.0 ) pt2 = ( 2.5 , 1.5 ) from math import sqrt line_length = sqrt (( pt1 [ 0 ] - pt2 [ 0 ]) ** 2 + ( pt1 [ 1 ] - pt2 [ 1 ]) ** 2 ) print ( line_length ) 3.8078865529319543 Using a named tuple it becomes more readable: from collections import namedtuple Point = namedtuple ( 'Point' , 'x y' ) pt1 = Point ( 1.0 , 5.0 ) pt2 = Point ( 2.5 , 1.5 ) from math import sqrt line_length = sqrt (( pt1 . x - pt2 . x ) ** 2 + ( pt1 . y - pt2 . y ) ** 2 ) print ( line_length ) 3.8078865529319543 However, named tuples are still backwards compatible with normal tuples, so the following will still work: Point = namedtuple ( 'Point' , 'x y' ) pt1 = Point ( 1.0 , 5.0 ) pt2 = Point ( 2.5 , 1.5 ) from math import sqrt # use index referencing line_length = sqrt (( pt1 [ 0 ] - pt2 [ 0 ]) ** 2 + ( pt1 [ 1 ] - pt2 [ 1 ]) ** 2 ) print ( line_length ) # use tuple unpacking x1 , y1 = pt1 print ( x1 ) print ( y1 ) 3.8078865529319543 1.0 5.0 Thus, you should use named tuples instead of tuples anywhere you think object notation will make your code more pythonic and more easily readable. Use them to represent very simple value types, particularly when passing them as parameters to functions. It makes the functions more readable, without seeing the context of the tuple packing. NamedTuples, like dictionaries, contain keys that are hashed to a particular value. But on contrary, it supports both access from key-value and iteration, the functionality that dictionaries lack. # Python code to demonstrate namedtuple() from collections import namedtuple # Declaring namedtuple() Student = namedtuple ( 'Student' , [ 'name' , 'age' , 'DOB' ]) # Adding values S = Student ( 'Harry' , '12' , '31071980' ) # Access by index: The attribute values of namedtuple() # are ordered and can be accessed using the index number unlike dictionaries # which are not accessible by index. print ( \"The Student age using index is : \" , end = \"\" ) print ( S [ 1 ]) # Access using name : Access by keyname is also allowed as in dictionaries. print ( \"The Student name using keyname is : \" , end = \"\" ) print ( S . name ) # Access using getattr(): This is yet another way to access the value by # giving namedtuple and key value as its argument. print ( \"The Student DOB using getattr() is : \" , end = \"\" ) print ( getattr ( S , 'DOB' )) The Student age using index is : 12 The Student name using keyname is : Harry The Student DOB using getattr() is : 31071980 Conversion Operations _make() : This function is used to return a namedtuple() from the iterable passed as argument. _asdict() : This function returns the OrderedDict() as constructed from the mapped values of namedtuple(). using \u201c**\u201d (double star) operator : This function is used to convert a dictionary into the namedtuple(). # Python code to demonstrate namedtuple() and # _make(), _asdict() and \"**\" operator # importing \"collections\" for namedtuple() import collections # Declaring namedtuple() Student = collections . namedtuple ( 'Student' , [ 'name' , 'age' , 'DOB' ]) # Adding values S = Student ( 'Harry' , '12' , '31071980' ) # initializing iterable li = [ 'Ron' , '12' , '01031980' ] # initializing dict di = { 'name' : \"Hermione\" , 'age' : 12 , 'DOB' : '19091979' } # using _make() to return namedtuple() print ( \"The namedtuple instance using iterable is : \" ) print ( Student . _make ( li )) # using _asdict() to return an OrderedDict() print ( \"The OrderedDict instance using namedtuple is : \" ) print ( S . _asdict ()) # using ** operator to return namedtuple from dictionary print ( \"The namedtuple instance from dict is : \" ) print ( Student ( ** di )) The namedtuple instance using iterable is : Student(name='Ron', age='12', DOB='01031980') The OrderedDict instance using namedtuple is : OrderedDict([('name', 'Harry'), ('age', '12'), ('DOB', '31071980')]) The namedtuple instance from dict is : Student(name='Hermione', age=12, DOB='19091979') Additional Operation _fields : This function is used to return all the keynames of the namespace declared. _replace() : _replace() is like str.replace() but targets named fields( does not modify the original values) # Python code to demonstrate namedtuple() and # _fields and _replace() # importing \"collections\" for namedtuple() import collections # Declaring namedtuple() Student = collections . namedtuple ( 'Student' , [ 'name' , 'age' , 'DOB' ]) # Adding values S = Student ( 'Harry' , '12' , '31071980' ) # using _fields to display all the keynames of namedtuple() print ( \"All the fields of students are : \" ) print ( S . _fields ) # ._replace returns a new namedtuple, it does not modify the original print ( \"returns a new namedtuple : \" ) print ( S . _replace ( name = 'Ron' )) # original namedtuple print ( S ) All the fields of students are : ('name', 'age', 'DOB') returns a new namedtuple : Student(name='Ron', age='12', DOB='31071980') Student(name='Harry', age='12', DOB='31071980')","title":"NamedTuple"},{"location":"DS/pyNamedTuple/#conversion-operations","text":"_make() : This function is used to return a namedtuple() from the iterable passed as argument. _asdict() : This function returns the OrderedDict() as constructed from the mapped values of namedtuple(). using \u201c**\u201d (double star) operator : This function is used to convert a dictionary into the namedtuple(). # Python code to demonstrate namedtuple() and # _make(), _asdict() and \"**\" operator # importing \"collections\" for namedtuple() import collections # Declaring namedtuple() Student = collections . namedtuple ( 'Student' , [ 'name' , 'age' , 'DOB' ]) # Adding values S = Student ( 'Harry' , '12' , '31071980' ) # initializing iterable li = [ 'Ron' , '12' , '01031980' ] # initializing dict di = { 'name' : \"Hermione\" , 'age' : 12 , 'DOB' : '19091979' } # using _make() to return namedtuple() print ( \"The namedtuple instance using iterable is : \" ) print ( Student . _make ( li )) # using _asdict() to return an OrderedDict() print ( \"The OrderedDict instance using namedtuple is : \" ) print ( S . _asdict ()) # using ** operator to return namedtuple from dictionary print ( \"The namedtuple instance from dict is : \" ) print ( Student ( ** di )) The namedtuple instance using iterable is : Student(name='Ron', age='12', DOB='01031980') The OrderedDict instance using namedtuple is : OrderedDict([('name', 'Harry'), ('age', '12'), ('DOB', '31071980')]) The namedtuple instance from dict is : Student(name='Hermione', age=12, DOB='19091979')","title":"Conversion Operations"},{"location":"DS/pyNamedTuple/#additional-operation","text":"_fields : This function is used to return all the keynames of the namespace declared. _replace() : _replace() is like str.replace() but targets named fields( does not modify the original values) # Python code to demonstrate namedtuple() and # _fields and _replace() # importing \"collections\" for namedtuple() import collections # Declaring namedtuple() Student = collections . namedtuple ( 'Student' , [ 'name' , 'age' , 'DOB' ]) # Adding values S = Student ( 'Harry' , '12' , '31071980' ) # using _fields to display all the keynames of namedtuple() print ( \"All the fields of students are : \" ) print ( S . _fields ) # ._replace returns a new namedtuple, it does not modify the original print ( \"returns a new namedtuple : \" ) print ( S . _replace ( name = 'Ron' )) # original namedtuple print ( S ) All the fields of students are : ('name', 'age', 'DOB') returns a new namedtuple : Student(name='Ron', age='12', DOB='31071980') Student(name='Harry', age='12', DOB='31071980')","title":"Additional Operation"},{"location":"DS/pyOrdereddict/","text":"An OrderedDict is a dictionary subclass that remembers the order that keys were first inserted. The only difference between dict() and OrderedDict() is that: OrderedDict preserves the order in which the keys are inserted. A regular dict doesn\u2019t track the insertion order, and iterating it gives the values in an arbitrary order. By contrast, the order the items are inserted is remembered by OrderedDict. # A Python program to demonstrate working # of OrderedDict from collections import OrderedDict print ( \"This is a Dict: \\n \" ) d = {} d [ 'a' ] = 1 d [ 'b' ] = 2 d [ 'c' ] = 3 d [ 'd' ] = 4 for key , value in d . items (): print ( key , value ) print ( \" \\n This is an Ordered Dict: \\n \" ) od = OrderedDict () od [ 'a' ] = 1 od [ 'b' ] = 2 od [ 'c' ] = 3 od [ 'd' ] = 4 for key , value in od . items (): print ( key , value ) This is a Dict: a 1 b 2 c 3 d 4 This is an Ordered Dict: a 1 b 2 c 3 d 4 Key value Change If the value of a certain key is changed, the position of the key remains unchanged in OrderedDict. # A Python program to demonstrate working of key # value change in OrderedDict from collections import OrderedDict print ( \"Before: \\n \" ) od = OrderedDict () od [ 'a' ] = 1 od [ 'b' ] = 2 od [ 'c' ] = 3 od [ 'd' ] = 4 for key , value in od . items (): print ( key , value ) print ( \" \\n After: \\n \" ) od [ 'c' ] = 5 for key , value in od . items (): print ( key , value ) Before: a 1 b 2 c 3 d 4 After: a 1 b 2 c 5 d 4 Deletion and Re-Inserting Deleting and re-inserting the same key will push it to the back as OrderedDict, however, maintains the order of insertion. # A Python program to demonstrate working of deletion # re-insertion in OrderedDict from collections import OrderedDict print ( \"Before deleting: \\n \" ) od = OrderedDict () od [ 'a' ] = 1 od [ 'b' ] = 2 od [ 'c' ] = 3 od [ 'd' ] = 4 for key , value in od . items (): print ( key , value ) print ( \" \\n After deleting: \\n \" ) od . pop ( 'c' ) for key , value in od . items (): print ( key , value ) print ( \" \\n After re-inserting: \\n \" ) od [ 'c' ] = 3 for key , value in od . items (): print ( key , value ) Before deleting: a 1 b 2 c 3 d 4 After deleting: a 1 b 2 d 4 After re-inserting: a 1 b 2 d 4 c 3 from collections import OrderedDict def main (): # list of sport teams with wins and losses sportTeams = [( \"Royals\" , ( 18 , 12 )), ( \"Rockets\" , ( 24 , 6 )), ( \"Cardinals\" , ( 20 , 10 )), ( \"Dragons\" , ( 22 , 8 )), ( \"Kings\" , ( 15 , 15 )), ( \"Chargers\" , ( 20 , 10 )), ( \"Jets\" , ( 16 , 14 )), ( \"Warriors\" , ( 25 , 5 ))] # sort the teams by number of wins sortedTeams = sorted ( sportTeams , key = lambda t : t [ 1 ][ 0 ], reverse = True ) # create an ordered dictionary of the teams teams = OrderedDict ( sortedTeams ) print ( teams ) # Use popitem to remove the top item tm , wl = teams . popitem ( False ) print ( \"Top team: \" , tm , wl ) # What are next the top 4 teams? for i , team in enumerate ( teams , start = 1 ): print ( i , team ) if i == 4 : break # test for equality a = OrderedDict ({ \"a\" : 1 , \"b\" : 2 , \"c\" : 3 }) b = OrderedDict ({ \"a\" : 1 , \"c\" : 3 , \"b\" : 2 }) print ( \"Equality test: \" , a == b ) if __name__ == \"__main__\" : main () OrderedDict([('Warriors', (25, 5)), ('Rockets', (24, 6)), ('Dragons', (22, 8)), ('Cardinals', (20, 10)), ('Chargers', (20, 10)), ('Royals', (18, 12)), ('Jets', (16, 14)), ('Kings', (15, 15))]) Top team: Warriors (25, 5) 1 Rockets 2 Dragons 3 Cardinals 4 Chargers Equality test: False","title":"Ordereddict"},{"location":"DS/pyOrdereddict/#key-value-change","text":"If the value of a certain key is changed, the position of the key remains unchanged in OrderedDict. # A Python program to demonstrate working of key # value change in OrderedDict from collections import OrderedDict print ( \"Before: \\n \" ) od = OrderedDict () od [ 'a' ] = 1 od [ 'b' ] = 2 od [ 'c' ] = 3 od [ 'd' ] = 4 for key , value in od . items (): print ( key , value ) print ( \" \\n After: \\n \" ) od [ 'c' ] = 5 for key , value in od . items (): print ( key , value ) Before: a 1 b 2 c 3 d 4 After: a 1 b 2 c 5 d 4","title":"Key value Change"},{"location":"DS/pyOrdereddict/#deletion-and-re-inserting","text":"Deleting and re-inserting the same key will push it to the back as OrderedDict, however, maintains the order of insertion. # A Python program to demonstrate working of deletion # re-insertion in OrderedDict from collections import OrderedDict print ( \"Before deleting: \\n \" ) od = OrderedDict () od [ 'a' ] = 1 od [ 'b' ] = 2 od [ 'c' ] = 3 od [ 'd' ] = 4 for key , value in od . items (): print ( key , value ) print ( \" \\n After deleting: \\n \" ) od . pop ( 'c' ) for key , value in od . items (): print ( key , value ) print ( \" \\n After re-inserting: \\n \" ) od [ 'c' ] = 3 for key , value in od . items (): print ( key , value ) Before deleting: a 1 b 2 c 3 d 4 After deleting: a 1 b 2 d 4 After re-inserting: a 1 b 2 d 4 c 3 from collections import OrderedDict def main (): # list of sport teams with wins and losses sportTeams = [( \"Royals\" , ( 18 , 12 )), ( \"Rockets\" , ( 24 , 6 )), ( \"Cardinals\" , ( 20 , 10 )), ( \"Dragons\" , ( 22 , 8 )), ( \"Kings\" , ( 15 , 15 )), ( \"Chargers\" , ( 20 , 10 )), ( \"Jets\" , ( 16 , 14 )), ( \"Warriors\" , ( 25 , 5 ))] # sort the teams by number of wins sortedTeams = sorted ( sportTeams , key = lambda t : t [ 1 ][ 0 ], reverse = True ) # create an ordered dictionary of the teams teams = OrderedDict ( sortedTeams ) print ( teams ) # Use popitem to remove the top item tm , wl = teams . popitem ( False ) print ( \"Top team: \" , tm , wl ) # What are next the top 4 teams? for i , team in enumerate ( teams , start = 1 ): print ( i , team ) if i == 4 : break # test for equality a = OrderedDict ({ \"a\" : 1 , \"b\" : 2 , \"c\" : 3 }) b = OrderedDict ({ \"a\" : 1 , \"c\" : 3 , \"b\" : 2 }) print ( \"Equality test: \" , a == b ) if __name__ == \"__main__\" : main () OrderedDict([('Warriors', (25, 5)), ('Rockets', (24, 6)), ('Dragons', (22, 8)), ('Cardinals', (20, 10)), ('Chargers', (20, 10)), ('Royals', (18, 12)), ('Jets', (16, 14)), ('Kings', (15, 15))]) Top team: Warriors (25, 5) 1 Rockets 2 Dragons 3 Cardinals 4 Chargers Equality test: False","title":"Deletion and Re-Inserting"},{"location":"DS/pyQueue/","text":"A queue is similar to a stack, but defines a different way to add and remove elements. The elements are inserted from one end, called the rear, and deleted from the other end, called the front. This behavior is called FIFO (First in First Out). Terminology The process of adding new elements into the queue is called enqueue. The process of removal of an element from the queue is called dequeue. Applications Queues are used whenever we need to manage objects in order starting with the first one in. Scenarios include printing documents on a printer, call center systems answering people on hold, and so on. Queue in Python can be implemented by the following ways: list collections.deque queue.Queue Using List Python lists are the easiest way to implement a queue functionality. List is a Python\u2019s built-in data structure that can be used as a queue. Instead of enqueue() and dequeue(), append() and pop() function is used. However, lists are quite slow for this purpose because inserting or deleting an element at the beginning requires shifting all of the other elements by one, requiring O(n) time. # Python program to # demonstrate queue implementation # using list # Initializing a queue queue = [] # Adding elements to the queue queue . append ( 'a' ) queue . append ( 'b' ) queue . append ( 'c' ) print ( \"Initial queue\" ) print ( queue ) # Removing elements from the queue print ( \" \\n Elements dequeued from queue\" ) print ( queue . pop ( 0 )) print ( queue . pop ( 0 )) print ( queue . pop ( 0 )) print ( \" \\n Queue after removing elements\" ) print ( queue ) # Uncommenting print(queue.pop(0)) # will raise and IndexError # as the queue is now empty Initial queue ['a', 'b', 'c'] Elements dequeued from queue a b c Queue after removing elements [] Using collections.deque Queue in Python can be implemented using deque class from the collections module. Deque is preferred over list in the cases where we need quicker append and pop operations from both the ends of container, as deque provides an O(1) time complexity for append and pop operations as compared to list which provides O(n) time complexity. Instead of enqueue and deque, append() and popleft() functions are used. # Python program to # demonstrate queue implementation # using collections.dequeue from collections import deque # Initializing a queue q = deque () # Adding elements to a queue q . append ( 'a' ) q . append ( 'b' ) q . append ( 'c' ) print ( \"Initial queue\" ) print ( q ) # Removing elements from a queue print ( \" \\n Elements dequeued from the queue\" ) print ( q . popleft ()) print ( q . popleft ()) print ( q . popleft ()) print ( \" \\n Queue after removing elements\" ) print ( q ) # Uncommenting q.popleft() # will raise an IndexError # as queue is now empty Initial queue deque(['a', 'b', 'c']) Elements dequeued from the queue a b c Queue after removing elements deque([]) Using queue.Queue Queue is built-in module of Python which is used to implement a queue. queue.Queue(maxsize) initializes a variable to a maximum size of maxsize. A maxsize of zero \u20180\u2019 means a infinite queue. This Queue follows FIFO rule. There are various functions available in this module: maxsize \u2013 Number of items allowed in the queue. empty() \u2013 Return True if the queue is empty, False otherwise. full() \u2013 Return True if there are maxsize items in the queue. If the queue was initialized with maxsize=0 (the default), then full() never returns True. get() \u2013 Remove and return an item from the queue. If queue is empty, wait until an item is available. get_nowait() \u2013 Return an item if one is immediately available, else raise QueueEmpty. put(item) \u2013 Put an item into the queue. If the queue is full, wait until a free slot is available before adding the item. put_nowait(item) \u2013 Put an item into the queue without blocking. If no free slot is immediately available, raise QueueFull. qsize() \u2013 Return the number of items in the queue. # Python program to # demonstrate implementation of # queue using queue module from queue import Queue # Initializing a queue q = Queue ( maxsize = 3 ) # qsize() give the maxsize # of the Queue print ( q . qsize ()) # Adding of element to queue q . put ( 'a' ) q . put ( 'b' ) q . put ( 'c' ) # Return Boolean for Full # Queue print ( \" \\n Full: \" , q . full ()) # Removing element from queue print ( \" \\n Elements dequeued from the queue\" ) print ( q . get ()) print ( q . get ()) print ( q . get ()) # Return Boolean for Empty # Queue print ( \" \\n Empty: \" , q . empty ()) q . put ( 1 ) print ( \" \\n Empty: \" , q . empty ()) print ( \"Full: \" , q . full ()) # This would result into Infinite # Loop as the Queue is empty. # print(q.get()) 0 Full: True Elements dequeued from the queue a b c Empty: True Empty: False Full: False","title":"Queue"},{"location":"DS/pyQueue/#using-list","text":"Python lists are the easiest way to implement a queue functionality. List is a Python\u2019s built-in data structure that can be used as a queue. Instead of enqueue() and dequeue(), append() and pop() function is used. However, lists are quite slow for this purpose because inserting or deleting an element at the beginning requires shifting all of the other elements by one, requiring O(n) time. # Python program to # demonstrate queue implementation # using list # Initializing a queue queue = [] # Adding elements to the queue queue . append ( 'a' ) queue . append ( 'b' ) queue . append ( 'c' ) print ( \"Initial queue\" ) print ( queue ) # Removing elements from the queue print ( \" \\n Elements dequeued from queue\" ) print ( queue . pop ( 0 )) print ( queue . pop ( 0 )) print ( queue . pop ( 0 )) print ( \" \\n Queue after removing elements\" ) print ( queue ) # Uncommenting print(queue.pop(0)) # will raise and IndexError # as the queue is now empty Initial queue ['a', 'b', 'c'] Elements dequeued from queue a b c Queue after removing elements []","title":"Using List"},{"location":"DS/pyQueue/#using-collectionsdeque","text":"Queue in Python can be implemented using deque class from the collections module. Deque is preferred over list in the cases where we need quicker append and pop operations from both the ends of container, as deque provides an O(1) time complexity for append and pop operations as compared to list which provides O(n) time complexity. Instead of enqueue and deque, append() and popleft() functions are used. # Python program to # demonstrate queue implementation # using collections.dequeue from collections import deque # Initializing a queue q = deque () # Adding elements to a queue q . append ( 'a' ) q . append ( 'b' ) q . append ( 'c' ) print ( \"Initial queue\" ) print ( q ) # Removing elements from a queue print ( \" \\n Elements dequeued from the queue\" ) print ( q . popleft ()) print ( q . popleft ()) print ( q . popleft ()) print ( \" \\n Queue after removing elements\" ) print ( q ) # Uncommenting q.popleft() # will raise an IndexError # as queue is now empty Initial queue deque(['a', 'b', 'c']) Elements dequeued from the queue a b c Queue after removing elements deque([])","title":"Using collections.deque"},{"location":"DS/pyQueue/#using-queuequeue","text":"Queue is built-in module of Python which is used to implement a queue. queue.Queue(maxsize) initializes a variable to a maximum size of maxsize. A maxsize of zero \u20180\u2019 means a infinite queue. This Queue follows FIFO rule. There are various functions available in this module: maxsize \u2013 Number of items allowed in the queue. empty() \u2013 Return True if the queue is empty, False otherwise. full() \u2013 Return True if there are maxsize items in the queue. If the queue was initialized with maxsize=0 (the default), then full() never returns True. get() \u2013 Remove and return an item from the queue. If queue is empty, wait until an item is available. get_nowait() \u2013 Return an item if one is immediately available, else raise QueueEmpty. put(item) \u2013 Put an item into the queue. If the queue is full, wait until a free slot is available before adding the item. put_nowait(item) \u2013 Put an item into the queue without blocking. If no free slot is immediately available, raise QueueFull. qsize() \u2013 Return the number of items in the queue. # Python program to # demonstrate implementation of # queue using queue module from queue import Queue # Initializing a queue q = Queue ( maxsize = 3 ) # qsize() give the maxsize # of the Queue print ( q . qsize ()) # Adding of element to queue q . put ( 'a' ) q . put ( 'b' ) q . put ( 'c' ) # Return Boolean for Full # Queue print ( \" \\n Full: \" , q . full ()) # Removing element from queue print ( \" \\n Elements dequeued from the queue\" ) print ( q . get ()) print ( q . get ()) print ( q . get ()) # Return Boolean for Empty # Queue print ( \" \\n Empty: \" , q . empty ()) q . put ( 1 ) print ( \" \\n Empty: \" , q . empty ()) print ( \"Full: \" , q . full ()) # This would result into Infinite # Loop as the Queue is empty. # print(q.get()) 0 Full: True Elements dequeued from the queue a b c Empty: True Empty: False Full: False","title":"Using queue.Queue"},{"location":"DS/pySet/","text":"Sets are data structures, similar to lists or dictionaries. They are created using curly braces, or the set function. They share some functionality with lists, such as the use of in to check whether they contain a particular item. To create an empty set, you must use set(), as {} creates an empty dictionary. One small syntax nuisance: {1, 2, 3} is a set, but {} is an empty dictionary. empty_set = set () num_set = { 1 , 2 , 3 , 4 , 5 } word_set = set ([ \"spam\" , \"eggs\" , \"ham\" ]) print ( 3 in num_set ) print ( \"spam\" not in word_set ) True False Sets differ from lists in several ways, but share several list operations such as len. They are unordered, which means that they can't be indexed. They cannot contain duplicate elements. Due to the way they're stored, it's faster to check whether an item is part of a set, rather than part of a list. Instead of using append to add to a set, use add. The method remove removes a specific element from a set; pop removes an arbitrary element. Basic uses of sets include membership testing and the elimination of duplicate entries. nums = { 1 , 1 , 2 , 3 , 1 , 2 , 1 , 1 } print ( nums ) nums . add ( - 7 ) nums . remove ( 3 ) print ( nums ) {1, 2, 3} {1, 2, -7} Set Operations Sets can be combined using mathematical operations. The union operator | combines two sets to form a new one containing items in either. OR The intersection operator & gets items only in both. AND The difference operator - gets items in the first set but not in the second. The symmetric difference operator ^ gets items in either set, but not both. XOR The comparison operators check for subset and superset relationships. >= and <= f = { 3 , 2 , 9 , 4 , 5 , 6 } s = { 7 , 8 , 9 , 1 , 4 , 6 , 6 , 8 } print ( f | s ) #Union print ( f & s ) #Intersection print ( f - s ) # Difference print ( f ^ s ) #Sym Difference print ( f >= s ) #f superset of s {1, 2, 3, 4, 5, 6, 7, 8, 9} {9, 4, 6} {2, 3, 5} {1, 2, 3, 5, 7, 8} False Sets provide methods as well as operators. The argument you pass to a method can be any iterable, not just a set. And accept more than one argument f . issuperset ([ 1 , 2 , 3 ]) False f . union ([ 1 , 2 , 3 ], ( 3 , 4 , 5 ), { 5 , 6 , 7 }, { 7 : 'a' , 8 : 'b' }) {1, 2, 3, 4, 5, 6, 7, 8, 9} Union # Python3 program for union() function set1 = { 2 , 4 , 5 , 6 } set2 = { 4 , 6 , 7 , 8 } set3 = { 7 , 8 , 9 , 10 } # union of two sets print ( \"set1 U set2 : \" , set1 . union ( set2 )) # union of three sets print ( \"set1 U set2 U set3 :\" , set1 . union ( set2 , set3 )) set1 U set2 : {2, 4, 5, 6, 7, 8} set1 U set2 U set3 : {2, 4, 5, 6, 7, 8, 9, 10} Intersection # Python3 program for intersection() function set1 = { 2 , 4 , 5 , 6 } set2 = { 4 , 6 , 7 , 8 } set3 = { 4 , 6 , 8 } # union of two sets print ( \"set1 intersection set2 : \" , set1 . intersection ( set2 )) # union of three sets print ( \"set1 intersection set2 intersection set3 :\" , set1 . intersection ( set2 , set3 )) set1 intersection set2 : {4, 6} set1 intersection set2 intersection set3 : {4, 6} # Python3 program for intersection() function set1 = { 2 , 4 , 5 , 6 } set2 = { 4 , 6 , 7 , 8 } set3 = { 1 , 0 , 12 } print ( set1 & set2 ) print ( set1 & set3 ) print ( set1 & set2 & set3 ) {4, 6} set() set() Difference # Python code to get the difference between two sets # using difference() between set A and set B # Driver Code A = { 10 , 20 , 30 , 40 , 80 } B = { 100 , 30 , 80 , 40 , 60 } print ( A . difference ( B )) print ( B . difference ( A )) {10, 20} {100, 60}","title":"Set"},{"location":"DS/pySet/#set-operations","text":"Sets can be combined using mathematical operations. The union operator | combines two sets to form a new one containing items in either. OR The intersection operator & gets items only in both. AND The difference operator - gets items in the first set but not in the second. The symmetric difference operator ^ gets items in either set, but not both. XOR The comparison operators check for subset and superset relationships. >= and <= f = { 3 , 2 , 9 , 4 , 5 , 6 } s = { 7 , 8 , 9 , 1 , 4 , 6 , 6 , 8 } print ( f | s ) #Union print ( f & s ) #Intersection print ( f - s ) # Difference print ( f ^ s ) #Sym Difference print ( f >= s ) #f superset of s {1, 2, 3, 4, 5, 6, 7, 8, 9} {9, 4, 6} {2, 3, 5} {1, 2, 3, 5, 7, 8} False Sets provide methods as well as operators. The argument you pass to a method can be any iterable, not just a set. And accept more than one argument f . issuperset ([ 1 , 2 , 3 ]) False f . union ([ 1 , 2 , 3 ], ( 3 , 4 , 5 ), { 5 , 6 , 7 }, { 7 : 'a' , 8 : 'b' }) {1, 2, 3, 4, 5, 6, 7, 8, 9}","title":"Set Operations"},{"location":"DS/pySet/#union","text":"# Python3 program for union() function set1 = { 2 , 4 , 5 , 6 } set2 = { 4 , 6 , 7 , 8 } set3 = { 7 , 8 , 9 , 10 } # union of two sets print ( \"set1 U set2 : \" , set1 . union ( set2 )) # union of three sets print ( \"set1 U set2 U set3 :\" , set1 . union ( set2 , set3 )) set1 U set2 : {2, 4, 5, 6, 7, 8} set1 U set2 U set3 : {2, 4, 5, 6, 7, 8, 9, 10}","title":"Union"},{"location":"DS/pySet/#intersection","text":"# Python3 program for intersection() function set1 = { 2 , 4 , 5 , 6 } set2 = { 4 , 6 , 7 , 8 } set3 = { 4 , 6 , 8 } # union of two sets print ( \"set1 intersection set2 : \" , set1 . intersection ( set2 )) # union of three sets print ( \"set1 intersection set2 intersection set3 :\" , set1 . intersection ( set2 , set3 )) set1 intersection set2 : {4, 6} set1 intersection set2 intersection set3 : {4, 6} # Python3 program for intersection() function set1 = { 2 , 4 , 5 , 6 } set2 = { 4 , 6 , 7 , 8 } set3 = { 1 , 0 , 12 } print ( set1 & set2 ) print ( set1 & set3 ) print ( set1 & set2 & set3 ) {4, 6} set() set()","title":"Intersection"},{"location":"DS/pySet/#difference","text":"# Python code to get the difference between two sets # using difference() between set A and set B # Driver Code A = { 10 , 20 , 30 , 40 , 80 } B = { 100 , 30 , 80 , 40 , 60 } print ( A . difference ( B )) print ( B . difference ( A )) {10, 20} {100, 60}","title":"Difference"},{"location":"DS/pyStack/","text":"A stack is a simple data structure that adds and removes elements in a particular order. Every time an element is added, it goes on the \"top\" of the stack. Only an element at the top of the stack can be removed, just like a stack of plates. This behavior is called LIFO (Last In, First Out). Terminology Adding a new element onto the stack is called push. Removing an element from the stack is called pop. Applications Stacks can be used to create undo-redo functionalities, parsing expressions (infix to postfix/prefix conversion), and much more. There are various ways from which a stack can be implemented in Python. This article covers the implementation of a stack using data structures and modules from the Python library. Stack in Python can be implemented using the following ways: list Collections.deque queue.LifoQueue singly linked list using List Python\u2019s built-in data structure list can be used as a stack. Instead of push(), append() is used to add elements to the top of the stack while pop() removes the element in LIFO order. Unfortunately, the list has a few shortcomings. The biggest issue is that it can run into speed issues as it grows. The items in the list are stored next to each other in memory, if the stack grows bigger than the block of memory that currently holds it, then Python needs to do some memory allocations. This can lead to some append() calls taking much longer than other ones. # Python program to # demonstrate stack implementation # using list stack = [] # append() function to push # element in the stack stack . append ( 'a' ) stack . append ( 'b' ) stack . append ( 'c' ) print ( 'Initial stack' ) print ( stack ) # pop() function to pop # element from stack in # LIFO order print ( ' \\n Elements popped from stack:' ) print ( stack . pop ()) print ( stack . pop ()) print ( stack . pop ()) print ( ' \\n Stack after elements are popped:' ) print ( stack ) # uncommenting print(stack.pop()) # will cause an IndexError # as the stack is now empty Initial stack ['a', 'b', 'c'] Elements popped from stack: c b a Stack after elements are popped: [] using deque Python stack can be implemented using the deque class from the collections module. Deque is preferred over the list in the cases where we need quicker append and pop operations from both the ends of the container, as deque provides an O(1) time complexity for append and pop operations as compared to list which provides O(n) time complexity. The same methods on deque as seen in the list are used, append() and pop(). # Python program to # demonstrate stack implementation # using collections.deque from collections import deque stack = deque () # append() function to push # element in the stack stack . append ( 'a' ) stack . append ( 'b' ) stack . append ( 'c' ) print ( 'Initial stack:' ) print ( stack ) # pop() function to pop # element from stack in # LIFO order print ( ' \\n Elements popped from stack:' ) print ( stack . pop ()) print ( stack . pop ()) print ( stack . pop ()) print ( ' \\n Stack after elements are popped:' ) print ( stack ) # uncommenting print(stack.pop()) # will cause an IndexError # as the stack is now empty Initial stack: deque(['a', 'b', 'c']) Elements popped from stack: c b a Stack after elements are popped: deque([]) using queue module Queue module also has a LIFO Queue, which is basically a Stack. Data is inserted into Queue using the put() function and get() takes data out from the Queue. There are various functions available in this module: maxsize \u2013 Number of items allowed in the queue. empty() \u2013 Return True if the queue is empty, False otherwise. full() \u2013 Return True if there are maxsize items in the queue. If the queue was initialized with maxsize=0 (the default), then full() never returns True. get() \u2013 Remove and return an item from the queue. If the queue is empty, wait until an item is available. get_nowait() \u2013 Return an item if one is immediately available, else raise QueueEmpty. put(item) \u2013 Put an item into the queue. If the queue is full, wait until a free slot is available before adding the item. put_nowait(item) \u2013 Put an item into the queue without blocking. qsize() \u2013 Return the number of items in the queue. If no free slot is immediately available, raise QueueFull. # Python program to # demonstrate stack implementation # using queue module from queue import LifoQueue # Initializing a stack stack = LifoQueue ( maxsize = 3 ) # qsize() show the number of elements # in the stack print ( stack . qsize ()) # put() function to push # element in the stack stack . put ( 'a' ) stack . put ( 'b' ) stack . put ( 'c' ) print ( \"Full: \" , stack . full ()) print ( \"Size: \" , stack . qsize ()) # get() function to pop # element from stack in # LIFO order print ( ' \\n Elements popped from the stack' ) print ( stack . get ()) print ( stack . get ()) print ( stack . get ()) print ( \" \\n Empty: \" , stack . empty ()) 0 Full: True Size: 3 Elements popped from the stack c b a Empty: True using singly linked list The linked list has two methods addHead(item) and removeHead() that run in constant time. These two methods are suitable to implement a stack. getSize()\u2013 Get the number of items in the stack. isEmpty() \u2013 Return True if the stack is empty, False otherwise. peek() \u2013 Return the top item in the stack. If the stack is empty, raise an exception. push(value) \u2013 Push a value into the head of the stack. pop() \u2013 Remove and return a value in the head of the stack. If the stack is empty, raise an exception. # Python program to demonstrate # stack implementation using a linked list. # node class class Node : def __init__ ( self , value ): self . value = value self . next = None class Stack : # Initializing a stack. # Use a dummy node, which is # easier for handling edge cases. def __init__ ( self ): self . head = Node ( \"head\" ) self . size = 0 # String representation of the stack def __str__ ( self ): cur = self . head . next out = \"\" while cur : out += str ( cur . value ) + \"->\" cur = cur . next return out [: - 3 ] # Get the current size of the stack def getSize ( self ): return self . size # Check if the stack is empty def isEmpty ( self ): return self . size == 0 # Get the top item of the stack def peek ( self ): # Sanitary check to see if we # are peeking an empty stack. if self . isEmpty (): raise Exception ( \"Peeking from an empty stack\" ) return self . head . next . value # Push a value into the stack. def push ( self , value ): node = Node ( value ) node . next = self . head . next self . head . next = node self . size += 1 # Remove a value from the stack and return. def pop ( self ): if self . isEmpty (): raise Exception ( \"Popping from an empty stack\" ) remove = self . head . next self . head . next = self . head . next . next self . size -= 1 return remove . value # Driver Code if __name__ == \"__main__\" : stack = Stack () for i in range ( 1 , 11 ): stack . push ( i ) print ( f \"Stack: { stack } \" ) for _ in range ( 1 , 6 ): remove = stack . pop () print ( f \"Pop: { remove } \" ) print ( f \"Stack: { stack } \" ) Stack: 10->9->8->7->6->5->4->3->2-> Pop: 10 Pop: 9 Pop: 8 Pop: 7 Pop: 6 Stack: 5->4->3->2->","title":"Stacks"},{"location":"DS/pyStack/#using-list","text":"Python\u2019s built-in data structure list can be used as a stack. Instead of push(), append() is used to add elements to the top of the stack while pop() removes the element in LIFO order. Unfortunately, the list has a few shortcomings. The biggest issue is that it can run into speed issues as it grows. The items in the list are stored next to each other in memory, if the stack grows bigger than the block of memory that currently holds it, then Python needs to do some memory allocations. This can lead to some append() calls taking much longer than other ones. # Python program to # demonstrate stack implementation # using list stack = [] # append() function to push # element in the stack stack . append ( 'a' ) stack . append ( 'b' ) stack . append ( 'c' ) print ( 'Initial stack' ) print ( stack ) # pop() function to pop # element from stack in # LIFO order print ( ' \\n Elements popped from stack:' ) print ( stack . pop ()) print ( stack . pop ()) print ( stack . pop ()) print ( ' \\n Stack after elements are popped:' ) print ( stack ) # uncommenting print(stack.pop()) # will cause an IndexError # as the stack is now empty Initial stack ['a', 'b', 'c'] Elements popped from stack: c b a Stack after elements are popped: []","title":"using List"},{"location":"DS/pyStack/#using-deque","text":"Python stack can be implemented using the deque class from the collections module. Deque is preferred over the list in the cases where we need quicker append and pop operations from both the ends of the container, as deque provides an O(1) time complexity for append and pop operations as compared to list which provides O(n) time complexity. The same methods on deque as seen in the list are used, append() and pop(). # Python program to # demonstrate stack implementation # using collections.deque from collections import deque stack = deque () # append() function to push # element in the stack stack . append ( 'a' ) stack . append ( 'b' ) stack . append ( 'c' ) print ( 'Initial stack:' ) print ( stack ) # pop() function to pop # element from stack in # LIFO order print ( ' \\n Elements popped from stack:' ) print ( stack . pop ()) print ( stack . pop ()) print ( stack . pop ()) print ( ' \\n Stack after elements are popped:' ) print ( stack ) # uncommenting print(stack.pop()) # will cause an IndexError # as the stack is now empty Initial stack: deque(['a', 'b', 'c']) Elements popped from stack: c b a Stack after elements are popped: deque([])","title":"using deque"},{"location":"DS/pyStack/#using-queue-module","text":"Queue module also has a LIFO Queue, which is basically a Stack. Data is inserted into Queue using the put() function and get() takes data out from the Queue. There are various functions available in this module: maxsize \u2013 Number of items allowed in the queue. empty() \u2013 Return True if the queue is empty, False otherwise. full() \u2013 Return True if there are maxsize items in the queue. If the queue was initialized with maxsize=0 (the default), then full() never returns True. get() \u2013 Remove and return an item from the queue. If the queue is empty, wait until an item is available. get_nowait() \u2013 Return an item if one is immediately available, else raise QueueEmpty. put(item) \u2013 Put an item into the queue. If the queue is full, wait until a free slot is available before adding the item. put_nowait(item) \u2013 Put an item into the queue without blocking. qsize() \u2013 Return the number of items in the queue. If no free slot is immediately available, raise QueueFull. # Python program to # demonstrate stack implementation # using queue module from queue import LifoQueue # Initializing a stack stack = LifoQueue ( maxsize = 3 ) # qsize() show the number of elements # in the stack print ( stack . qsize ()) # put() function to push # element in the stack stack . put ( 'a' ) stack . put ( 'b' ) stack . put ( 'c' ) print ( \"Full: \" , stack . full ()) print ( \"Size: \" , stack . qsize ()) # get() function to pop # element from stack in # LIFO order print ( ' \\n Elements popped from the stack' ) print ( stack . get ()) print ( stack . get ()) print ( stack . get ()) print ( \" \\n Empty: \" , stack . empty ()) 0 Full: True Size: 3 Elements popped from the stack c b a Empty: True","title":"using queue module"},{"location":"DS/pyStack/#using-singly-linked-list","text":"The linked list has two methods addHead(item) and removeHead() that run in constant time. These two methods are suitable to implement a stack. getSize()\u2013 Get the number of items in the stack. isEmpty() \u2013 Return True if the stack is empty, False otherwise. peek() \u2013 Return the top item in the stack. If the stack is empty, raise an exception. push(value) \u2013 Push a value into the head of the stack. pop() \u2013 Remove and return a value in the head of the stack. If the stack is empty, raise an exception. # Python program to demonstrate # stack implementation using a linked list. # node class class Node : def __init__ ( self , value ): self . value = value self . next = None class Stack : # Initializing a stack. # Use a dummy node, which is # easier for handling edge cases. def __init__ ( self ): self . head = Node ( \"head\" ) self . size = 0 # String representation of the stack def __str__ ( self ): cur = self . head . next out = \"\" while cur : out += str ( cur . value ) + \"->\" cur = cur . next return out [: - 3 ] # Get the current size of the stack def getSize ( self ): return self . size # Check if the stack is empty def isEmpty ( self ): return self . size == 0 # Get the top item of the stack def peek ( self ): # Sanitary check to see if we # are peeking an empty stack. if self . isEmpty (): raise Exception ( \"Peeking from an empty stack\" ) return self . head . next . value # Push a value into the stack. def push ( self , value ): node = Node ( value ) node . next = self . head . next self . head . next = node self . size += 1 # Remove a value from the stack and return. def pop ( self ): if self . isEmpty (): raise Exception ( \"Popping from an empty stack\" ) remove = self . head . next self . head . next = self . head . next . next self . size -= 1 return remove . value # Driver Code if __name__ == \"__main__\" : stack = Stack () for i in range ( 1 , 11 ): stack . push ( i ) print ( f \"Stack: { stack } \" ) for _ in range ( 1 , 6 ): remove = stack . pop () print ( f \"Pop: { remove } \" ) print ( f \"Stack: { stack } \" ) Stack: 10->9->8->7->6->5->4->3->2-> Pop: 10 Pop: 9 Pop: 8 Pop: 7 Pop: 6 Stack: 5->4->3->2->","title":"using singly linked list"},{"location":"DS/pyTrees/","text":"Unlike Arrays, Linked Lists, Stack and Queues, which are linear data structures, trees are hierarchical data structures. Tree Vocabulary: Root The topmost node is called root of the tree. Children The elements that are directly under an element are called its children. Parent The element directly above something is called its parent. For example, \u2018a\u2019 is a child of \u2018f\u2019, and \u2018f\u2019 is the parent of \u2018a\u2019. Leaf Finally, elements with no children are called leaves. Main applications of trees include: Manipulate hierarchical data. Make information easy to search (see tree traversal). Manipulate sorted lists of data. As a workflow for compositing digital images for visual effects. Router algorithms Form of a multi-stage decision-making # Python program to introduce Binary Tree # A class that represents an individual node in a # Binary Tree class Node : def __init__ ( self , key ): self . left = None self . right = None self . val = key # create root root = Node ( 1 ) ''' following is the tree after above statement 1 / \\ None None''' root . left = Node ( 2 ); root . right = Node ( 3 ); ''' 2 and 3 become left and right children of 1 1 / \\ 2 3 / \\ / \\ None None None None''' root . left . left = Node ( 4 ); '''4 becomes left child of 2 1 / \\ 2 3 / \\ / \\ 4 None None None / \\ None None'''","title":"Trees"},{"location":"DS/pyTrie/","text":"Trie is a tree-like data structure made up of nodes. Nodes can be used to store data. Each node may have none, one or more children. When used to store a vocabulary, each node is used to store a character, and consequently each \"branch\" of the trie represents a unique word. The following figure shows a trie with five words (was, wax, what, word, work) stored in it. There are two major operations that can be performed on a trie, namely: Inserting a word into the Trie Searching for words using a prefix Inserting Words into the Trie In order to insert a new word into the trie, we need to first check whether any prefix of the word is already in the trie. Therefore, we will start traverse the trie from the root node, and follow the algorithm below: Set the current node to be the root node Set the current character as the first character of the input word Check if the current character is a child of the current node If yes, set the current node to be this child node, set the current character to the next character in the input word, and perform this step again If no, it means from this character onwards, we will need to create new nodes and insert them into the trie Below is an illustration of what will happen when we want to add the word won into the trie above. Following the steps in the algorithm mentioned above, we will arrive at the node o under w, at which point we discover that n is not a child of o, and therefore we create a new node for the character n, and insert it under o. Searching in the Trie A common application scenario of the trie data structure is to search for words with a certain prefix, just like the auto-complete or query suggestion function in a search bar. When given a prefix, we can traverse the trie to check if any word in the trie starts with that prefix. If the prefix is found in the trie, we can then use depth-first traversal to retrieve all the words with that prefix. For example, given the trie illustrated above, which contains the words was, wax, what, word, work and won, let's see what will happen if we want to search for words with the prefix wa: Starting from the root node, we are able to find the node w and a From the node a, we can go on to traverse the trie to retrieve all words starting with the prefix wa When we arrive at the node s, we check whether it is the end of a word (yes), and the word was was output Similarity, when we arrive at the node x, the word wax is output Implementation class TrieNode : \"\"\"A node in the trie structure\"\"\" def __init__ ( self , char ): # the character stored in this node self . char = char # whether this can be the end of a word self . is_end = False # a counter indicating how many times a word is inserted # (if this node's is_end is True) self . counter = 0 # a dictionary of child nodes # keys are characters, values are nodes self . children = {} In this implementation, we want to store also the number of times a word has been inserted into the trie. This allows us to support additional features, such as ranking the words by their popularity. class Trie ( object ): \"\"\"The trie object\"\"\" def __init__ ( self ): \"\"\" The trie has at least the root node. The root node does not store any character \"\"\" self . root = TrieNode ( \"\" ) def insert ( self , word ): \"\"\"Insert a word into the trie\"\"\" node = self . root # Loop through each character in the word # Check if there is no child containing the character, create a new child for the current node for char in word : if char in node . children : node = node . children [ char ] else : # If a character is not found, # create a new node in the trie new_node = TrieNode ( char ) node . children [ char ] = new_node node = new_node # Mark the end of a word node . is_end = True # Increment the counter to indicate that we see this word once more node . counter += 1 def dfs ( self , node , prefix ): \"\"\"Depth-first traversal of the trie Args: - node: the node to start with - prefix: the current prefix, for tracing a word while traversing the trie \"\"\" if node . is_end : self . output . append (( prefix + node . char , node . counter )) for child in node . children . values (): self . dfs ( child , prefix + node . char ) def query ( self , x ): \"\"\"Given an input (a prefix), retrieve all words stored in the trie with that prefix, sort the words by the number of times they have been inserted \"\"\" # Use a variable within the class to keep all possible outputs # As there can be more than one word with such prefix self . output = [] node = self . root # Check if the prefix is in the trie for char in x : if char in node . children : node = node . children [ char ] else : # cannot found the prefix, return empty list return [] # Traverse the trie to get all candidates self . dfs ( node , x [: - 1 ]) # Sort the results in reverse order and return return sorted ( self . output , key = lambda x : x [ 1 ], reverse = True ) Below is an example of how this Trie class can be used: t = Trie () t . insert ( \"was\" ) t . insert ( \"word\" ) t . insert ( \"war\" ) t . insert ( \"what\" ) t . insert ( \"where\" ) t . query ( \"wh\" ) [('what', 1), ('where', 1)] using DefaultDict _end = '_end_' def make_trie ( * words ): root = dict () for word in words : current_dict = root for letter in word : current_dict = current_dict . setdefault ( letter , {}) current_dict [ _end ] = _end return root make_trie ( 'foo' , 'bar' , 'baz' , 'barz' ) {'b': {'a': {'r': {'_end_': '_end_', 'z': {'_end_': '_end_'}}, 'z': {'_end_': '_end_'}}}, 'f': {'o': {'o': {'_end_': '_end_'}}}} setdefault() simply looks up a key in the dictionary (here, letter or _end). If the key is present, it returns the associated value; if not, it assigns a default value to that key and returns the value ({} or _end). (It's like a version of get that also updates the dictionary.) def in_trie ( trie , word ): current_dict = trie for letter in word : if letter not in current_dict : return False current_dict = current_dict [ letter ] return _end in current_dict in_trie ( make_trie ( 'foo' , 'bar' , 'baz' , 'barz' ), 'baz' ) True in_trie ( make_trie ( 'foo' , 'bar' , 'baz' , 'barz' ), 'barzz' ) False","title":"Trie"},{"location":"DS/pyTrie/#inserting-words-into-the-trie","text":"In order to insert a new word into the trie, we need to first check whether any prefix of the word is already in the trie. Therefore, we will start traverse the trie from the root node, and follow the algorithm below: Set the current node to be the root node Set the current character as the first character of the input word Check if the current character is a child of the current node If yes, set the current node to be this child node, set the current character to the next character in the input word, and perform this step again If no, it means from this character onwards, we will need to create new nodes and insert them into the trie Below is an illustration of what will happen when we want to add the word won into the trie above. Following the steps in the algorithm mentioned above, we will arrive at the node o under w, at which point we discover that n is not a child of o, and therefore we create a new node for the character n, and insert it under o.","title":"Inserting Words into the Trie"},{"location":"DS/pyTrie/#searching-in-the-trie","text":"A common application scenario of the trie data structure is to search for words with a certain prefix, just like the auto-complete or query suggestion function in a search bar. When given a prefix, we can traverse the trie to check if any word in the trie starts with that prefix. If the prefix is found in the trie, we can then use depth-first traversal to retrieve all the words with that prefix. For example, given the trie illustrated above, which contains the words was, wax, what, word, work and won, let's see what will happen if we want to search for words with the prefix wa: Starting from the root node, we are able to find the node w and a From the node a, we can go on to traverse the trie to retrieve all words starting with the prefix wa When we arrive at the node s, we check whether it is the end of a word (yes), and the word was was output Similarity, when we arrive at the node x, the word wax is output","title":"Searching in the Trie"},{"location":"DS/pyTrie/#implementation","text":"class TrieNode : \"\"\"A node in the trie structure\"\"\" def __init__ ( self , char ): # the character stored in this node self . char = char # whether this can be the end of a word self . is_end = False # a counter indicating how many times a word is inserted # (if this node's is_end is True) self . counter = 0 # a dictionary of child nodes # keys are characters, values are nodes self . children = {} In this implementation, we want to store also the number of times a word has been inserted into the trie. This allows us to support additional features, such as ranking the words by their popularity. class Trie ( object ): \"\"\"The trie object\"\"\" def __init__ ( self ): \"\"\" The trie has at least the root node. The root node does not store any character \"\"\" self . root = TrieNode ( \"\" ) def insert ( self , word ): \"\"\"Insert a word into the trie\"\"\" node = self . root # Loop through each character in the word # Check if there is no child containing the character, create a new child for the current node for char in word : if char in node . children : node = node . children [ char ] else : # If a character is not found, # create a new node in the trie new_node = TrieNode ( char ) node . children [ char ] = new_node node = new_node # Mark the end of a word node . is_end = True # Increment the counter to indicate that we see this word once more node . counter += 1 def dfs ( self , node , prefix ): \"\"\"Depth-first traversal of the trie Args: - node: the node to start with - prefix: the current prefix, for tracing a word while traversing the trie \"\"\" if node . is_end : self . output . append (( prefix + node . char , node . counter )) for child in node . children . values (): self . dfs ( child , prefix + node . char ) def query ( self , x ): \"\"\"Given an input (a prefix), retrieve all words stored in the trie with that prefix, sort the words by the number of times they have been inserted \"\"\" # Use a variable within the class to keep all possible outputs # As there can be more than one word with such prefix self . output = [] node = self . root # Check if the prefix is in the trie for char in x : if char in node . children : node = node . children [ char ] else : # cannot found the prefix, return empty list return [] # Traverse the trie to get all candidates self . dfs ( node , x [: - 1 ]) # Sort the results in reverse order and return return sorted ( self . output , key = lambda x : x [ 1 ], reverse = True ) Below is an example of how this Trie class can be used: t = Trie () t . insert ( \"was\" ) t . insert ( \"word\" ) t . insert ( \"war\" ) t . insert ( \"what\" ) t . insert ( \"where\" ) t . query ( \"wh\" ) [('what', 1), ('where', 1)]","title":"Implementation"},{"location":"DS/pyTrie/#using-defaultdict","text":"_end = '_end_' def make_trie ( * words ): root = dict () for word in words : current_dict = root for letter in word : current_dict = current_dict . setdefault ( letter , {}) current_dict [ _end ] = _end return root make_trie ( 'foo' , 'bar' , 'baz' , 'barz' ) {'b': {'a': {'r': {'_end_': '_end_', 'z': {'_end_': '_end_'}}, 'z': {'_end_': '_end_'}}}, 'f': {'o': {'o': {'_end_': '_end_'}}}} setdefault() simply looks up a key in the dictionary (here, letter or _end). If the key is present, it returns the associated value; if not, it assigns a default value to that key and returns the value ({} or _end). (It's like a version of get that also updates the dictionary.) def in_trie ( trie , word ): current_dict = trie for letter in word : if letter not in current_dict : return False current_dict = current_dict [ letter ] return _end in current_dict in_trie ( make_trie ( 'foo' , 'bar' , 'baz' , 'barz' ), 'baz' ) True in_trie ( make_trie ( 'foo' , 'bar' , 'baz' , 'barz' ), 'barzz' ) False","title":"using DefaultDict"},{"location":"DS/pyTuple/","text":"A tuple is a Python collection that is extremely similar to a list, with some subtle differences. For starters, tuples are indicated using parentheses instead of square brackets. Like lists and dictionaries, tuples can be nested within each other. x = 1 y = 2 coordinates = ( x , y ) The variable coordinates above is a tuple containing the variables x and y. This example was chosen to also demonstrate a difference between the typical usage of tuples versus lists. Whereas lists are frequently used to contain objects whose values are similar in some sense, tuples are frequently used to contain attributes of a coherent unit. For instance, as above, it makes sense to treat the coordinates of a point as a single unit. As another example, consider the following tuple and list concerning dates: year1 = 2011 month1 = \"May\" day1 = 18 date1 = ( month1 , day1 , year1 ) year2 = 2017 month2 = \"June\" day2 = 13 date2 = ( month2 , day2 , year2 ) years_list = [ year1 , year2 ] Notice above that we have collected the attributes of a single date into one tuple: those pieces of information all describe a single \"unit\". By contrast, in the years list we have collected the different years. In the code-snippet: the values in the list have a commonality (they are both years), but they do not describe the same unit. The distinction drawn between tuples and lists is one that many Python programmers recognize in practice, but not one that is strictly enforced (i.e., you won't get any errors if you break this convention!). Another subtle way in which tuples and lists differ involves what is called mutability of Python variables. Mutability refers to the fact that a mutable object can be changed after it is created, and an immutable object can\u2019t. Tuples are not mutable, lists are mutable. Tuples are very similar to lists, except that they are immutable (they cannot be changed). Trying to reassign a value in a tuple causes a TypeError. Objects of built-in types like (int, float, bool, str, tuple, frozenset, unicode) are immutable. Objects of built-in types like (list, set, dict, byte array) are mutable. Custom classes are generally mutable. To simulate immutability in a class, one should override attribute setting and deletion to raise exceptions. To read further. words = ( \"spam\" , \"eggs\" , \"sausages\" ,) print ( words [ 0 ]) words [ 1 ] = \"cheese\" spam --------------------------------------------------------------------------- TypeError Traceback (most recent call last) <ipython-input-85-a8af92c7d33f> in <module>() 1 words = (\"spam\", \"eggs\", \"sausages\",) 2 print(words[0]) ----> 3 words[1]=\"cheese\" TypeError: 'tuple' object does not support item assignment Tuples can be created without the parentheses, by just separating the values with commas. An empty tuple is created using an empty parenthesis pair. Tuples are faster than lists, but they cannot be changed. Slicing can also be done on tuples. my_tp = () tp = \"one\" , \"two\" , \"three\" print ( tp [ 0 ]) print ( len ( my_tp )) print ( tp [ 1 :]) one 0 ('two', 'three') Tuple unpacking Tuple unpacking allows you to assign each item in an iterable (often a tuple) to a variable. This can be also used to swap variables by doing a, b = b, a , since b, a on the right hand side forms the tuple (b, a) which is then unpacked. A variable that is prefaced with an asterisk (*) takes all values from the iterable that are left over from the other variables. numbers = ( 1 , 2 , 3 ) a , b , c = numbers #unpacking print ( a ) print ( b ) print ( c ) 1 2 3 a , b , * c , d = ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ) print ( a ) print ( b ) print ( c ) print ( d ) 1 2 [3, 4, 5, 6, 7, 8] 9","title":"Tuple"},{"location":"DS/pyTuple/#tuple-unpacking","text":"Tuple unpacking allows you to assign each item in an iterable (often a tuple) to a variable. This can be also used to swap variables by doing a, b = b, a , since b, a on the right hand side forms the tuple (b, a) which is then unpacked. A variable that is prefaced with an asterisk (*) takes all values from the iterable that are left over from the other variables. numbers = ( 1 , 2 , 3 ) a , b , c = numbers #unpacking print ( a ) print ( b ) print ( c ) 1 2 3 a , b , * c , d = ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ) print ( a ) print ( b ) print ( c ) print ( d ) 1 2 [3, 4, 5, 6, 7, 8] 9","title":"Tuple unpacking"},{"location":"DS/pyUserDefGen/","text":"Linear data structures Lists Stacks Queue and Deque LinkedLists Non-linear data structures Mapping data structures Set Counter Hashtables and Hashmaps Tree data structures Trees (BST) Priority Queue Trie Graph data structures Dictionary of dictionaries Adjacent matrix","title":"General"},{"location":"DS/pyUserDefGen/#linear-data-structures","text":"Lists Stacks Queue and Deque LinkedLists","title":"Linear data structures"},{"location":"DS/pyUserDefGen/#non-linear-data-structures","text":"","title":"Non-linear data structures"},{"location":"DS/pyUserDefGen/#mapping-data-structures","text":"Set Counter Hashtables and Hashmaps","title":"Mapping data structures"},{"location":"DS/pyUserDefGen/#tree-data-structures","text":"Trees (BST) Priority Queue Trie","title":"Tree data structures"},{"location":"DS/pyUserDefGen/#graph-data-structures","text":"Dictionary of dictionaries Adjacent matrix","title":"Graph data structures"},{"location":"DS/pydeque/","text":"The collection Module in Python provides different types of containers. A Container is an object that is used to store different objects and provide a way to access the contained objects and iterate over them. Some of the built-in containers are Tuple, List, Dictionary, etc. import collections Deque (Doubly Ended Queue) in Python is implemented using the module \u201ccollections\u201c. Deque is preferred over list in the cases where we need quicker append and pop operations from both the ends of container, as deque provides an O(1) time complexity for append and pop operations as compared to list which provides O(n) time complexity. With Python lists, we can add and remove elements from the end of the list in constant time, but adding and removing from the beginning takes linear time. That\u2019s because Python lists are implemented using arrays that grow dynamically. With linked lists, we can add and remove elements from the beginning of the list in constant time, but adding and removing from the end takes linear time. With either of these implementations, it is easy to make a stack, that is, a collection where the first element we add is the last element we remove. A stack is also called a \u201cfirst-in, last-out\u201d queue, abbreviated FILO. But it is not easy to implement a \u201cfirst-in, first-out\u201d queue, that is, a collection where the first element we add is the first element we remove. Fortunately, there are ways to implement lists that can add and remove elements from both ends in constant time. A collection that has this property is called a double-ended queue, abbreviated \u201cdeque\u201d and pronounced like \u201cdeck\u201d. One way to implement a deque is a doubly-linked list, also known as a \u201chead-tail linked list\u201d. Each node in a doubly-linked list has a reference to the previous node in the list as well as the next element, which I will call left and right. Constructor dq = collections . deque ( range ( 10 )) dq deque([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) append() & popleft() for i in range ( 10 , 15 ): dq . append ( i ) v = dq . popleft () print ( \"Inserted :\" , i , \"- popped: \" , v , \"-result:\" , dq ) Inserted : 10 - popped: 0 -result: deque([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) Inserted : 11 - popped: 1 -result: deque([2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) Inserted : 12 - popped: 2 -result: deque([3, 4, 5, 6, 7, 8, 9, 10, 11, 12]) Inserted : 13 - popped: 3 -result: deque([4, 5, 6, 7, 8, 9, 10, 11, 12, 13]) Inserted : 14 - popped: 4 -result: deque([5, 6, 7, 8, 9, 10, 11, 12, 13, 14]) appendleft() & pop() for i in reversed ( range ( 0 , 5 )): dq . appendleft ( i ) v = dq . pop () print ( \"Inserted :\" , i , \"- popped: \" , v , \"-result:\" , dq ) Inserted : 4 - popped: 14 -result: deque([4, 5, 6, 7, 8, 9, 10, 11, 12, 13]) Inserted : 3 - popped: 13 -result: deque([3, 4, 5, 6, 7, 8, 9, 10, 11, 12]) Inserted : 2 - popped: 12 -result: deque([2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) Inserted : 1 - popped: 11 -result: deque([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) Inserted : 0 - popped: 10 -result: deque([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) index(ele, beg, end) This function returns the first index of the value mentioned in arguments, starting searching from beg till end index. insert(i, a) This function inserts the value mentioned in arguments(a) at index(i) specified in arguments. remove() This function removes the first occurrence of value mentioned in arguments. count() This function counts the number of occurrences of value mentioned in arguments. # Python code to demonstrate working of # insert(), index(), remove(), count() # importing \"collections\" for deque operations import collections # initializing deque de = collections . deque ([ 1 , 2 , 3 , 3 , 4 , 2 , 4 ]) # using index() to print the first occurrence of 4 print ( \"The number 4 first occurs at a position : \" ) print ( de . index ( 4 , 2 , 5 )) # using insert() to insert the value 3 at 5th position de . insert ( 4 , 3 ) # printing modified deque print ( \"The deque after inserting 3 at 5th position is : \" ) print ( de ) # using count() to count the occurrences of 3 print ( \"The count of 3 in deque is : \" ) print ( de . count ( 3 )) # using remove() to remove the first occurrence of 3 de . remove ( 3 ) # printing modified deque print ( \"The deque after deleting first occurrence of 3 is : \" ) print ( de ) The number 4 first occurs at a position : 4 The deque after inserting 3 at 5th position is : deque([1, 2, 3, 3, 3, 4, 2, 4]) The count of 3 in deque is : 3 The deque after deleting first occurrence of 3 is : deque([1, 2, 3, 3, 4, 2, 4]) extend(iterable) This function is used to add multiple values at the right end of deque. The argument passed is an iterable. extendleft(iterable) This function is used to add multiple values at the left end of deque. The argument passed is an iterable. Order is reversed as a result of left appends. reverse() This function is used to reverse order of deque elements. rotate() This function rotates the deque by the number specified in arguments. If the number specified is negative, rotation occurs to left. Else rotation is to right. # Python code to demonstrate working of # extend(), extendleft(), rotate(), reverse() # importing \"collections\" for deque operations import collections # initializing deque de = collections . deque ([ 1 , 2 , 3 ,]) # using extend() to add numbers to right end # adds 4,5,6 to right end de . extend ([ 4 , 5 , 6 ]) # printing modified deque print ( \"The deque after extending deque at end is : \" ) print ( de ) # using extendleft() to add numbers to left end # adds 7,8,9 to right end de . extendleft ([ 7 , 8 , 9 ]) # printing modified deque print ( \"The deque after extending deque at beginning is : \" ) print ( de ) # using rotate() to rotate the deque # rotates by 3 to left de . rotate ( - 3 ) # printing modified deque print ( \"The deque after rotating deque is : \" ) print ( de ) # using reverse() to reverse the deque de . reverse () # printing modified deque print ( \"The deque after reversing deque is : \" ) print ( de ) The deque after extending deque at end is : deque([1, 2, 3, 4, 5, 6]) The deque after extending deque at beginning is : deque([9, 8, 7, 1, 2, 3, 4, 5, 6]) The deque after rotating deque is : deque([1, 2, 3, 4, 5, 6, 9, 8, 7]) The deque after reversing deque is : deque([7, 8, 9, 6, 5, 4, 3, 2, 1])","title":"Deque"},{"location":"DS/pydeque/#constructor","text":"dq = collections . deque ( range ( 10 )) dq deque([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])","title":"Constructor"},{"location":"DS/pydeque/#append-popleft","text":"for i in range ( 10 , 15 ): dq . append ( i ) v = dq . popleft () print ( \"Inserted :\" , i , \"- popped: \" , v , \"-result:\" , dq ) Inserted : 10 - popped: 0 -result: deque([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) Inserted : 11 - popped: 1 -result: deque([2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) Inserted : 12 - popped: 2 -result: deque([3, 4, 5, 6, 7, 8, 9, 10, 11, 12]) Inserted : 13 - popped: 3 -result: deque([4, 5, 6, 7, 8, 9, 10, 11, 12, 13]) Inserted : 14 - popped: 4 -result: deque([5, 6, 7, 8, 9, 10, 11, 12, 13, 14])","title":"append() &amp; popleft()"},{"location":"DS/pydeque/#appendleft-pop","text":"for i in reversed ( range ( 0 , 5 )): dq . appendleft ( i ) v = dq . pop () print ( \"Inserted :\" , i , \"- popped: \" , v , \"-result:\" , dq ) Inserted : 4 - popped: 14 -result: deque([4, 5, 6, 7, 8, 9, 10, 11, 12, 13]) Inserted : 3 - popped: 13 -result: deque([3, 4, 5, 6, 7, 8, 9, 10, 11, 12]) Inserted : 2 - popped: 12 -result: deque([2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) Inserted : 1 - popped: 11 -result: deque([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) Inserted : 0 - popped: 10 -result: deque([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])","title":"appendleft() &amp; pop()"},{"location":"DS/pydeque/#indexele-beg-end","text":"This function returns the first index of the value mentioned in arguments, starting searching from beg till end index.","title":"index(ele, beg, end)"},{"location":"DS/pydeque/#inserti-a","text":"This function inserts the value mentioned in arguments(a) at index(i) specified in arguments.","title":"insert(i, a)"},{"location":"DS/pydeque/#remove","text":"This function removes the first occurrence of value mentioned in arguments.","title":"remove()"},{"location":"DS/pydeque/#count","text":"This function counts the number of occurrences of value mentioned in arguments. # Python code to demonstrate working of # insert(), index(), remove(), count() # importing \"collections\" for deque operations import collections # initializing deque de = collections . deque ([ 1 , 2 , 3 , 3 , 4 , 2 , 4 ]) # using index() to print the first occurrence of 4 print ( \"The number 4 first occurs at a position : \" ) print ( de . index ( 4 , 2 , 5 )) # using insert() to insert the value 3 at 5th position de . insert ( 4 , 3 ) # printing modified deque print ( \"The deque after inserting 3 at 5th position is : \" ) print ( de ) # using count() to count the occurrences of 3 print ( \"The count of 3 in deque is : \" ) print ( de . count ( 3 )) # using remove() to remove the first occurrence of 3 de . remove ( 3 ) # printing modified deque print ( \"The deque after deleting first occurrence of 3 is : \" ) print ( de ) The number 4 first occurs at a position : 4 The deque after inserting 3 at 5th position is : deque([1, 2, 3, 3, 3, 4, 2, 4]) The count of 3 in deque is : 3 The deque after deleting first occurrence of 3 is : deque([1, 2, 3, 3, 4, 2, 4])","title":"count()"},{"location":"DS/pydeque/#extenditerable","text":"This function is used to add multiple values at the right end of deque. The argument passed is an iterable.","title":"extend(iterable)"},{"location":"DS/pydeque/#extendleftiterable","text":"This function is used to add multiple values at the left end of deque. The argument passed is an iterable. Order is reversed as a result of left appends.","title":"extendleft(iterable)"},{"location":"DS/pydeque/#reverse","text":"This function is used to reverse order of deque elements.","title":"reverse()"},{"location":"DS/pydeque/#rotate","text":"This function rotates the deque by the number specified in arguments. If the number specified is negative, rotation occurs to left. Else rotation is to right. # Python code to demonstrate working of # extend(), extendleft(), rotate(), reverse() # importing \"collections\" for deque operations import collections # initializing deque de = collections . deque ([ 1 , 2 , 3 ,]) # using extend() to add numbers to right end # adds 4,5,6 to right end de . extend ([ 4 , 5 , 6 ]) # printing modified deque print ( \"The deque after extending deque at end is : \" ) print ( de ) # using extendleft() to add numbers to left end # adds 7,8,9 to right end de . extendleft ([ 7 , 8 , 9 ]) # printing modified deque print ( \"The deque after extending deque at beginning is : \" ) print ( de ) # using rotate() to rotate the deque # rotates by 3 to left de . rotate ( - 3 ) # printing modified deque print ( \"The deque after rotating deque is : \" ) print ( de ) # using reverse() to reverse the deque de . reverse () # printing modified deque print ( \"The deque after reversing deque is : \" ) print ( de ) The deque after extending deque at end is : deque([1, 2, 3, 4, 5, 6]) The deque after extending deque at beginning is : deque([9, 8, 7, 1, 2, 3, 4, 5, 6]) The deque after rotating deque is : deque([1, 2, 3, 4, 5, 6, 9, 8, 7]) The deque after reversing deque is : deque([7, 8, 9, 6, 5, 4, 3, 2, 1])","title":"rotate()"},{"location":"Func/pyAnn/","text":"PEP 3107 PEP stands for Python Enhancement Proposal. It is a design document that describes new features for Python or its processes or environment. It also provides information to the python community. PEP-3107 introduced the concept and syntax for adding arbitrary metadata annotations to Python. There's no preconceived use case, but the PEP suggests several. One very handy one is to allow you to annotate parameters with their expected types; it would then be easy to write a decorator that verifies the annotations or coerces the arguments to the right type. Another is to allow parameter-specific documentation instead of encoding it into the docstring. Function annotations are only supported in python 3x. Details here the -> marks the return function annotation. def kinetic_energy ( m : 'in KG' , v : 'in M/S' ) -> 'Joules' : return 1 / 2 * m * v ** 2 kinetic_energy . __annotations__ {'m': 'in KG', 'return': 'Joules', 'v': 'in M/S'} Annotations are dictionaries, so you can do this: ' {:,} {} ' . format ( kinetic_energy ( 12 , 30 ), kinetic_energy . __annotations__ [ 'return' ]) 5,400.0 Joules You can also have a python data structure rather than just a string: rd = { 'type' : float , 'units' : 'Joules' , 'docstring' : 'Given mass and velocity returns kinetic energy in Joules' } def f () -> rd : pass f . __annotations__ [ 'return' ][ 'type' ] float f . __annotations__ [ 'return' ][ 'units' ] Joules f . __annotations__ [ 'return' ][ 'docstring' ] Given mass and velocity returns kinetic energy in Joules Or, you can use function attributes to validate called values: def validate ( func , locals ): for var , test in func . __annotations__ . items (): value = locals [ var ] try : pr = test . __name__ + ': ' + test . __docstring__ except AttributeError : pr = test . __name__ msg = ' {} == {} ; Test: {} ' . format ( var , value , pr ) assert test ( value ), msg def between ( lo , hi ): def _between ( x ): return lo <= x <= hi _between . __docstring__ = 'must be between {} and {} ' . format ( lo , hi ) return _between def f ( x : between ( 3 , 10 ), y : lambda _y : isinstance ( _y , int )): validate ( f , locals ()) print ( x , y ) f ( 2 , 2 ) --------------------------------------------------------------------------- AssertionError Traceback (most recent call last) <ipython-input-8-e43489394a12> in <module>() ----> 1 f(2,2) 1 frames <ipython-input-7-b73806aca747> in validate(func, locals) 7 pr=test.__name__ 8 msg = '{}=={}; Test: {}'.format(var, value, pr) ----> 9 assert test(value), msg 10 11 def between(lo, hi): AssertionError: x==2; Test: _between: must be between 3 and 10 f ( 3 , 2.1 ) --------------------------------------------------------------------------- AssertionError Traceback (most recent call last) <ipython-input-9-d705e73c1fc6> in <module>() ----> 1 f(3,2.1) 1 frames <ipython-input-7-b73806aca747> in validate(func, locals) 7 pr=test.__name__ 8 msg = '{}=={}; Test: {}'.format(var, value, pr) ----> 9 assert test(value), msg 10 11 def between(lo, hi): AssertionError: y==2.1; Test: <lambda> f ( 3 , 4 ) 3 4","title":"Annotations"},{"location":"Func/pyCtxtMgr/","text":"The with Keyword Context managers are a really helpful structure in Python. Each context manager executes specific code before and after the statements you specify. To use one, you use the with keyword: with <context manager> as <var>: <statements> Using with gives you a way to define code to be executed within the context manager\u2019s scope. The most basic example of this is when you\u2019re working with file I/O in Python. If you wanted to open a file, do something with that file, and then make sure that the file was closed correctly, then you would use a context manager. Consider this example in which names.txt contains a list of names, one per line: with open ( \"names.txt\" ) as input_file : for name in input_file : print ( name . strip ()) The file I/O context manager provided by open() and initiated with the with keyword opens the file for reading, assigns the open file pointer to input_file, then executes whatever code you specify in the with block. Then, after the block is executed, the file pointer closes. Even if your code in the with block raises an exception, the file pointer would still close. The as Keyword If you want access to the results of the expression or context manager passed to with, you\u2019ll need to alias it using as. You may have also seen as used to alias imports and exceptions, and this is no different. The alias is available in the with block: with <expr> as <alias>: <statements> Most of the time, you\u2019ll see these two Python keywords, with and as, used together.","title":"Context Managers"},{"location":"Func/pyCtxtMgr/#the-with-keyword","text":"Context managers are a really helpful structure in Python. Each context manager executes specific code before and after the statements you specify. To use one, you use the with keyword: with <context manager> as <var>: <statements> Using with gives you a way to define code to be executed within the context manager\u2019s scope. The most basic example of this is when you\u2019re working with file I/O in Python. If you wanted to open a file, do something with that file, and then make sure that the file was closed correctly, then you would use a context manager. Consider this example in which names.txt contains a list of names, one per line: with open ( \"names.txt\" ) as input_file : for name in input_file : print ( name . strip ()) The file I/O context manager provided by open() and initiated with the with keyword opens the file for reading, assigns the open file pointer to input_file, then executes whatever code you specify in the with block. Then, after the block is executed, the file pointer closes. Even if your code in the with block raises an exception, the file pointer would still close.","title":"The with Keyword"},{"location":"Func/pyCtxtMgr/#the-as-keyword","text":"If you want access to the results of the expression or context manager passed to with, you\u2019ll need to alias it using as. You may have also seen as used to alias imports and exceptions, and this is no different. The alias is available in the with block: with <expr> as <alias>: <statements> Most of the time, you\u2019ll see these two Python keywords, with and as, used together.","title":"The as Keyword"},{"location":"Func/pyDecor/","text":"A Decorator is a callable that takes another function as an argument, extending the behavior of that function without explicitly modifying that function. Decorators provide a way to modify functions using other functions. This is ideal when you need to extend the functionality of functions that you don't want to modify. Functions within functions def fib_3 ( a , b , c ): def get_3 (): return a , b , c return get_3 fib_3 ( 1 , 1 , 2 ) <function __main__.fib_3.<locals>.get_3> f = fib_3 ( 1 , 1 , 2 ) f () (1, 1, 2) We defined a function named decor that has a single parameter func. Inside decor, we defined a nested function named wrap. The wrap function will print a string, then call func(), and print another string. The decor function returns the wrap function as its result. We could say that the variable decorated is a decorated version of print_text - it's print_text plus something. def decor ( func ): def wrap (): '''This is the wrapper''' #Do something before print ( \"***************\" ) func () #Do something after print ( \"***************\" ) return wrap def print_text (): '''Prints Hello''' print ( \"Hello\" ) decorated = decor ( print_text ) decorated () *************** Hello *************** print_text . __name__ print_text print_text . __doc__ Prints Hello Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name and the @ symbol. If we are defining a function we can \"decorate\" it with the @ symbol like. A single function can have multiple decorators. def print_text (): print ( \"Hello\" ) print_text = decor ( print_text ) print_text () *************** Hello *************** Is equivalent to: @decor def print_text (): '''Prints Hello''' print ( \"Hello\" ) print_text () *************** Hello *************** print_text . __name__ wrap print_text . __doc__ This is the wrapper To avoid this problem use functools from functools import wraps def decor ( func ): @wraps ( func ) def wrap (): '''This is the wrapper''' #Do something before print ( \"***************\" ) func () #Do something after print ( \"***************\" ) return wrap @decor def print_text (): '''Prints Hello''' print ( \"Hello\" ) print_text () *************** Hello *************** print_text . __name__ print_text print_text . __doc__ Prints Hello Decorators with arguments def pfib ( a , b , c ): print ( a , b , c ) pfib ( 1 , 1 , 2 ) 1 1 2 If I dont want only 3 args but more def pfib ( a , * args ): print ( a ) print ( args ) pfib ( 1 , 1 , 2 , 3 ) 1 (1, 2, 3) def pfib ( a , ** kwargs ): print ( a ) print ( kwargs ) pfib ( 1 , se = 1 , th = 2 , fo = 3 , fi = 5 ) 1 {'se': 1, 'th': 2, 'fo': 3, 'fi': 5} def pfib ( * args , ** kwargs ): print ( args ) print ( kwargs ) pfib ( 1 , 2 , 2 , se = 1 , th = 2 , fo = 3 , fi = 5 ) (1, 2, 2) {'se': 1, 'th': 2, 'fo': 3, 'fi': 5} def wrapper ( * args , ** kwargs ): print ( * args ) print ( 'Leaving wrapper' ) pfib ( * args , ** kwargs ) print ( kwargs ) wrapper ( 1 , 1 , th = 2 ) 1 1 Leaving wrapper (1, 1) {'th': 2} {'th': 2} The template is: from functools import wraps def decorator ( func ): @wraps ( func ) def wrapper ( * args , ** kwargs ): #Do something before result = func ( * args , ** kwargs ) #Do something after return result return wrapper @decorator def func (): pass Decorators with classes We can define a decorator as a class in order to do that, we have to use a call method of classes. # Python program showing # use of __call__() method class MyDecorator : def __init__ ( self , function ): self . function = function def __call__ ( self ): # We can add some code # before function call self . function () # We can also add some code # after function call. # adding class decorator to the function @MyDecorator def function (): print ( \"Meps3\" ) function () Meps3 # Python program showing # class decorator with *args # and **kwargs class MyDecorator : def __init__ ( self , function ): self . function = function def __call__ ( self , * args , ** kwargs ): # We can add some code # before function call self . function ( * args , ** kwargs ) # We can also add some code # after function call. # adding class decorator to the function @MyDecorator def function ( name , message = 'Hello' ): print ( \" {} , {} \" . format ( message , name )) function ( \"gpes3\" , \"hello\" ) hello, gpes3 # Python program to execute # time of a program # importing time module from time import time class Timer : def __init__ ( self , func ): self . function = func def __call__ ( self , * args , ** kwargs ): start_time = time () result = self . function ( * args , ** kwargs ) end_time = time () print ( \"Execution took {} seconds\" . format ( end_time - start_time )) return result # adding a decorator to the function @Timer def some_function ( delay ): from time import sleep # Introducing some time delay to # simulate a time taking function. sleep ( delay ) some_function ( 3 ) Execution took 3.003098487854004 seconds Decorators as a cache: Memoization LRU is the cache replacement algorithm that removes the least recently used data and stores the new data. Suppose we have a cache space of 10 memory frames. And each frame is filled with a file. Now if we want to store the new file, we need to remove the oldest file in the cache and add the new file. This is how LRU works. LRU cache consists of Queue and Dictionary data structures. Queue: to store the most recently used to least recently used files Hash table: to store the file and its position in the cache lru_cache() is one such function in functools module which helps in reducing the execution time of the function by using memoization technique. from functools import lru_cache import time # Function that computes Fibonacci # numbers without lru_cache def fib_without_cache ( n ): if n < 2 : return n return fib_without_cache ( n - 1 ) + fib_without_cache ( n - 2 ) # Execution start time begin = time . time () fib_without_cache ( 30 ) # Execution end time end = time . time () print ( \"Time taken to execute the \\ function without lru_cache is\" , end - begin ) # Function that computes Fibonacci # numbers with lru_cache @lru_cache ( maxsize = 128 ) def fib_with_cache ( n ): if n < 2 : return n return fib_with_cache ( n - 1 ) + fib_with_cache ( n - 2 ) begin = time . time () fib_with_cache ( 30 ) end = time . time () print ( \"Time taken to execute the \\ function with lru_cache is\" , end - begin ) Time taken to execute the function without lru_cache is 0.3661181926727295 Time taken to execute the function with lru_cache is 7.653236389160156e-05","title":"Decorators"},{"location":"Func/pyDecor/#functions-within-functions","text":"def fib_3 ( a , b , c ): def get_3 (): return a , b , c return get_3 fib_3 ( 1 , 1 , 2 ) <function __main__.fib_3.<locals>.get_3> f = fib_3 ( 1 , 1 , 2 ) f () (1, 1, 2) We defined a function named decor that has a single parameter func. Inside decor, we defined a nested function named wrap. The wrap function will print a string, then call func(), and print another string. The decor function returns the wrap function as its result. We could say that the variable decorated is a decorated version of print_text - it's print_text plus something. def decor ( func ): def wrap (): '''This is the wrapper''' #Do something before print ( \"***************\" ) func () #Do something after print ( \"***************\" ) return wrap def print_text (): '''Prints Hello''' print ( \"Hello\" ) decorated = decor ( print_text ) decorated () *************** Hello *************** print_text . __name__ print_text print_text . __doc__ Prints Hello Python provides support to wrap a function in a decorator by pre-pending the function definition with a decorator name and the @ symbol. If we are defining a function we can \"decorate\" it with the @ symbol like. A single function can have multiple decorators. def print_text (): print ( \"Hello\" ) print_text = decor ( print_text ) print_text () *************** Hello *************** Is equivalent to: @decor def print_text (): '''Prints Hello''' print ( \"Hello\" ) print_text () *************** Hello *************** print_text . __name__ wrap print_text . __doc__ This is the wrapper To avoid this problem use functools from functools import wraps def decor ( func ): @wraps ( func ) def wrap (): '''This is the wrapper''' #Do something before print ( \"***************\" ) func () #Do something after print ( \"***************\" ) return wrap @decor def print_text (): '''Prints Hello''' print ( \"Hello\" ) print_text () *************** Hello *************** print_text . __name__ print_text print_text . __doc__ Prints Hello","title":"Functions within functions"},{"location":"Func/pyDecor/#decorators-with-arguments","text":"def pfib ( a , b , c ): print ( a , b , c ) pfib ( 1 , 1 , 2 ) 1 1 2 If I dont want only 3 args but more def pfib ( a , * args ): print ( a ) print ( args ) pfib ( 1 , 1 , 2 , 3 ) 1 (1, 2, 3) def pfib ( a , ** kwargs ): print ( a ) print ( kwargs ) pfib ( 1 , se = 1 , th = 2 , fo = 3 , fi = 5 ) 1 {'se': 1, 'th': 2, 'fo': 3, 'fi': 5} def pfib ( * args , ** kwargs ): print ( args ) print ( kwargs ) pfib ( 1 , 2 , 2 , se = 1 , th = 2 , fo = 3 , fi = 5 ) (1, 2, 2) {'se': 1, 'th': 2, 'fo': 3, 'fi': 5} def wrapper ( * args , ** kwargs ): print ( * args ) print ( 'Leaving wrapper' ) pfib ( * args , ** kwargs ) print ( kwargs ) wrapper ( 1 , 1 , th = 2 ) 1 1 Leaving wrapper (1, 1) {'th': 2} {'th': 2} The template is: from functools import wraps def decorator ( func ): @wraps ( func ) def wrapper ( * args , ** kwargs ): #Do something before result = func ( * args , ** kwargs ) #Do something after return result return wrapper @decorator def func (): pass","title":"Decorators with arguments"},{"location":"Func/pyDecor/#decorators-with-classes","text":"We can define a decorator as a class in order to do that, we have to use a call method of classes. # Python program showing # use of __call__() method class MyDecorator : def __init__ ( self , function ): self . function = function def __call__ ( self ): # We can add some code # before function call self . function () # We can also add some code # after function call. # adding class decorator to the function @MyDecorator def function (): print ( \"Meps3\" ) function () Meps3 # Python program showing # class decorator with *args # and **kwargs class MyDecorator : def __init__ ( self , function ): self . function = function def __call__ ( self , * args , ** kwargs ): # We can add some code # before function call self . function ( * args , ** kwargs ) # We can also add some code # after function call. # adding class decorator to the function @MyDecorator def function ( name , message = 'Hello' ): print ( \" {} , {} \" . format ( message , name )) function ( \"gpes3\" , \"hello\" ) hello, gpes3 # Python program to execute # time of a program # importing time module from time import time class Timer : def __init__ ( self , func ): self . function = func def __call__ ( self , * args , ** kwargs ): start_time = time () result = self . function ( * args , ** kwargs ) end_time = time () print ( \"Execution took {} seconds\" . format ( end_time - start_time )) return result # adding a decorator to the function @Timer def some_function ( delay ): from time import sleep # Introducing some time delay to # simulate a time taking function. sleep ( delay ) some_function ( 3 ) Execution took 3.003098487854004 seconds","title":"Decorators with classes"},{"location":"Func/pyDecor/#decorators-as-a-cache-memoization","text":"LRU is the cache replacement algorithm that removes the least recently used data and stores the new data. Suppose we have a cache space of 10 memory frames. And each frame is filled with a file. Now if we want to store the new file, we need to remove the oldest file in the cache and add the new file. This is how LRU works. LRU cache consists of Queue and Dictionary data structures. Queue: to store the most recently used to least recently used files Hash table: to store the file and its position in the cache lru_cache() is one such function in functools module which helps in reducing the execution time of the function by using memoization technique. from functools import lru_cache import time # Function that computes Fibonacci # numbers without lru_cache def fib_without_cache ( n ): if n < 2 : return n return fib_without_cache ( n - 1 ) + fib_without_cache ( n - 2 ) # Execution start time begin = time . time () fib_without_cache ( 30 ) # Execution end time end = time . time () print ( \"Time taken to execute the \\ function without lru_cache is\" , end - begin ) # Function that computes Fibonacci # numbers with lru_cache @lru_cache ( maxsize = 128 ) def fib_with_cache ( n ): if n < 2 : return n return fib_with_cache ( n - 1 ) + fib_with_cache ( n - 2 ) begin = time . time () fib_with_cache ( 30 ) end = time . time () print ( \"Time taken to execute the \\ function with lru_cache is\" , end - begin ) Time taken to execute the function without lru_cache is 0.3661181926727295 Time taken to execute the function with lru_cache is 7.653236389160156e-05","title":"Decorators as a cache: Memoization"},{"location":"Func/pyDoc/","text":"Docstrings (documentation strings) serve a similar purpose to comments, as they are designed to explain code. However, they are more specific and have a different syntax. They are created by putting a multiline string containing an explanation of the function below the function's first line. Unlike conventional comments, docstrings are retained throughout the runtime of the program. This allows the programmer to inspect these comments at run time. def sumt ( x , y ): \"\"\" Multiplies by two the sum of parameters Parameters ---------- x : int First Number. y : int Second Number. Returns ------- z : int Result of the operation Examples -------- >>> sumt(2, 3) 12 \"\"\" return ( x + y ) * 2 The docstring is a triple-quoted string (which may span multiple lines) that comes immediately after the header of a function. When we call help() or .doc on a function, it shows the docstring. help ( sumt ) Help on function sumt in module __main__: sumt(x, y) Multiplies by two the sum of parameters Parameters ---------- x : int First Number. y : int Second Number. Returns ------- z : int Result of the operation Examples -------- >>> sumt(2, 3) 12 print ( sumt . __doc__ ) Multiplies by two the sum of parameters Parameters ---------- x : int First Number. y : int Second Number. Returns ------- z : int Result of the operation Examples -------- >>> sumt(2, 3) 12","title":"Documentation"},{"location":"Func/pyFnArgs/","text":"Python allows to have function with varying number of arguments. Using args as a function parameter enables you to pass an arbitrary number of arguments to that function. The arguments are then accessible as the tuple args in the body of the function. The parameter args must come after the named parameters to a function. The name args is just a convention; you can choose to use another. *args is called an argument list. def function ( named_args , * args ): print ( named_args ) print ( args ) function ( 1 , 2 , 3 , 4 , 5 , 6 , 7 ) 1 (2, 3, 4, 5, 6, 7) Default Values Named parameters to a function can be made optional by giving them a default value. These must come after named parameters without a default value. In case the argument is passed in, the default value is ignored. If the argument is not passed in, the default value is used. def function ( x , y , food = \"spam\" ): print ( food ) function ( 1 , 2 ) function ( 2 , 3 , \"eggs\" ) spam eggs Keyword Arguments kwargs (standing for keyword arguments) allows you to handle named arguments that you have not defined in advance. The keyword arguments return a **dictionary in which the keys are the argument names, and the values are the argument values. The arguments returned by * kwargs are not included in args def my_func ( x , y = 7 , * args , ** kwargs ): print ( kwargs ) my_func ( 2 , 3 , 4 , 5 , 6 , a = 7 , b = 8 ) #a and b are the names of the arguments that we passed to the function call. {'a': 7, 'b': 8} Keyword-only Arguments These are only specifiable via the name of the argument, and cannot be specified as a positional argument. For example, the following function takes a positional argument and two keyword-only arguments def keyword_only_function ( parameter , * , option1 = False , option2 = '' ): pass In this example, option1, and option2 are only specifiable via the keyword argument syntax. The following is valid keyword_only_function ( 3 , option1 = True , option2 = 'Hello World!' ) But this example will raise an error keyword_only_function ( 3 , True , 'Hello World!' ) Passing Arguments By Value and By Reference Manipulating provided arguments inside the function will leave immutable arguments intact, but will update mutable arguments. Lists are mutable, int is inmutable. Passing List as arguments is similar to passing by reference. Passing int is similar to passing by value. def Func ( a , b ): a = 1 b [ 0 ] = 1 x = 0 y = [ 0 ] Func ( x , y ) print ( x , y ) 0 [1]","title":"Arguments"},{"location":"Func/pyFnArgs/#default-values","text":"Named parameters to a function can be made optional by giving them a default value. These must come after named parameters without a default value. In case the argument is passed in, the default value is ignored. If the argument is not passed in, the default value is used. def function ( x , y , food = \"spam\" ): print ( food ) function ( 1 , 2 ) function ( 2 , 3 , \"eggs\" ) spam eggs","title":"Default Values"},{"location":"Func/pyFnArgs/#keyword-arguments","text":"kwargs (standing for keyword arguments) allows you to handle named arguments that you have not defined in advance. The keyword arguments return a **dictionary in which the keys are the argument names, and the values are the argument values. The arguments returned by * kwargs are not included in args def my_func ( x , y = 7 , * args , ** kwargs ): print ( kwargs ) my_func ( 2 , 3 , 4 , 5 , 6 , a = 7 , b = 8 ) #a and b are the names of the arguments that we passed to the function call. {'a': 7, 'b': 8}","title":"Keyword Arguments"},{"location":"Func/pyFnArgs/#keyword-only-arguments","text":"These are only specifiable via the name of the argument, and cannot be specified as a positional argument. For example, the following function takes a positional argument and two keyword-only arguments def keyword_only_function ( parameter , * , option1 = False , option2 = '' ): pass In this example, option1, and option2 are only specifiable via the keyword argument syntax. The following is valid keyword_only_function ( 3 , option1 = True , option2 = 'Hello World!' ) But this example will raise an error keyword_only_function ( 3 , True , 'Hello World!' )","title":"Keyword-only Arguments"},{"location":"Func/pyFnArgs/#passing-arguments-by-value-and-by-reference","text":"Manipulating provided arguments inside the function will leave immutable arguments intact, but will update mutable arguments. Lists are mutable, int is inmutable. Passing List as arguments is similar to passing by reference. Passing int is similar to passing by value. def Func ( a , b ): a = 1 b [ 0 ] = 1 x = 0 y = [ 0 ] Func ( x , y ) print ( x , y ) 0 [1]","title":"Passing Arguments By Value and By Reference"},{"location":"Func/pyFuncObj/","text":"Functions can also be used as arguments of other functions. def add ( x , y ): return x + y def twice ( func , x , y ): return func ( func ( x , y ), func ( x , y )) a = 2 b = 3 print ( twice ( add , a , b )) 10 Functions that operate on other functions are called \"higher-order functions.\" there are higher-order functions built into Python that you might find useful to call. Here's an interesting example using the max function. By default, max returns the largest of its arguments. But if we pass in a function using the optional key argument, it returns the argument x that maximizes key(x) (aka the 'argmax'). def mod_5 ( x ): \"\"\"Return the remainder of x after dividing by 5\"\"\" return x % 5 print ( 'Which number is biggest?' , max ( 100 , 51 , 14 ), 'Which number is the biggest modulo 5?' , max ( 100 , 51 , 14 , key = mod_5 ), sep = ' \\n ' , ) Which number is biggest? 100 Which number is the biggest modulo 5? 14","title":"Function As Objects"},{"location":"Func/pyGen/","text":"The help() function is possibly the most important Python function you can learn. If you can remember how to use help(), you hold the key to understanding most other functions. help ( round ) Help on built-in function round in module builtins: round(number, ndigits=None) Round a number to a given precision in decimal digits. The return value is an integer if ndigits is omitted or None. Otherwise the return value has the same type as the number. ndigits may be negative. You can create your own functions by using the def statement. The code block within every function starts with a colon (:) and is indented. You must define functions before they are called, in the same way that you must assign variables before using them. def my_func (): print ( \"spam \" ) print ( \"spam \" ) my_func () def excla ( word ): print ( \"Spam with \" + word + \"!\" ) excla ( \"eggs\" ) def sumtwice ( x , y ): return ( x + y ) * 2 print ( sumtwice ( 3 , 4 )) spam spam Spam with eggs! 14","title":"General"},{"location":"Func/pyLambdas/","text":"Creating a function normally (using def) assigns it to a variable automatically. This is different from the creation of other objects - such as strings and integers - which can be created on the fly, without assigning them to a variable. The same is possible with functions, provided that they are created using lambda syntax. Functions created this way are known as anonymous . This approach is most commonly used when passing a simple function as an argument to another function. The syntax is shown in the next example and consists of the lambda keyword followed by a list of arguments, a colon, and the expression to evaluate and return. def my_func ( f , arg ): return f ( arg ) my_func ( lambda x : 2 * x * x , 5 ) 50 Lambda functions aren't as powerful as named functions. They can only do things that require a single expression - usually equivalent to a single line of code. Lambda functions can be assigned to variables, and used like normal functions. #It is usually better to define a function with def instead. ec = lambda x : x * x * 2 + 4 * x + 3 print ( ec ( 8 )) 163","title":"Lambdas"},{"location":"Func/pyNumFunc/","text":"To find the maximum or minimum of some numbers or a list, you can use max or min. To find the distance of a number from zero (its absolute value), use abs. To round a number to a certain number of decimal places, use round. To find the total of a list, use sum. Numeric Functions x =- 47.3 y = abs ( x ) print ( f 'x is { type ( x ) } ' ) print ( f 'x is { x } ' ) print ( f 'x is { type ( y ) } ' ) print ( f 'x is { y } ' ) x is <class 'float'> x is -47.3 x is <class 'float'> x is 47.3 x = 47 y = divmod ( x , 3 ) print ( f 'x is { type ( x ) } ' ) print ( f 'x is { x } ' ) print ( f 'x is { type ( y ) } ' ) print ( f 'x is { y } ' ) x is <class 'int'> x is 47 x is <class 'tuple'> x is (15, 2) x = 47 y = x + 73 j #y=complex(x, 73) print ( f 'x is { type ( x ) } ' ) print ( f 'x is { x } ' ) print ( f 'x is { type ( y ) } ' ) print ( f 'x is { y } ' ) x is <class 'int'> x is 47 x is <class 'complex'> x is (47+73j) Mathematical Functions Mathematical functions import math Mathematical functions for complex numbers import cmath print ( min ( 0 , 1 , 2 , 3 , - 1 , 4 , 5 , 6 )) print ( min ([ 0 , 1 , 2 , 3 , - 1 , 4 , 5 , 6 ])) print ( abs ( - 54 )) print ( round ( 0.6464 , 2 )) print ( sum ([ 0 , 1 , 4 , 5 , - 3 , 9 ])) -1 -1 54 0.65 16 Statistics For more advanced function use numpy # using Python statistics functions import statistics # simple statistics operations sample_data1 = [ 1 , 3 , 5 , 7 ] sample_data2 = [ 2 , 3 , 5 , 4 , 3 , 5 , 3 , 2 , 5 , 6 , 4 , 3 ] # Use the mean function - calculates an average value print ( statistics . mean ( sample_data1 )) # Use the different median functions print ( statistics . median ( sample_data1 )) print ( statistics . median_low ( sample_data1 )) print ( statistics . median_high ( sample_data1 )) # The mode function indicates which data item occurs # most frequently print ( statistics . mode ( sample_data2 )) 4 4.0 3 5 3","title":"Numeric Functions"},{"location":"Func/pyNumFunc/#numeric-functions","text":"x =- 47.3 y = abs ( x ) print ( f 'x is { type ( x ) } ' ) print ( f 'x is { x } ' ) print ( f 'x is { type ( y ) } ' ) print ( f 'x is { y } ' ) x is <class 'float'> x is -47.3 x is <class 'float'> x is 47.3 x = 47 y = divmod ( x , 3 ) print ( f 'x is { type ( x ) } ' ) print ( f 'x is { x } ' ) print ( f 'x is { type ( y ) } ' ) print ( f 'x is { y } ' ) x is <class 'int'> x is 47 x is <class 'tuple'> x is (15, 2) x = 47 y = x + 73 j #y=complex(x, 73) print ( f 'x is { type ( x ) } ' ) print ( f 'x is { x } ' ) print ( f 'x is { type ( y ) } ' ) print ( f 'x is { y } ' ) x is <class 'int'> x is 47 x is <class 'complex'> x is (47+73j)","title":"Numeric Functions"},{"location":"Func/pyNumFunc/#mathematical-functions","text":"Mathematical functions import math Mathematical functions for complex numbers import cmath print ( min ( 0 , 1 , 2 , 3 , - 1 , 4 , 5 , 6 )) print ( min ([ 0 , 1 , 2 , 3 , - 1 , 4 , 5 , 6 ])) print ( abs ( - 54 )) print ( round ( 0.6464 , 2 )) print ( sum ([ 0 , 1 , 4 , 5 , - 3 , 9 ])) -1 -1 54 0.65 16","title":"Mathematical Functions"},{"location":"Func/pyNumFunc/#statistics","text":"For more advanced function use numpy # using Python statistics functions import statistics # simple statistics operations sample_data1 = [ 1 , 3 , 5 , 7 ] sample_data2 = [ 2 , 3 , 5 , 4 , 3 , 5 , 3 , 2 , 5 , 6 , 4 , 3 ] # Use the mean function - calculates an average value print ( statistics . mean ( sample_data1 )) # Use the different median functions print ( statistics . median ( sample_data1 )) print ( statistics . median_low ( sample_data1 )) print ( statistics . median_high ( sample_data1 )) # The mode function indicates which data item occurs # most frequently print ( statistics . mode ( sample_data2 )) 4 4.0 3 5 3","title":"Statistics"},{"location":"Func/pyRegex/","text":"Regular expressions are a powerful tool for various kinds of string manipulation. They are a domain specific language (DSL) that is present as a library in most modern programming languages, not just Python. Regex Site They are useful for two main tasks: - verifying that strings match a pattern (for instance, that a string has the format of an email address), - performing substitutions in a string (such as changing all American spellings to British ones). Domain specific languages are highly specialized mini programming languages. Regular expressions are a popular example, and SQL (for database manipulation) is another. Private domain-specific languages are often used for specific industrial purposes. Regular expressions in Python can be accessed using the re module, which is part of the standard library. After you've defined a regular expression, the re.match function can be used to determine whether it matches at the beginning of a string. If it does, match returns an object representing the match, if not, it returns None. To avoid any confusion while working with regular expressions, we would use raw strings as r\"expression\". Raw strings don't escape anything, which makes use of regular expressions easier. import re pattern = r \"spam\" if re . match ( pattern , \"spamspamspam\" ): print ( \"Match\" ) else : print ( \"No match\" ) Match The function re.search finds a match of a pattern anywhere in the string. The function re.findall returns a list of all substrings that match a pattern. The function re.finditer does the same thing as re.findall, except it returns an iterator, rather than a list. import re pattern = r \"spam\" if re . match ( pattern , \"eggspamsausagespam\" ): print ( \"Match\" ) else : print ( \"No match\" ) if re . search ( pattern , \"eggspamsausagespam\" ): print ( \"Match\" ) else : print ( \"No match\" ) print ( re . findall ( pattern , \"eggspamsausagespam\" )) No match Match ['spam', 'spam'] The regex search returns an object with several methods that give details about it. These methods include group which returns the string matched, start and end which return the start and ending positions of the first match, and span which returns the start and end positions of the first match as a tuple. import re pattern = r \"pam\" match = re . search ( pattern , \"eggspamsausage\" ) if match : print ( match . group ()) print ( match . start ()) print ( match . end ()) print ( match . span ()) pam 4 7 (4, 7) One of the most important re methods that use regular expressions is sub. re.sub(pattern, repl, string, count=0) This method replaces all occurrences of the pattern in string with repl, substituting all occurrences, unless count provided. This method returns the modified string. import re hello = \"My name is Carlos, Hi Carlos\" pattern = r \"Carlos\" newstr = re . sub ( pattern , \"Diana\" , hello , count = 1 ) print ( newstr ) My name is Diana, Hi Carlos Metacharacters Metacharacters are what make regular expressions more powerful than normal string methods. They allow you to create regular expressions to represent concepts like \"one or more repetitions of a vowel\". The existence of metacharacters poses a problem if you want to create a regular expression (or regex) that matches a literal metacharacter, such as \"$\". You can do this by escaping the metacharacters by putting a backslash in front of them. However, this can cause problems, since backslashes also have an escaping function in normal Python strings. This can mean putting three or four backslashes in a row to do all the escaping. To avoid this, you can use a raw string, which is a normal string with an \"r\" in front of it. . (dot) : This matches any character, other than a new line. ^ and $ : These match the start and end of a string, respectively. import re pattern = r \"gr.y\" pattern2 = r \"....\" #Any four character string with no newlines patt3 = r \"^gr.y$\" if re . match ( pattern , \"grey\" ): print ( \"Match 1\" ) if re . match ( pattern , \"gray\" ): print ( \"Match 2\" ) if re . match ( pattern , \"blue\" ): print ( \"Match 3\" ) if re . match ( patt3 , \"gray\" ): print ( \"Match 4\" ) if re . match ( patt3 , \"Stingray\" ): print ( \"Match 5\" ) Match 1 Match 2 Match 4 Character Classes Character classes provide a way to match only one of a specific set of characters. A character class is created by putting the characters it matches inside square brackets. The pattern [aeiou] in the search function matches all strings that contain any one of the characters defined. import re patt = r \"[aeiou]\" if re . search ( patt , \"grey\" ): print ( \"Match 1\" ) if re . search ( patt , \"qwertyuiop\" ): print ( \"Match 2\" ) if re . search ( patt , \"rhythm myths\" ): print ( \"Match 3\" ) Match 1 Match 2 Character classes can also match ranges of characters. Some examples: The class [a-z] matches any lowercase alphabetic character. The class [G-P] matches any uppercase character from G to P. The class [0-9] matches any digit. Multiple ranges can be included in one class. For example, [A-Za-z] matches a letter of any case. import re #strings that contain two alphabetic uppercase letters followed by a digit. patt = r \"[A-Z][A-Z][0-9]\" if re . search ( patt , \"LS8\" ): print ( \"Match 1\" ) if re . search ( patt , \"E3\" ): print ( \"Match 2\" ) if re . search ( patt , \"1ab\" ): print ( \"Match 3\" ) Match 1 Place a ^ at the start of a character class to invert it. This causes it to match any character other than the ones included. Other metacharacters such as $ and ., have no meaning within character classes. The metacharacter ^ has no meaning unless it is the first character in a class. The pattern [^A-Z] excludes uppercase strings. Note, that the ^ should be inside the brackets to invert the character class. import re patt = r \"[^A-Z]\" if re . search ( patt , \"this is all quiet\" ): print ( \"Match 1\" ) if re . search ( patt , \"E31hsDD\" ): print ( \"Match 2\" ) if re . search ( patt , \"SHOUT\" ): print ( \"Match 3\" ) Match 1 Match 2 Metacharacters for Repetition Some more metacharacters are * + ? { and }. These specify numbers of repetitions. * The metacharacter * means \"zero or more repetitions of the previous thing\". It tries to match as many repetitions as possible. The \"previous thing\" can be a single character, a class, or a group of characters in parentheses. * matches 0 or more occurrences of the preceding expression. * The metacharacter + is very similar to *, except it means \"one or more repetitions\", as opposed to \"zero or more repetitions\". + matches 1 or more occurrence of the preceding expression. * The metacharacter ? means \"zero or one repetitions\". * Curly braces can be used to represent the number of repetitions between two numbers. The regex {x,y} means \"between x and y repetitions of something\". Hence {0,1} is the same thing as ?. If the first number is missing, it is taken to be zero. If the second number is missing, it is taken to be infinity. import re # strings that start with \"egg\" and follow with zero or more \"spam\"s patt = r \"egg(spam)*\" patt1 = r \"[a^]*\" #Zero or more repetitions of \"a\" or \"^\" patt2 = r \"g+\" patt3 = r \"(42)+$\" #One or more 42s patt4 = r \"ice(-)?cream\" patt5 = r \"colo(u)?r\" #Matches both color and colour patt6 = r \"9{1,3}$\" # matches string that have 1 to 3 nines. if re . match ( patt , \"egg\" ): print ( \"Match 1\" ) if re . match ( patt , \"eggspamspamegg\" ): print ( \"Match 2\" ) if re . match ( patt , \"spam\" ): print ( \"Match 3\" ) if re . match ( patt2 , \"g\" ): print ( \"Match 4\" ) if re . match ( patt2 , \"gggggg\" ): print ( \"Match 5\" ) if re . match ( patt2 , \"abcde\" ): print ( \"Match 6\" ) if re . match ( patt4 , \"ice-cream\" ): print ( \"Match 7\" ) if re . match ( patt4 , \"icecream\" ): print ( \"Match 8\" ) if re . match ( patt4 , \"ice--cream\" ): print ( \"Match 9\" ) if re . match ( patt6 , \"9\" ): print ( \"Match 10\" ) if re . match ( patt6 , \"999\" ): print ( \"Match 11\" ) if re . match ( patt6 , \"9999\" ): print ( \"Match 12\" ) Match 1 Match 2 Match 4 Match 5 Match 7 Match 8 Match 10 Match 11 Groups A group can be created by surrounding part of a regular expression with parentheses. This means that a group can be given as an argument to metacharacters such as * and ?. (spam) represents a group in the example pattern shown below. The content of groups in a match can be accessed using the group function. A call of group(0) or group() returns the whole match. A call of group(n), where n is greater than 0, returns the nth group from the left. The method groups() returns all groups up from 1. Groups can be nested import re # strings that start with \"egg\" and follow with zero or more \"spam\"s patt = r \"egg(spam)*\" patt1 = r \"([^aeiou][aeiou][^aeiou])+\" #one or more repetitions of a nonvowel, a vowel and nonvowel patt2 = r \"a(bc)(de)(f(g)h)i\" if re . match ( patt , \"egg\" ): print ( \"Match 1\" ) if re . match ( patt , \"eggspamspamegg\" ): print ( \"Match 2\" ) if re . match ( patt , \"spam\" ): print ( \"Match 3\" ) match = re . match ( patt2 , \"abcdefghijklmnop\" ) if match : print ( match . group ()) print ( match . group ( 0 )) print ( match . group ( 1 )) print ( match . group ( 2 )) print ( match . groups ()) Match 1 Match 2 abcdefghi abcdefghi bc de ('bc', 'de', 'fgh', 'g') There are several kinds of special groups. Two useful ones are named groups and non-capturing groups. * Named groups have the format (?P ...), where name is the name of the group, and ... is the content. They behave exactly the same as normal groups, except they can be accessed by group(name) in addition to its number. * Non-capturing groups have the format (?:...). They are not accessible by the group method, so they can be added to an existing regular expression without breaking the numbering. import re patt = r \"(?P<first>abc)(?:def)(ghi)\" match = re . match ( patt , \"abcdefghijklmnop\" ) if match : print ( match . group ( \"first\" )) print ( match . groups ()) abc ('abc', 'ghi') Another important metacharacter is |. This means \"or\", so red|blue matches either \"red\" or \"blue\". import re patt = r \"gr(a|e)y\" match = re . match ( patt , \"gray\" ) if match : print ( \"Match 1\" ) match = re . match ( patt , \"grey\" ) if match : print ( \"Match 2\" ) match = re . match ( patt , \"griy\" ) if match : print ( \"Match 3\" ) Match 1 Match 2 Special Sequences There are various special sequences you can use in regular expressions. They are written as a backslash followed by another character. One useful special sequence is a backslash and a number between 1 and 99, e.g., \\1 or \\17. This matches the expression of the group of that number. Note, that \"(.+) \\1\" is not the same as \"(.+) (.+)\", because \\1 refers to the first group's subexpression, which is the matched expression itself, and not the regex pattern. More useful special sequences are \\d, \\s, and \\w. These match digits, whitespace, and word characters respectively. In ASCII mode they are equivalent to [0-9], [ \\t\\n\\r\\f\\v], and [a-zA-Z0-9_]. In Unicode mode they match certain other characters, as well. For instance, \\w matches letters with accents. Versions of these special sequences with upper case letters - \\D, \\S, and \\W - mean the opposite to the lower-case versions. For instance, \\D matches anything that isn't a digit. Additional special sequences are \\A, \\Z, and \\b. The sequences \\A and \\Z match the beginning and end of a string, respectively. The sequence \\b matches the empty string between \\w and \\W characters, or \\w characters and the beginning or end of the string. Informally, it represents the boundary between words. The sequence \\B matches the empty string anywhere else. import re #[\\w\\.-]+ matches one or more word character, dot or dash. emailpattern = r \"([\\w\\.-]+)@([\\w\\.-]+)(\\.[\\w\\.]+)\" patt = r \"(.+) \\1\" match = re . match ( patt , \"word word\" ) if match : print ( \"Match 1\" ) match = re . match ( patt , \"?! ?!\" ) if match : print ( \"Match 2\" ) match = re . match ( patt , \"abc def\" ) if match : print ( \"Match 3\" ) patt = r \"(\\D+\\d)\" # matches one or more non-digits followed by a digit. match = re . match ( patt , \"Hi 999!\" ) if match : print ( \"Match 4\" ) match = re . match ( patt , \"1, 23, 456!!\" ) if match : print ( \"Match 5\" ) match = re . match ( patt , \" ! $?\" ) if match : print ( \"Match 6\" ) patt = r \"\\b(cat)\\b\" # matches the word \"cat\" surrounded by word boundaries. match = re . search ( patt , \"The cat sat!\" ) #needs search not match if match : print ( \"Match 7\" ) match = re . search ( patt , \"we s>cat<tered?\" ) if match : print ( \"Match 8\" ) match = re . search ( patt , \"We scattered.\" ) if match : print ( \"Match 9\" ) patt = r \"\\B(cat)\\B\" match = re . search ( patt , \"We scattered.\" ) if match : print ( \"Match 10\" ) #[\\w\\.-]+ matches one or more word character, dot or dash. the dot is preceded by \\ to treat it as a character emailpattern = r \"([\\w\\.-]+)@([\\w\\.-]+)(\\.[\\w\\.]+)\" match = re . search ( emailpattern , \"Please contact car.ar@laposte.net for any assitance\" ) #needs search not match if match : print ( match . group ()) Match 1 Match 2 Match 4 Match 7 Match 8 Match 10 car.ar@laposte.net Regexes can be more readable with the verbose flag #The usual compact way: email_rx = r \"^[^@ ]+@[^@ ]+\\.[^@ ]+$\" import re #The verbose way: email_rx = r \"\"\"(?x) #verbose flag ^ #beginning of string [^@ ]+ #stuff without @ or space (name) @ #an @ sign [^@ ]+ #more stuff (domain) \\. #a dot [^@ ]+ #final stuff(com, org,..) $ #end of string \"\"\" print ( re . match ( email_rx , \"carlos@pollo.com\" )) <re.Match object; span=(0, 16), match='carlos@pollo.com'>","title":"Regular Expressions"},{"location":"Func/pyRegex/#metacharacters","text":"Metacharacters are what make regular expressions more powerful than normal string methods. They allow you to create regular expressions to represent concepts like \"one or more repetitions of a vowel\". The existence of metacharacters poses a problem if you want to create a regular expression (or regex) that matches a literal metacharacter, such as \"$\". You can do this by escaping the metacharacters by putting a backslash in front of them. However, this can cause problems, since backslashes also have an escaping function in normal Python strings. This can mean putting three or four backslashes in a row to do all the escaping. To avoid this, you can use a raw string, which is a normal string with an \"r\" in front of it. . (dot) : This matches any character, other than a new line. ^ and $ : These match the start and end of a string, respectively. import re pattern = r \"gr.y\" pattern2 = r \"....\" #Any four character string with no newlines patt3 = r \"^gr.y$\" if re . match ( pattern , \"grey\" ): print ( \"Match 1\" ) if re . match ( pattern , \"gray\" ): print ( \"Match 2\" ) if re . match ( pattern , \"blue\" ): print ( \"Match 3\" ) if re . match ( patt3 , \"gray\" ): print ( \"Match 4\" ) if re . match ( patt3 , \"Stingray\" ): print ( \"Match 5\" ) Match 1 Match 2 Match 4","title":"Metacharacters"},{"location":"Func/pyRegex/#character-classes","text":"Character classes provide a way to match only one of a specific set of characters. A character class is created by putting the characters it matches inside square brackets. The pattern [aeiou] in the search function matches all strings that contain any one of the characters defined. import re patt = r \"[aeiou]\" if re . search ( patt , \"grey\" ): print ( \"Match 1\" ) if re . search ( patt , \"qwertyuiop\" ): print ( \"Match 2\" ) if re . search ( patt , \"rhythm myths\" ): print ( \"Match 3\" ) Match 1 Match 2 Character classes can also match ranges of characters. Some examples: The class [a-z] matches any lowercase alphabetic character. The class [G-P] matches any uppercase character from G to P. The class [0-9] matches any digit. Multiple ranges can be included in one class. For example, [A-Za-z] matches a letter of any case. import re #strings that contain two alphabetic uppercase letters followed by a digit. patt = r \"[A-Z][A-Z][0-9]\" if re . search ( patt , \"LS8\" ): print ( \"Match 1\" ) if re . search ( patt , \"E3\" ): print ( \"Match 2\" ) if re . search ( patt , \"1ab\" ): print ( \"Match 3\" ) Match 1 Place a ^ at the start of a character class to invert it. This causes it to match any character other than the ones included. Other metacharacters such as $ and ., have no meaning within character classes. The metacharacter ^ has no meaning unless it is the first character in a class. The pattern [^A-Z] excludes uppercase strings. Note, that the ^ should be inside the brackets to invert the character class. import re patt = r \"[^A-Z]\" if re . search ( patt , \"this is all quiet\" ): print ( \"Match 1\" ) if re . search ( patt , \"E31hsDD\" ): print ( \"Match 2\" ) if re . search ( patt , \"SHOUT\" ): print ( \"Match 3\" ) Match 1 Match 2","title":"Character Classes"},{"location":"Func/pyRegex/#metacharacters-for-repetition","text":"Some more metacharacters are * + ? { and }. These specify numbers of repetitions. * The metacharacter * means \"zero or more repetitions of the previous thing\". It tries to match as many repetitions as possible. The \"previous thing\" can be a single character, a class, or a group of characters in parentheses. * matches 0 or more occurrences of the preceding expression. * The metacharacter + is very similar to *, except it means \"one or more repetitions\", as opposed to \"zero or more repetitions\". + matches 1 or more occurrence of the preceding expression. * The metacharacter ? means \"zero or one repetitions\". * Curly braces can be used to represent the number of repetitions between two numbers. The regex {x,y} means \"between x and y repetitions of something\". Hence {0,1} is the same thing as ?. If the first number is missing, it is taken to be zero. If the second number is missing, it is taken to be infinity. import re # strings that start with \"egg\" and follow with zero or more \"spam\"s patt = r \"egg(spam)*\" patt1 = r \"[a^]*\" #Zero or more repetitions of \"a\" or \"^\" patt2 = r \"g+\" patt3 = r \"(42)+$\" #One or more 42s patt4 = r \"ice(-)?cream\" patt5 = r \"colo(u)?r\" #Matches both color and colour patt6 = r \"9{1,3}$\" # matches string that have 1 to 3 nines. if re . match ( patt , \"egg\" ): print ( \"Match 1\" ) if re . match ( patt , \"eggspamspamegg\" ): print ( \"Match 2\" ) if re . match ( patt , \"spam\" ): print ( \"Match 3\" ) if re . match ( patt2 , \"g\" ): print ( \"Match 4\" ) if re . match ( patt2 , \"gggggg\" ): print ( \"Match 5\" ) if re . match ( patt2 , \"abcde\" ): print ( \"Match 6\" ) if re . match ( patt4 , \"ice-cream\" ): print ( \"Match 7\" ) if re . match ( patt4 , \"icecream\" ): print ( \"Match 8\" ) if re . match ( patt4 , \"ice--cream\" ): print ( \"Match 9\" ) if re . match ( patt6 , \"9\" ): print ( \"Match 10\" ) if re . match ( patt6 , \"999\" ): print ( \"Match 11\" ) if re . match ( patt6 , \"9999\" ): print ( \"Match 12\" ) Match 1 Match 2 Match 4 Match 5 Match 7 Match 8 Match 10 Match 11","title":"Metacharacters for Repetition"},{"location":"Func/pyRegex/#groups","text":"A group can be created by surrounding part of a regular expression with parentheses. This means that a group can be given as an argument to metacharacters such as * and ?. (spam) represents a group in the example pattern shown below. The content of groups in a match can be accessed using the group function. A call of group(0) or group() returns the whole match. A call of group(n), where n is greater than 0, returns the nth group from the left. The method groups() returns all groups up from 1. Groups can be nested import re # strings that start with \"egg\" and follow with zero or more \"spam\"s patt = r \"egg(spam)*\" patt1 = r \"([^aeiou][aeiou][^aeiou])+\" #one or more repetitions of a nonvowel, a vowel and nonvowel patt2 = r \"a(bc)(de)(f(g)h)i\" if re . match ( patt , \"egg\" ): print ( \"Match 1\" ) if re . match ( patt , \"eggspamspamegg\" ): print ( \"Match 2\" ) if re . match ( patt , \"spam\" ): print ( \"Match 3\" ) match = re . match ( patt2 , \"abcdefghijklmnop\" ) if match : print ( match . group ()) print ( match . group ( 0 )) print ( match . group ( 1 )) print ( match . group ( 2 )) print ( match . groups ()) Match 1 Match 2 abcdefghi abcdefghi bc de ('bc', 'de', 'fgh', 'g') There are several kinds of special groups. Two useful ones are named groups and non-capturing groups. * Named groups have the format (?P ...), where name is the name of the group, and ... is the content. They behave exactly the same as normal groups, except they can be accessed by group(name) in addition to its number. * Non-capturing groups have the format (?:...). They are not accessible by the group method, so they can be added to an existing regular expression without breaking the numbering. import re patt = r \"(?P<first>abc)(?:def)(ghi)\" match = re . match ( patt , \"abcdefghijklmnop\" ) if match : print ( match . group ( \"first\" )) print ( match . groups ()) abc ('abc', 'ghi') Another important metacharacter is |. This means \"or\", so red|blue matches either \"red\" or \"blue\". import re patt = r \"gr(a|e)y\" match = re . match ( patt , \"gray\" ) if match : print ( \"Match 1\" ) match = re . match ( patt , \"grey\" ) if match : print ( \"Match 2\" ) match = re . match ( patt , \"griy\" ) if match : print ( \"Match 3\" ) Match 1 Match 2","title":"Groups"},{"location":"Func/pyRegex/#special-sequences","text":"There are various special sequences you can use in regular expressions. They are written as a backslash followed by another character. One useful special sequence is a backslash and a number between 1 and 99, e.g., \\1 or \\17. This matches the expression of the group of that number. Note, that \"(.+) \\1\" is not the same as \"(.+) (.+)\", because \\1 refers to the first group's subexpression, which is the matched expression itself, and not the regex pattern. More useful special sequences are \\d, \\s, and \\w. These match digits, whitespace, and word characters respectively. In ASCII mode they are equivalent to [0-9], [ \\t\\n\\r\\f\\v], and [a-zA-Z0-9_]. In Unicode mode they match certain other characters, as well. For instance, \\w matches letters with accents. Versions of these special sequences with upper case letters - \\D, \\S, and \\W - mean the opposite to the lower-case versions. For instance, \\D matches anything that isn't a digit. Additional special sequences are \\A, \\Z, and \\b. The sequences \\A and \\Z match the beginning and end of a string, respectively. The sequence \\b matches the empty string between \\w and \\W characters, or \\w characters and the beginning or end of the string. Informally, it represents the boundary between words. The sequence \\B matches the empty string anywhere else. import re #[\\w\\.-]+ matches one or more word character, dot or dash. emailpattern = r \"([\\w\\.-]+)@([\\w\\.-]+)(\\.[\\w\\.]+)\" patt = r \"(.+) \\1\" match = re . match ( patt , \"word word\" ) if match : print ( \"Match 1\" ) match = re . match ( patt , \"?! ?!\" ) if match : print ( \"Match 2\" ) match = re . match ( patt , \"abc def\" ) if match : print ( \"Match 3\" ) patt = r \"(\\D+\\d)\" # matches one or more non-digits followed by a digit. match = re . match ( patt , \"Hi 999!\" ) if match : print ( \"Match 4\" ) match = re . match ( patt , \"1, 23, 456!!\" ) if match : print ( \"Match 5\" ) match = re . match ( patt , \" ! $?\" ) if match : print ( \"Match 6\" ) patt = r \"\\b(cat)\\b\" # matches the word \"cat\" surrounded by word boundaries. match = re . search ( patt , \"The cat sat!\" ) #needs search not match if match : print ( \"Match 7\" ) match = re . search ( patt , \"we s>cat<tered?\" ) if match : print ( \"Match 8\" ) match = re . search ( patt , \"We scattered.\" ) if match : print ( \"Match 9\" ) patt = r \"\\B(cat)\\B\" match = re . search ( patt , \"We scattered.\" ) if match : print ( \"Match 10\" ) #[\\w\\.-]+ matches one or more word character, dot or dash. the dot is preceded by \\ to treat it as a character emailpattern = r \"([\\w\\.-]+)@([\\w\\.-]+)(\\.[\\w\\.]+)\" match = re . search ( emailpattern , \"Please contact car.ar@laposte.net for any assitance\" ) #needs search not match if match : print ( match . group ()) Match 1 Match 2 Match 4 Match 7 Match 8 Match 10 car.ar@laposte.net Regexes can be more readable with the verbose flag #The usual compact way: email_rx = r \"^[^@ ]+@[^@ ]+\\.[^@ ]+$\" import re #The verbose way: email_rx = r \"\"\"(?x) #verbose flag ^ #beginning of string [^@ ]+ #stuff without @ or space (name) @ #an @ sign [^@ ]+ #more stuff (domain) \\. #a dot [^@ ]+ #final stuff(com, org,..) $ #end of string \"\"\" print ( re . match ( email_rx , \"carlos@pollo.com\" )) <re.Match object; span=(0, 16), match='carlos@pollo.com'>","title":"Special Sequences"},{"location":"PR/pyAsser/","text":"An assertion is a sanity-check that you can turn on or turn off when you have finished testing the program. An expression is tested, and if the result comes up false, an exception is raised. Assertions are carried out through use of the assert statement. Programmers often place assertions at the start of a function to check for valid input, and after a function call to check for valid output. print ( 1 ) assert 2 + 2 == 4 print ( 2 ) assert 1 + 1 == 3 print ( 3 ) 1 2 --------------------------------------------------------------------------- AssertionError Traceback (most recent call last) <ipython-input-77-c678df5c3c33> in <module>() 2 assert 2 + 2 == 4 3 print (2) ----> 4 assert 1 + 1 == 3 5 print (3) AssertionError: The assert can take a second argument that is passed to the AssertionError raised if the assertion fails. AssertionError exceptions can be caught and handled like any other exception using the try-except statement, but if not handled, this type of exception will terminate the program. temp =- 10 assert ( temp >= 0 ), \"Colder than absolute zero!\" --------------------------------------------------------------------------- AssertionError Traceback (most recent call last) <ipython-input-78-f713a352d793> in <module>() 1 temp=-10 ----> 2 assert (temp>=0), \"Colder than absolute zero!\" AssertionError: Colder than absolute zero!","title":"Assertions"},{"location":"PR/pyCompr/","text":"Comprehensions are a handy way to run a loop within a single line of code and to collect the results of the loop in a collection such as a list List Comprehension List comprehensions are a useful way of quickly creating lists whose contents obey a simple rule. Python allows for list comprehension in which the elements of a list are iterated over all in one line of code. List comprehensions are inspired by set-builder notation in mathematics. even_list = [ 2 , 4 , 6 , 8 ] odd_list = [ even + 1 for even in even_list ] print ( odd_list ) cubes = [ i ** 3 for i in range ( 5 )] print ( cubes ) [3, 5, 7, 9] [0, 1, 8, 27, 64] Note from above the similarities between list comprehension and a for-loop; Python has list comprehension as a compact, \"pythonic\" way of performing operations that could be done within a for-loop. A list comprehension can also contain an if statement to enforce a condition on values in the list. a = [ i ** 2 for i in range ( 10 )] evens = [ i ** 2 for i in range ( 10 ) if i ** 2 % 2 == 0 ] print ( a ) print ( evens ) [0, 1, 4, 9, 16, 25, 36, 49, 64, 81] [0, 4, 16, 36, 64] Trying to create a list in a very extensive range will result in a MemoryError. This code shows an example where the list comprehension runs out of memory. This issue is solved by generators. results = [] for city , year in zip ( cities , years ): #int () needed because year is a string if int ( year ) > 1945 : results . append ( city + ': ' + year ) To do it better and more Pythonic Use List comprehensions #List comprehension: # [f(element) for element in iterator if condition(element)] results = [( city + ': ' + year ) for city , year in zip ( cities , years ) if int ( year ) > 1945 ] results = [( city + ': ' + year ) for city , year in zip ( cities , years ) if int ( year ) > 1945 ] Dictionary comprehension cities_by_year = { year : city for city , year in zip ( cities , years )} # Demonstrate how to use dictionary comprehensions def main (): # define a list of temperature values ctemps = [ 0 , 12 , 34 , 100 ] # Use a comprehension to build a dictionary tempDict = { t : ( t * 9 / 5 ) + 32 for t in ctemps if t < 100 } print ( tempDict ) print ( tempDict [ 12 ]) # Merge two dictionaries with a comprehension team1 = { \"Jones\" : 24 , \"Jameson\" : 18 , \"Smith\" : 58 , \"Burns\" : 7 } team2 = { \"White\" : 12 , \"Macke\" : 88 , \"Perce\" : 4 } newTeam = { k : v for team in ( team1 , team2 ) for k , v in team . items ()} print ( newTeam ) if __name__ == \"__main__\" : main () {0: 32.0, 12: 53.6, 34: 93.2} 53.6 {'Jones': 24, 'Jameson': 18, 'Smith': 58, 'Burns': 7, 'White': 12, 'Macke': 88, 'Perce': 4} Set Comprehension cities_after_1930 = { city for year , city in cities_by_year . items () if int ( year ) > 1930 } def main (): # define a list of temperature data points ctemps = [ 5 , 10 , 12 , 14 , 10 , 23 , 41 , 30 , 12 , 24 , 12 , 18 , 29 ] # build a set of unique Fahrenheit temperatures ftemps1 = [( t * 9 / 5 ) + 32 for t in ctemps ] ftemps2 = {( t * 9 / 5 ) + 32 for t in ctemps } print ( ftemps1 ) print ( ftemps2 ) # build a set from an input source sTemp = \"The quick brown fox jumped over the lazy dog\" chars = { c . upper () for c in sTemp if not c . isspace ()} print ( chars ) if __name__ == \"__main__\" : main () [41.0, 50.0, 53.6, 57.2, 50.0, 73.4, 105.8, 86.0, 53.6, 75.2, 53.6, 64.4, 84.2] {64.4, 73.4, 41.0, 105.8, 75.2, 50.0, 84.2, 53.6, 86.0, 57.2} {'G', 'M', 'E', 'B', 'J', 'U', 'R', 'N', 'W', 'P', 'Y', 'T', 'O', 'H', 'Z', 'Q', 'V', 'X', 'F', 'K', 'L', 'D', 'I', 'A', 'C'}","title":"Comprehensions"},{"location":"PR/pyCompr/#list-comprehension","text":"List comprehensions are a useful way of quickly creating lists whose contents obey a simple rule. Python allows for list comprehension in which the elements of a list are iterated over all in one line of code. List comprehensions are inspired by set-builder notation in mathematics. even_list = [ 2 , 4 , 6 , 8 ] odd_list = [ even + 1 for even in even_list ] print ( odd_list ) cubes = [ i ** 3 for i in range ( 5 )] print ( cubes ) [3, 5, 7, 9] [0, 1, 8, 27, 64] Note from above the similarities between list comprehension and a for-loop; Python has list comprehension as a compact, \"pythonic\" way of performing operations that could be done within a for-loop. A list comprehension can also contain an if statement to enforce a condition on values in the list. a = [ i ** 2 for i in range ( 10 )] evens = [ i ** 2 for i in range ( 10 ) if i ** 2 % 2 == 0 ] print ( a ) print ( evens ) [0, 1, 4, 9, 16, 25, 36, 49, 64, 81] [0, 4, 16, 36, 64] Trying to create a list in a very extensive range will result in a MemoryError. This code shows an example where the list comprehension runs out of memory. This issue is solved by generators. results = [] for city , year in zip ( cities , years ): #int () needed because year is a string if int ( year ) > 1945 : results . append ( city + ': ' + year ) To do it better and more Pythonic Use List comprehensions #List comprehension: # [f(element) for element in iterator if condition(element)] results = [( city + ': ' + year ) for city , year in zip ( cities , years ) if int ( year ) > 1945 ] results = [( city + ': ' + year ) for city , year in zip ( cities , years ) if int ( year ) > 1945 ]","title":"List Comprehension"},{"location":"PR/pyCompr/#dictionary-comprehension","text":"cities_by_year = { year : city for city , year in zip ( cities , years )} # Demonstrate how to use dictionary comprehensions def main (): # define a list of temperature values ctemps = [ 0 , 12 , 34 , 100 ] # Use a comprehension to build a dictionary tempDict = { t : ( t * 9 / 5 ) + 32 for t in ctemps if t < 100 } print ( tempDict ) print ( tempDict [ 12 ]) # Merge two dictionaries with a comprehension team1 = { \"Jones\" : 24 , \"Jameson\" : 18 , \"Smith\" : 58 , \"Burns\" : 7 } team2 = { \"White\" : 12 , \"Macke\" : 88 , \"Perce\" : 4 } newTeam = { k : v for team in ( team1 , team2 ) for k , v in team . items ()} print ( newTeam ) if __name__ == \"__main__\" : main () {0: 32.0, 12: 53.6, 34: 93.2} 53.6 {'Jones': 24, 'Jameson': 18, 'Smith': 58, 'Burns': 7, 'White': 12, 'Macke': 88, 'Perce': 4}","title":"Dictionary comprehension"},{"location":"PR/pyCompr/#set-comprehension","text":"cities_after_1930 = { city for year , city in cities_by_year . items () if int ( year ) > 1930 } def main (): # define a list of temperature data points ctemps = [ 5 , 10 , 12 , 14 , 10 , 23 , 41 , 30 , 12 , 24 , 12 , 18 , 29 ] # build a set of unique Fahrenheit temperatures ftemps1 = [( t * 9 / 5 ) + 32 for t in ctemps ] ftemps2 = {( t * 9 / 5 ) + 32 for t in ctemps } print ( ftemps1 ) print ( ftemps2 ) # build a set from an input source sTemp = \"The quick brown fox jumped over the lazy dog\" chars = { c . upper () for c in sTemp if not c . isspace ()} print ( chars ) if __name__ == \"__main__\" : main () [41.0, 50.0, 53.6, 57.2, 50.0, 73.4, 105.8, 86.0, 53.6, 75.2, 53.6, 64.4, 84.2] {64.4, 73.4, 41.0, 105.8, 75.2, 50.0, 84.2, 53.6, 86.0, 57.2} {'G', 'M', 'E', 'B', 'J', 'U', 'R', 'N', 'W', 'P', 'Y', 'T', 'O', 'H', 'Z', 'Q', 'V', 'X', 'F', 'K', 'L', 'D', 'I', 'A', 'C'}","title":"Set Comprehension"},{"location":"PR/pyCond/","text":"Oftentimes while programming, one will want to only execute portions of code when certain conditions are met, for instance, when a variable has a certain value. This is accomplished using conditional statements: if, elif, and else. Indentation is used to define the level of nesting, for nested conditionals. Multiple if/else statements make the code long and not very readable. The elif statement is equivalent to an else/if statement. It is used to make the code shorter, more readable, and avoid indentation increase. for i in range ( 10 ): if i % 2 == 0 : # % -- modulus operator -- returns the remainder after division print ( \" {} is even\" . format ( i )) else : print ( \" {} is odd\" . format ( i )) 0 is even 1 is odd 2 is even 3 is odd 4 is even 5 is odd 6 is even 7 is odd 8 is even 9 is odd # Example using elif as well # Print the meteorological season for each month (loosely, of course, and in the Northern Hemisphere) print ( \"In the Northern Hemisphere: \\n \" ) month_integer = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 ] # i.e., January is 1, February is 2, etc... for month in month_integer : if month < 3 : print ( \"Month {} is in Winter\" . format ( month )) elif month < 6 : print ( \"Month {} is in Spring\" . format ( month )) elif month < 9 : print ( \"Month {} is in Summer\" . format ( month )) elif month < 12 : print ( \"Month {} is in Fall\" . format ( month )) else : # This will put 12 (i.e., December) into Winter print ( \"Month {} is in Winter\" . format ( month )) In the Northern Hemisphere: Month 1 is in Winter Month 2 is in Winter Month 3 is in Spring Month 4 is in Spring Month 5 is in Spring Month 6 is in Summer Month 7 is in Summer Month 8 is in Summer Month 9 is in Fall Month 10 is in Fall Month 11 is in Fall Month 12 is in Winter Ternary operator Conditional expressions provide the functionality of if statements while using less code. They shouldn't be overused, as they can easily reduce readability, but they are often useful when assigning variables. Conditional expressions are also known as applications of the ternary operator. The ternary operator checks the condition and returns the corresponding value. The ternary operator is so called because, unlike most operators, it takes three arguments. a = 3 b = 1 if a >= 5 else 42 print ( b ) #42 Match case (Switch) ##For 3.10 up value = \"one\" match value : case \"one\" : result = 1 case \"two\" : result = 2 case \"three\" | \"four\" : result = ( 3 , 4 ) case _ : result =- 1 print ( result )","title":"Conditionals"},{"location":"PR/pyCond/#ternary-operator","text":"Conditional expressions provide the functionality of if statements while using less code. They shouldn't be overused, as they can easily reduce readability, but they are often useful when assigning variables. Conditional expressions are also known as applications of the ternary operator. The ternary operator checks the condition and returns the corresponding value. The ternary operator is so called because, unlike most operators, it takes three arguments. a = 3 b = 1 if a >= 5 else 42 print ( b ) #42","title":"Ternary operator"},{"location":"PR/pyCond/#match-case-switch","text":"##For 3.10 up value = \"one\" match value : case \"one\" : result = 1 case \"two\" : result = 2 case \"three\" | \"four\" : result = ( 3 , 4 ) case _ : result =- 1 print ( result )","title":"Match case (Switch)"},{"location":"PR/pyElse/","text":"The else statement is most commonly used along with the if statement, but it can also follow a for or while loop, which gives it a different meaning. With the for or while loop, the code within it is called if the loop finishes normally (when a break statement does not cause an exit from the loop). for i in range ( 10 ): if i == 999 : break else : print ( \"Unbroken 1\" ) for i in range ( 10 ): if i == 5 : break else : print ( \"Unbroken 2\" ) Unbroken 1 The else statement can also be used with try/except statements. In this case, the code within it is only executed if no error occurs in the try statement. try : print ( 1 ) except ZeroDivisionError : print ( 2 ) else : print ( 3 ) print ( \"*********\" ) try : print ( 1 / 0 ) except ZeroDivisionError : print ( 2 ) else : print ( 3 ) 1 3 ********* 2","title":"Else-4loopsExcep"},{"location":"PR/pyExp/","text":"Exceptions ImportError: an import fails; IndexError: a list is indexed with an out-of-range number; NameError: an unknown variable is used; SyntaxError: the code can't be parsed properly; TypeError: a function is called on a value of an inappropriate type; ValueError: a function is called on a value of the correct type, but with an inappropriate value. Exception Handling To handle exceptions, and to call code when an exception occurs, you can use a try/except statement. Multiple exceptions can also be put into a single except block using parentheses, to have the except block handle all of them. An except statement without any exception specified will catch all errors. Finally To ensure some code runs no matter what errors occur, you can use a finally statement. The finally statement is placed at the bottom of a try/except statement. try : a = 0 b = 1 print ( a / b ) #print(b/a) print ( a + \"a\" ) except ZeroDivisionError : print ( \"Error!\" ) except ( ValueError , TypeError ): print ( \"Error 2!\" ) except : print ( f 'Unknown error: { sys . exc_info () } ' ) else : print ( 'No errors' ) finally : print ( \"Bye bye\" ) 0.0 Error 2! Bye bye Raising Exceptions Use raise statement Exceptions can be raised with arguments that give detail about them. print ( 1 ) raise ValueError print ( 2 ) 1 --------------------------------------------------------------------------- ValueError Traceback (most recent call last) <ipython-input-75-990863ff3a0f> in <module>() 1 print(1) ----> 2 raise ValueError 3 print(2) ValueError: try : name = \"123\" raise NameError ( \"Invalid Name!\" ) except NameError as e : print ( f 'Name error: { e } ' ) print ( 2 ) Name error: Invalid Name! 2","title":"Exceptions"},{"location":"PR/pyExp/#exceptions","text":"ImportError: an import fails; IndexError: a list is indexed with an out-of-range number; NameError: an unknown variable is used; SyntaxError: the code can't be parsed properly; TypeError: a function is called on a value of an inappropriate type; ValueError: a function is called on a value of the correct type, but with an inappropriate value.","title":"Exceptions"},{"location":"PR/pyExp/#exception-handling","text":"To handle exceptions, and to call code when an exception occurs, you can use a try/except statement. Multiple exceptions can also be put into a single except block using parentheses, to have the except block handle all of them. An except statement without any exception specified will catch all errors.","title":"Exception Handling"},{"location":"PR/pyExp/#finally","text":"To ensure some code runs no matter what errors occur, you can use a finally statement. The finally statement is placed at the bottom of a try/except statement. try : a = 0 b = 1 print ( a / b ) #print(b/a) print ( a + \"a\" ) except ZeroDivisionError : print ( \"Error!\" ) except ( ValueError , TypeError ): print ( \"Error 2!\" ) except : print ( f 'Unknown error: { sys . exc_info () } ' ) else : print ( 'No errors' ) finally : print ( \"Bye bye\" ) 0.0 Error 2! Bye bye","title":"Finally"},{"location":"PR/pyExp/#raising-exceptions","text":"Use raise statement Exceptions can be raised with arguments that give detail about them. print ( 1 ) raise ValueError print ( 2 ) 1 --------------------------------------------------------------------------- ValueError Traceback (most recent call last) <ipython-input-75-990863ff3a0f> in <module>() 1 print(1) ----> 2 raise ValueError 3 print(2) ValueError: try : name = \"123\" raise NameError ( \"Invalid Name!\" ) except NameError as e : print ( f 'Name error: { e } ' ) print ( 2 ) Name error: Invalid Name! 2","title":"Raising Exceptions"},{"location":"PR/pyOp1/","text":"Operator Name Description a + b Addition Sum of a and b a - b Subtraction Difference of a and b a * b Multiplication Product of a and b a / b True division Quotient of a and b a // b Floor division Quotient of a and b , removing fractional parts a % b Modulus Integer remainder after division of a by b a ** b Exponentiation a raised to the power of b -a Negation The negative of a a = 3 ** 2 b = 2 ** 2 ** 3 print ( a ) print ( b ) print ( 9 ** ( 1 / 2 )) #result is float print ( 20 // 6 ) # Quotient print ( 20 % 6 ) # Modulo or remainder 9 256 3.0 3 2 For enhanced precision, the decimal module provides support for fast correctly-rounded decimal floating point arithmetic. from decimal import * getcontext () . prec = 6 Decimal ( 1 ) / Decimal ( 7 ) Decimal('0.142857')","title":"Arithmethic"},{"location":"PR/pyOp2/","text":"In Python, bitwise operators are used to performing bitwise calculations on integers. The integers are first converted into binary and then operations are performed on bit by bit, hence the name bitwise operators. Then the result is returned in decimal format. Note: Python bitwise operators work only on integers. Operator Name Description a & b Bitwise AND Returns 1 if both the bits are 1 else 0 a | b Bitwise OR Returns 1 if either of the bit is 1 else 0 a ~ b Bitwise NOT Returns one\u2019s complement of the number a ^ b Bitwise XOR Returns 1 if one of the bits is 1 and the other is 0 else returns false a >> b Bitwise right shift Returns 1 if both the bits are 1 else 0 a << b Bitwise left shift Returns 1 if both the bits are 1 else 0 Shift Operators These operators are used to shift the bits of a number left or right thereby multiplying or dividing the number by two respectively. They can be used when we have to multiply or divide a number by two. Bitwise right shift Shifts the bits of the number to the right and fills 0 on voids left as a result. Similar effect as of dividing the number with some power of two. Bitwise left shift Shifts the bits of the number to the left and fills 0 on voids left as a result. Similar effect as of multiplying the number with some power of two. a = 10 #1010(Binary) b = 4 #0100(Binary) # Print bitwise AND operation print ( \"a & b =\" , a & b ) #0000(Binary) # Print bitwise OR operation print ( \"a | b =\" , a | b ) #1110(Binary)=14(Decimal) # Print bitwise NOT operation print ( \"~a =\" , ~ a ) #-(1010+1)(Binary)=-(1011)=-11(Decimal) # print bitwise XOR operation print ( \"a ^ b =\" , a ^ b ) # 1110(Binary)=14(Decimal) a = 10 b = - 10 # print bitwise right shift operator print ( \"a >> 1 =\" , a >> 1 ) print ( \"b >> 1 =\" , b >> 1 ) a = 5 b = - 10 # print bitwise left shift operator print ( \"a << 1 =\" , a << 1 ) print ( \"b << 1 =\" , b << 1 ) #Hexidecimal x = 0x0a y = 0x02 z = x & y print ( f '(hex) x is { x : 02x } , y is { y : 02x } , z is { z : 02x } ' ) print ( f '(bin) x is { x : 08b } , y is { y : 08b } , z is { z : 08b } ' ) z = x << y print ( f '(bin) x is { x : 08b } , y is { y : 08b } , z is { z : 08b } ' ) a & b = 0 a | b = 14 ~a = -11 a ^ b = 14 a >> 1 = 5 b >> 1 = -5 a << 1 = 10 b << 1 = -20 (hex) x is 0a, y is 02, z is 02 (bin) x is 00001010, y is 00000010, z is 00000010 (bin) x is 00001010, y is 00000010, z is 00101000","title":"Bitwise"},{"location":"PR/pyOp2/#shift-operators","text":"These operators are used to shift the bits of a number left or right thereby multiplying or dividing the number by two respectively. They can be used when we have to multiply or divide a number by two.","title":"Shift Operators"},{"location":"PR/pyOp2/#bitwise-right-shift","text":"Shifts the bits of the number to the right and fills 0 on voids left as a result. Similar effect as of dividing the number with some power of two.","title":"Bitwise right shift"},{"location":"PR/pyOp2/#bitwise-left-shift","text":"Shifts the bits of the number to the left and fills 0 on voids left as a result. Similar effect as of multiplying the number with some power of two. a = 10 #1010(Binary) b = 4 #0100(Binary) # Print bitwise AND operation print ( \"a & b =\" , a & b ) #0000(Binary) # Print bitwise OR operation print ( \"a | b =\" , a | b ) #1110(Binary)=14(Decimal) # Print bitwise NOT operation print ( \"~a =\" , ~ a ) #-(1010+1)(Binary)=-(1011)=-11(Decimal) # print bitwise XOR operation print ( \"a ^ b =\" , a ^ b ) # 1110(Binary)=14(Decimal) a = 10 b = - 10 # print bitwise right shift operator print ( \"a >> 1 =\" , a >> 1 ) print ( \"b >> 1 =\" , b >> 1 ) a = 5 b = - 10 # print bitwise left shift operator print ( \"a << 1 =\" , a << 1 ) print ( \"b << 1 =\" , b << 1 ) #Hexidecimal x = 0x0a y = 0x02 z = x & y print ( f '(hex) x is { x : 02x } , y is { y : 02x } , z is { z : 02x } ' ) print ( f '(bin) x is { x : 08b } , y is { y : 08b } , z is { z : 08b } ' ) z = x << y print ( f '(bin) x is { x : 08b } , y is { y : 08b } , z is { z : 08b } ' ) a & b = 0 a | b = 14 ~a = -11 a ^ b = 14 a >> 1 = 5 b >> 1 = -5 a << 1 = 10 b << 1 = -20 (hex) x is 0a, y is 02, z is 02 (bin) x is 00001010, y is 00000010, z is 00000010 (bin) x is 00001010, y is 00000010, z is 00101000","title":"Bitwise left shift"},{"location":"PR/pyOp3/","text":"In-place operators allow you to write code like 'x = x + 3' more concisely, as 'x += 3'. In-place operators can be used for any numerical operation (+, -, , /, %, *, //). These operators can be used on types other than numbers, as well, such as strings. x = 2 x += 3 print ( x ) x *= 7 print ( x ) y = \"spam \" y *= 3 print ( y ) 5 35 spam spam spam","title":"In-Place"},{"location":"PR/pyOp4/","text":"Walrus operator := allows you to assign values to variables within an expression, including variables that do not exist yet. Let's suppose we want to take an integer from the user, assign it to a variable num and output it. The walrus operator accomplishes these operations at once. The walrus operator makes code more readable and can be useful in many situations. num = int ( input ()) print ( num ) #The same but using Walrus operator #Python 3.8 up print ( num := int ( input ()))","title":"Walrus"},{"location":"PR/pyOp5/","text":"Boolean type . There are two Boolean values: True and False. They can be created by comparing values, for instance by using the equal operator ==. a = True print ( a ) b = ( 1 == 3 ) print ( b ) True False -1 Comparison operators are also called Relational operators . There are != , <, <=, >, >=. Used to compare strings lexicographically print ( 3 != 2 ) print ( 8 <= 9.0 ) #different types, no problem! print ( 'Carlos' > 'Ana' ) True True True Boolean logic is used to make more complicated conditions for if statements that rely on more than one condition. Python's Boolean operators are and , or , not , in , not in , is and, is not . print ( 1 == 1 and 3 > 4 ) print ( 1 == 1 or 3 > 4 ) print ( 1 == 2 and not 3 > 4 ) x = ( 'bear' , 'bunny' , 'tree' ) y = 'bear' print ( y in x ) print ( y not in x ) print ( y is x [ 0 ]) #same id print ( id ( y )) print ( id ( x [ 0 ])) False True False True False True 140097849021808 140097849021808","title":"Comparison"},{"location":"PR/pyOp6/","text":"The Operator, @ In the context of matrix multiplication, a @ b invokes a.__matmul__(b) - making this syntax: a @ b equivalent to dot(a, b) and a @= b equivalent to a = dot(a, b) where dot is, for example, the numpy matrix multiplication function and a and b are matrices.","title":"/@"},{"location":"PR/pyOp7/","text":"(Star) * Operator The single star * unpacks the sequence/collection into positional arguments, so you can do this: def sum ( a , b ): return a + b values = ( 1 , 2 ) s = sum ( * values ) print ( s ) s = sum ( 1 , 2 ) #The same print ( s ) 3 3 The double star ** does the same, only using a dictionary and thus named arguments: values = { 'a' : 1 , 'b' : 2 } s = sum ( ** values ) print ( s ) 3 Combining the two: def sum ( a , b , c , d ): return a + b + c + d values1 = ( 1 , 2 ) values2 = { 'c' : 10 , 'd' : 15 } s = sum ( * values1 , ** values2 ) print ( s ) # the same as s = sum ( 1 , 2 , c = 10 , d = 15 ) print ( s ) 28 28 Additionally you can define functions to take x and *y arguments, this allows a function to accept any number of positional and/or named arguments that aren't specifically named in the declaration. def sum ( * values ): s = 0 for v in values : s = s + v return s s = sum ( 1 , 2 , 3 , 4 , 5 ) print ( s ) 15 or with ** def get_a ( ** values ): return values [ 'a' ] s = get_a ( a = 1 , b = 2 ) # returns 1 print ( s ) 1 this can allow you to specify a large number of optional parameters without having to declare them. And again, you can combine: def sum ( * values , ** options ): s = 0 for i in values : s = s + i if \"neg\" in options : if options [ \"neg\" ]: s = - s return s s = sum ( 1 , 2 , 3 , 4 , 5 ) # returns 15 s = sum ( 1 , 2 , 3 , 4 , 5 , neg = True ) # returns -15 s = sum ( 1 , 2 , 3 , 4 , 5 , neg = False ) # returns 15","title":"(star) *"},{"location":"PR/pyOp7/#star-operator","text":"The single star * unpacks the sequence/collection into positional arguments, so you can do this: def sum ( a , b ): return a + b values = ( 1 , 2 ) s = sum ( * values ) print ( s ) s = sum ( 1 , 2 ) #The same print ( s ) 3 3 The double star ** does the same, only using a dictionary and thus named arguments: values = { 'a' : 1 , 'b' : 2 } s = sum ( ** values ) print ( s ) 3 Combining the two: def sum ( a , b , c , d ): return a + b + c + d values1 = ( 1 , 2 ) values2 = { 'c' : 10 , 'd' : 15 } s = sum ( * values1 , ** values2 ) print ( s ) # the same as s = sum ( 1 , 2 , c = 10 , d = 15 ) print ( s ) 28 28 Additionally you can define functions to take x and *y arguments, this allows a function to accept any number of positional and/or named arguments that aren't specifically named in the declaration. def sum ( * values ): s = 0 for v in values : s = s + v return s s = sum ( 1 , 2 , 3 , 4 , 5 ) print ( s ) 15 or with ** def get_a ( ** values ): return values [ 'a' ] s = get_a ( a = 1 , b = 2 ) # returns 1 print ( s ) 1 this can allow you to specify a large number of optional parameters without having to declare them. And again, you can combine: def sum ( * values , ** options ): s = 0 for i in values : s = s + i if \"neg\" in options : if options [ \"neg\" ]: s = - s return s s = sum ( 1 , 2 , 3 , 4 , 5 ) # returns 15 s = sum ( 1 , 2 , 3 , 4 , 5 , neg = True ) # returns -15 s = sum ( 1 , 2 , 3 , 4 , 5 , neg = False ) # returns 15","title":"(Star) * Operator"},{"location":"PR/pyStr1/","text":"Backslashes can also be used to escape tabs or arbitrary Unicode characters. \\n represents a new line. Similarly, \\t represents a tab. Newlines will be automatically added for strings that are created using three quotes. This makes it easier to format long, multi-line texts without the need to explicitly put \\n for line breaks. print ( \"Hugo \\' s house \\n Jane \\' s mother \\t Diana \\' s dog\" ) print ( \"\"\"This is multline text\"\"\" ) print ( \"That's \\\" cool \\\" \" ) print ( \"Look, a mountain: / \\\\ \" ) print ( \"1 \\n 2 3\" ) Hugo's house Jane's mother Diana's dog This is multline text That's \"cool\" Look, a mountain: /\\ 1 2 3","title":"Backslashes"},{"location":"PR/pyStr2/","text":"String Operations : (+) concatenation (*) multiplication - Strings can also be multiplied by integers. This produces a repeated version of the original string. User Input : The input function prompts the user for input, and returns what they enter as a string print ( \"spam\" + \" eggs\" ) print ( \"spam \" * 3 ) name = input ( \"your name is?\" ) print ( \"Hello \" + name ) spam eggs spam spam spam your name is?Carlos Hello Carlos","title":"String operations"},{"location":"PR/pyStr3/","text":"str.format() String formatting uses a string's format method to substitute a number of arguments in the string. Each argument of the format function is placed in the string at the corresponding position, which is determined using the curly braces { }. # String formatting nums = [ 1 , 2 , 3 ] msg = \"Numbers {0} {1} {2} \" . format ( nums [ 1 ], nums [ 0 ], nums [ 2 ]) print ( msg ) Numbers 2 1 3 String formatting can also be done with named arguments. a = \" {x} , {y} \" . format ( y = 12 , x = 4 ) print ( a ) 4 , 12 x = 42 print ( 'The number is {:b} ' . format ( x )) The number is 101010 count(str) returns how many times the str substring appears in the given string. upper() converts the string to uppercase. lower() converts the string to lowercase. replace(old, new) replaces all occurrences of old with new. len(str) returns the length of the string (number of characters). Note, that these functions return a new string with the corresponding manipulation Fstrings (Literal String Interpolation) After Python 3.6, to create an f-string, prefix the string with the letter \u201c f \u201d. The string itself can be formatted in much the same way that you would with str.format(). F-strings provide a concise and convenient way to embed python expressions inside string literals for formatting. Simply it is a shortcut for the format method. # Prints today's date with help # of datetime library import datetime today = datetime . datetime . today () print ( f \" { today : %B %d, %Y } \" ) July 30, 2021 name = \"Eric Idle\" f \" { name . lower () } is funny.\" eric idle is funny. x = 42 print ( f 'The number is { x : b } ' ) The number is 101010 name = 'CarPool' age = 23 print ( f \"Hello, My name is { name } and I'm { age } years old.\" ) Hello, My name is CarPool and I'm 23 years old. Template string from string import Template def main (): # Usual string formatting with format() str1 = \"Love {0} and {1} \" . format ( \"Pollo\" , \"Pitas\" ) print ( str1 ) # create a template with placeholders templ = Template ( \"Love $ {title} and $ {author} \" ) # use the substitute method with keyword arguments str2 = templ . substitute ( title = \"Pollo\" , author = \"Pitas\" ) print ( str2 ) # use the substitute method with a dictionary data = { \"author\" : \"Pitas\" , \"title\" : \"Pollo\" } str3 = templ . substitute ( data ) print ( str3 ) if __name__ == \"__main__\" : main () Love Pollo and Pitas Love Pollo and Pitas Love Pollo and Pitas","title":"String formatting"},{"location":"PR/pyStr3/#strformat","text":"String formatting uses a string's format method to substitute a number of arguments in the string. Each argument of the format function is placed in the string at the corresponding position, which is determined using the curly braces { }. # String formatting nums = [ 1 , 2 , 3 ] msg = \"Numbers {0} {1} {2} \" . format ( nums [ 1 ], nums [ 0 ], nums [ 2 ]) print ( msg ) Numbers 2 1 3 String formatting can also be done with named arguments. a = \" {x} , {y} \" . format ( y = 12 , x = 4 ) print ( a ) 4 , 12 x = 42 print ( 'The number is {:b} ' . format ( x )) The number is 101010 count(str) returns how many times the str substring appears in the given string. upper() converts the string to uppercase. lower() converts the string to lowercase. replace(old, new) replaces all occurrences of old with new. len(str) returns the length of the string (number of characters). Note, that these functions return a new string with the corresponding manipulation","title":"str.format()"},{"location":"PR/pyStr3/#fstrings-literal-string-interpolation","text":"After Python 3.6, to create an f-string, prefix the string with the letter \u201c f \u201d. The string itself can be formatted in much the same way that you would with str.format(). F-strings provide a concise and convenient way to embed python expressions inside string literals for formatting. Simply it is a shortcut for the format method. # Prints today's date with help # of datetime library import datetime today = datetime . datetime . today () print ( f \" { today : %B %d, %Y } \" ) July 30, 2021 name = \"Eric Idle\" f \" { name . lower () } is funny.\" eric idle is funny. x = 42 print ( f 'The number is { x : b } ' ) The number is 101010 name = 'CarPool' age = 23 print ( f \"Hello, My name is { name } and I'm { age } years old.\" ) Hello, My name is CarPool and I'm 23 years old.","title":"Fstrings (Literal String Interpolation)"},{"location":"PR/pyStr3/#template-string","text":"from string import Template def main (): # Usual string formatting with format() str1 = \"Love {0} and {1} \" . format ( \"Pollo\" , \"Pitas\" ) print ( str1 ) # create a template with placeholders templ = Template ( \"Love $ {title} and $ {author} \" ) # use the substitute method with keyword arguments str2 = templ . substitute ( title = \"Pollo\" , author = \"Pitas\" ) print ( str2 ) # use the substitute method with a dictionary data = { \"author\" : \"Pitas\" , \"title\" : \"Pollo\" } str3 = templ . substitute ( data ) print ( str3 ) if __name__ == \"__main__\" : main () Love Pollo and Pitas Love Pollo and Pitas Love Pollo and Pitas","title":"Template string"},{"location":"PR/pyStr4/","text":"\u201c Format specifications \u201d are used within replacement fields contained within a format string to define how individual values are presented A general convention is that an empty format specification produces the same result as if you had called str() on the value. A non-empty format specification typically modifies the result. The general form of a standard format specifier is: format_spec [[fill]align][sign][#][0][width][grouping_option][.precision][type] fill any character align \"<\" , \">\" , \"=\" , \"^\" sign \"+\" , \"-\" , \" \" width digit+ grouping_option \"_\" , \",\" precision digit+ type \"b\", \"c\" , \"d\" , \"e\" , \"E\" , \"f\" , \"F\" , \"g\" , \"G\" , \"n\" , \"o\" , \"s\" , \"x\" , \"X\" , \"%\" Fill If a valid align value is specified, it can be preceded by a fill character that can be any character and defaults to a space if omitted. It is not possible to use a literal curly brace (\u201c{\u201d or \u201c}\u201d) as the fill character in a formatted string literal or when using the str.format() method. However, it is possible to insert a curly brace with a nested replacement field. This limitation doesn\u2019t affect the format() function. Align The meaning of the various alignment options is as follows: Option Meaning '<' Forces the field to be left-aligned within the available space (this is the default for most objects) '>' Forces the field to be right-aligned within the available space (this is the default for numbers) '=' Forces the padding to be placed after the sign (if any) but before the digits. This is used for printing fields in the form \u2018+000000120\u2019. This alignment option is only valid for numeric types. It becomes the default for numbers when \u20180\u2019 immediately precedes the field width '^' Forces the field to be centered within the available space ' {:>30} ' . format ( 'right aligned' ) right aligned ' {:*^30} ' . format ( 'centered' ) # use '*' as a fill char ***********centered*********** Sign Note that unless a minimum field width is defined, the field width will always be the same size as the data to fill it, so that the alignment option has no meaning in this case. The sign option is only valid for number types, and can be one of the following: Option Meaning '+' indicates that a sign should be used for both positive as well as negative numbers. '-' indicates that a sign should be used only for negative numbers (this is the default behavior). space indicates that a leading space should be used on positive numbers, and a minus sign on negative numbers. ' {:+f} ; {:+f} ' . format ( 3.14 , - 3.14 ) # show it always +3.140000; -3.140000 ' {: f} ; {: f} ' . format ( 3.14 , - 3.14 ) # show a space for positive numbers 3.140000; -3.140000 ' {:-f} ; {:-f} ' . format ( 3.14 , - 3.14 ) # show only the minus -- same as '{:f}; {:f}' 3.140000; -3.140000 # and , and _ Option '#' option The '#' option causes the \u201calternate form\u201d to be used for the conversion. The alternate form is defined differently for different types. This option is only valid for integer, float and complex types. For integers, when binary, octal, or hexadecimal output is used, this option adds the respective prefix '0b', '0o', '0x', or '0X' to the output value. For float and complex the alternate form causes the result of the conversion to always contain a decimal-point character, even if no digits follow it. Normally, a decimal-point character appears in the result of these conversions only if a digit follows it. In addition, for 'g' and 'G' conversions, trailing zeros are not removed from the result. 'Integer in Octal: {:#o} ' . format ( 1234567 ) Correct answers: 0o4553207 'Integer in Octal: {:o} ' . format ( 1234567 ) Correct answers: 4553207 ',' option The ',' option signals the use of a comma for a thousands separator. For a locale aware separator, use the 'n' integer presentation type instead. see PEP378 ' {:,} ' . format ( 1234567890 ) 1,234,567,890 format ( 1234.5 , \"08,.1f\" ) 01,234.5 '_' option The '_' option signals the use of an underscore for a thousands separator for floating point presentation types and for integer presentation type 'd'. For integer presentation types 'b', 'o', 'x', and 'X', underscores will be inserted every 4 digits. For other presentation types, specifying this option is an error. #{:10_} for a width of 10 with _ separator. format ( 1234.5 , \"08_.1f\" ) 01_234.5 Width width is a decimal integer defining the minimum total field width, including any prefixes, separators, and other formatting characters. If not specified, then the field width will be determined by the content. When no explicit alignment is given, preceding the width field by a zero ('0') character enables sign-aware zero-padding for numeric types. This is equivalent to a fill character of '0' with an alignment type of '='. Changed in version 3.10: Preceding the width field by '0' no longer affects the default alignment for strings. Precision The precision is a decimal integer indicating how many digits should be displayed after the decimal point for presentation types 'f' and 'F', or before and after the decimal point for presentation types 'g' or 'G'. For string presentation types the field indicates the maximum field size - in other words, how many characters will be used from the field content. The precision is not allowed for integer presentation types. points = 19 total = 22 'Correct answers: {:.2%} ' . format ( points / total ) Correct answers: 86.36% Type The type determines how the data should be presented. for strings The available string presentation types are: Type Meaning 's' String format. This is the default type for strings and may be omitted. None The same as 's'. for integers The available integer presentation types are: Type Meaning 'b' Binary format. Outputs the number in base 2. 'c' Character. Converts the integer to the corresponding unicode character before printing. 'd' Octal format. Outputs the number in base 8. 'o' Character. Converts the integer to the corresponding unicode character before printing. 'x' Hex format. Outputs the number in base 16, using lower-case letters for the digits above 9. 'X' Hex format. Outputs the number in base 16, using upper-case letters for the digits above 9. In case '#' is specified, the prefix '0x' will be upper-cased to '0X' as well. 'n' Number. This is the same as 'd', except that it uses the current locale setting to insert the appropriate number separator characters. None The same as 'd'. In addition to the above presentation types, integers can be formatted with the floating point presentation types listed below (except 'n' and None). When doing so, float() is used to convert the integer to a floating point number before formatting. for float and decimal The available presentation types for float and Decimal values are: Type Meaning 'e' Scientific notation. For a given precision p, formats the number in scientific notation with the letter \u2018e\u2019 separating the coefficient from the exponent. The coefficient has one digit before and p digits after the decimal point, for a total of p + 1 significant digits. With no precision given, uses a precision of 6 digits after the decimal point for float, and shows all coefficient digits for Decimal. If no digits follow the decimal point, the decimal point is also removed unless the # option is used. 'E' Scientific notation. Same as 'e' except it uses an upper case \u2018E\u2019 as the separator character. 'f' Fixed-point notation. For a given precision p, formats the number as a decimal number with exactly p digits following the decimal point. With no precision given, uses a precision of 6 digits after the decimal point for float, and uses a precision large enough to show all coefficient digits for Decimal. If no digits follow the decimal point, the decimal point is also removed unless the # option is used. 'F' Fixed-point notation. Same as 'f', but converts nan to NAN and inf to INF. 'g' General format. For a given precision p >= 1, this rounds the number to p significant digits and then formats the result in either fixed-point format or in scientific notation, depending on its magnitude. A precision of 0 is treated as equivalent to a precision of 1. The precise rules are as follows: suppose that the result formatted with presentation type 'e' and precision p-1 would have exponent exp. Then, if m <= exp < p, where m is -4 for floats and -6 for Decimals, the number is formatted with presentation type 'f' and precision p-1-exp. Otherwise, the number is formatted with presentation type 'e' and precision p-1. In both cases insignificant trailing zeros are removed from the significand, and the decimal point is also removed if there are no remaining digits following it, unless the '#' option is used. With no precision given, uses a precision of 6 significant digits for float. For Decimal, the coefficient of the result is formed from the coefficient digits of the value; scientific notation is used for values smaller than 1e-6 in absolute value and values where the place value of the least significant digit is larger than 1, and fixed-point notation is used otherwise. Positive and negative infinity, positive and negative zero, and nans, are formatted as inf, -inf, 0, -0 and nan respectively, regardless of the precision. 'G' General format. Same as 'g' except switches to 'E' if the number gets too large. The representations of infinity and NaN are uppercased, too. 'n' Number. This is the same as 'g', except that it uses the current locale setting to insert the appropriate number separator characters. '%' Percentage. Multiplies the number by 100 and displays in fixed ('f') format, followed by a percent sign. None For float this is the same as 'g', except that when fixed-point notation is used to format the result, it always includes at least one digit past the decimal point. The precision used is as large as needed to represent the given value faithfully. For Decimal, this is the same as either 'g' or 'G' depending on the value of context.capitals for the current decimal context. The overall effect is to match the output of str() as altered by the other format modifiers.","title":"String formatting specifications"},{"location":"PR/pyStr4/#fill","text":"If a valid align value is specified, it can be preceded by a fill character that can be any character and defaults to a space if omitted. It is not possible to use a literal curly brace (\u201c{\u201d or \u201c}\u201d) as the fill character in a formatted string literal or when using the str.format() method. However, it is possible to insert a curly brace with a nested replacement field. This limitation doesn\u2019t affect the format() function.","title":"Fill"},{"location":"PR/pyStr4/#align","text":"The meaning of the various alignment options is as follows: Option Meaning '<' Forces the field to be left-aligned within the available space (this is the default for most objects) '>' Forces the field to be right-aligned within the available space (this is the default for numbers) '=' Forces the padding to be placed after the sign (if any) but before the digits. This is used for printing fields in the form \u2018+000000120\u2019. This alignment option is only valid for numeric types. It becomes the default for numbers when \u20180\u2019 immediately precedes the field width '^' Forces the field to be centered within the available space ' {:>30} ' . format ( 'right aligned' ) right aligned ' {:*^30} ' . format ( 'centered' ) # use '*' as a fill char ***********centered***********","title":"Align"},{"location":"PR/pyStr4/#sign","text":"Note that unless a minimum field width is defined, the field width will always be the same size as the data to fill it, so that the alignment option has no meaning in this case. The sign option is only valid for number types, and can be one of the following: Option Meaning '+' indicates that a sign should be used for both positive as well as negative numbers. '-' indicates that a sign should be used only for negative numbers (this is the default behavior). space indicates that a leading space should be used on positive numbers, and a minus sign on negative numbers. ' {:+f} ; {:+f} ' . format ( 3.14 , - 3.14 ) # show it always +3.140000; -3.140000 ' {: f} ; {: f} ' . format ( 3.14 , - 3.14 ) # show a space for positive numbers 3.140000; -3.140000 ' {:-f} ; {:-f} ' . format ( 3.14 , - 3.14 ) # show only the minus -- same as '{:f}; {:f}' 3.140000; -3.140000","title":"Sign"},{"location":"PR/pyStr4/#and-and-_-option","text":"","title":"# and , and _ Option"},{"location":"PR/pyStr4/#option","text":"The '#' option causes the \u201calternate form\u201d to be used for the conversion. The alternate form is defined differently for different types. This option is only valid for integer, float and complex types. For integers, when binary, octal, or hexadecimal output is used, this option adds the respective prefix '0b', '0o', '0x', or '0X' to the output value. For float and complex the alternate form causes the result of the conversion to always contain a decimal-point character, even if no digits follow it. Normally, a decimal-point character appears in the result of these conversions only if a digit follows it. In addition, for 'g' and 'G' conversions, trailing zeros are not removed from the result. 'Integer in Octal: {:#o} ' . format ( 1234567 ) Correct answers: 0o4553207 'Integer in Octal: {:o} ' . format ( 1234567 ) Correct answers: 4553207","title":"'#' option"},{"location":"PR/pyStr4/#option_1","text":"The ',' option signals the use of a comma for a thousands separator. For a locale aware separator, use the 'n' integer presentation type instead. see PEP378 ' {:,} ' . format ( 1234567890 ) 1,234,567,890 format ( 1234.5 , \"08,.1f\" ) 01,234.5","title":"',' option"},{"location":"PR/pyStr4/#_-option","text":"The '_' option signals the use of an underscore for a thousands separator for floating point presentation types and for integer presentation type 'd'. For integer presentation types 'b', 'o', 'x', and 'X', underscores will be inserted every 4 digits. For other presentation types, specifying this option is an error. #{:10_} for a width of 10 with _ separator. format ( 1234.5 , \"08_.1f\" ) 01_234.5","title":"'_' option"},{"location":"PR/pyStr4/#width","text":"width is a decimal integer defining the minimum total field width, including any prefixes, separators, and other formatting characters. If not specified, then the field width will be determined by the content. When no explicit alignment is given, preceding the width field by a zero ('0') character enables sign-aware zero-padding for numeric types. This is equivalent to a fill character of '0' with an alignment type of '='. Changed in version 3.10: Preceding the width field by '0' no longer affects the default alignment for strings.","title":"Width"},{"location":"PR/pyStr4/#precision","text":"The precision is a decimal integer indicating how many digits should be displayed after the decimal point for presentation types 'f' and 'F', or before and after the decimal point for presentation types 'g' or 'G'. For string presentation types the field indicates the maximum field size - in other words, how many characters will be used from the field content. The precision is not allowed for integer presentation types. points = 19 total = 22 'Correct answers: {:.2%} ' . format ( points / total ) Correct answers: 86.36%","title":"Precision"},{"location":"PR/pyStr4/#type","text":"The type determines how the data should be presented.","title":"Type"},{"location":"PR/pyStr4/#for-strings","text":"The available string presentation types are: Type Meaning 's' String format. This is the default type for strings and may be omitted. None The same as 's'.","title":"for strings"},{"location":"PR/pyStr4/#for-integers","text":"The available integer presentation types are: Type Meaning 'b' Binary format. Outputs the number in base 2. 'c' Character. Converts the integer to the corresponding unicode character before printing. 'd' Octal format. Outputs the number in base 8. 'o' Character. Converts the integer to the corresponding unicode character before printing. 'x' Hex format. Outputs the number in base 16, using lower-case letters for the digits above 9. 'X' Hex format. Outputs the number in base 16, using upper-case letters for the digits above 9. In case '#' is specified, the prefix '0x' will be upper-cased to '0X' as well. 'n' Number. This is the same as 'd', except that it uses the current locale setting to insert the appropriate number separator characters. None The same as 'd'. In addition to the above presentation types, integers can be formatted with the floating point presentation types listed below (except 'n' and None). When doing so, float() is used to convert the integer to a floating point number before formatting.","title":"for integers"},{"location":"PR/pyStr4/#for-float-and-decimal","text":"The available presentation types for float and Decimal values are: Type Meaning 'e' Scientific notation. For a given precision p, formats the number in scientific notation with the letter \u2018e\u2019 separating the coefficient from the exponent. The coefficient has one digit before and p digits after the decimal point, for a total of p + 1 significant digits. With no precision given, uses a precision of 6 digits after the decimal point for float, and shows all coefficient digits for Decimal. If no digits follow the decimal point, the decimal point is also removed unless the # option is used. 'E' Scientific notation. Same as 'e' except it uses an upper case \u2018E\u2019 as the separator character. 'f' Fixed-point notation. For a given precision p, formats the number as a decimal number with exactly p digits following the decimal point. With no precision given, uses a precision of 6 digits after the decimal point for float, and uses a precision large enough to show all coefficient digits for Decimal. If no digits follow the decimal point, the decimal point is also removed unless the # option is used. 'F' Fixed-point notation. Same as 'f', but converts nan to NAN and inf to INF. 'g' General format. For a given precision p >= 1, this rounds the number to p significant digits and then formats the result in either fixed-point format or in scientific notation, depending on its magnitude. A precision of 0 is treated as equivalent to a precision of 1. The precise rules are as follows: suppose that the result formatted with presentation type 'e' and precision p-1 would have exponent exp. Then, if m <= exp < p, where m is -4 for floats and -6 for Decimals, the number is formatted with presentation type 'f' and precision p-1-exp. Otherwise, the number is formatted with presentation type 'e' and precision p-1. In both cases insignificant trailing zeros are removed from the significand, and the decimal point is also removed if there are no remaining digits following it, unless the '#' option is used. With no precision given, uses a precision of 6 significant digits for float. For Decimal, the coefficient of the result is formed from the coefficient digits of the value; scientific notation is used for values smaller than 1e-6 in absolute value and values where the place value of the least significant digit is larger than 1, and fixed-point notation is used otherwise. Positive and negative infinity, positive and negative zero, and nans, are formatted as inf, -inf, 0, -0 and nan respectively, regardless of the precision. 'G' General format. Same as 'g' except switches to 'E' if the number gets too large. The representations of infinity and NaN are uppercased, too. 'n' Number. This is the same as 'g', except that it uses the current locale setting to insert the appropriate number separator characters. '%' Percentage. Multiplies the number by 100 and displays in fixed ('f') format, followed by a percent sign. None For float this is the same as 'g', except that when fixed-point notation is used to format the result, it always includes at least one digit past the decimal point. The precision used is as large as needed to represent the given value faithfully. For Decimal, this is the same as either 'g' or 'G' depending on the value of context.capitals for the current decimal context. The overall effect is to match the output of str() as altered by the other format modifiers.","title":"for float and decimal"},{"location":"PR/pyStr5/","text":"Python contains many useful built-in functions and methods to accomplish common tasks. join joins a list of strings with another string as a separator. print ( \", \" . join ([ \"spam\" , \"eggs\" , \"ham\" ])) spam, eggs, ham replace replaces one substring in a string with another. print ( \"Hello Me\" . replace ( \"Me\" , \"Ham\" )) Hello Ham startswith and endswith determine if there is a substring at the start and end of a string, respectively. find and rfind search for a substr in a larger str. returns the index or -1 if not found. rfind starts from the right end to search. (Use the in operator for boolean result) print ( \"Hello Me\" . find ( 'lo' )) print ( \"Hello Me\" . find ( 'lop' )) print ( \"Hello Me\" . rfind ( 'lo' )) print ( \"lo\" in \"Hello Me\" ) 3 -1 3 True lower and upper To change the case of a string, you can use lower and upper. split is the opposite of join turning a string with a certain separator into a list. print ( \"spam, eggs, ham\" . split ( \", \" )) ['spam', 'eggs', 'ham'] count to count the number of times a substring is present. print ( \"Me Hello Me\" . count ( \"Me\" )) print ( \"Me Hello Me\" . count ( \"Meh\" )) 2 0","title":"String functions"},{"location":"PR/pyStr5/#join","text":"joins a list of strings with another string as a separator. print ( \", \" . join ([ \"spam\" , \"eggs\" , \"ham\" ])) spam, eggs, ham","title":"join"},{"location":"PR/pyStr5/#replace","text":"replaces one substring in a string with another. print ( \"Hello Me\" . replace ( \"Me\" , \"Ham\" )) Hello Ham","title":"replace"},{"location":"PR/pyStr5/#startswith-and-endswith","text":"determine if there is a substring at the start and end of a string, respectively.","title":"startswith and endswith"},{"location":"PR/pyStr5/#find-and-rfind","text":"search for a substr in a larger str. returns the index or -1 if not found. rfind starts from the right end to search. (Use the in operator for boolean result) print ( \"Hello Me\" . find ( 'lo' )) print ( \"Hello Me\" . find ( 'lop' )) print ( \"Hello Me\" . rfind ( 'lo' )) print ( \"lo\" in \"Hello Me\" ) 3 -1 3 True","title":"find and rfind"},{"location":"PR/pyStr5/#lower-and-upper","text":"To change the case of a string, you can use lower and upper.","title":"lower and upper"},{"location":"PR/pyStr5/#split","text":"is the opposite of join turning a string with a certain separator into a list. print ( \"spam, eggs, ham\" . split ( \", \" )) ['spam', 'eggs', 'ham']","title":"split"},{"location":"PR/pyStr5/#count","text":"to count the number of times a substring is present. print ( \"Me Hello Me\" . count ( \"Me\" )) print ( \"Me Hello Me\" . count ( \"Meh\" )) 2 0","title":"count"},{"location":"PR/pyVar1/","text":"In Python, we store all pieces of data -- numbers, characters, strings, everything -- as objects, and we refer to these objects using variables. As a simple case, we can assign a variable a value using the assignment operator, which is the \"equals\" sign. Python's order of operations is the same as that of normal mathematics: parentheses first, then exponentiation, then multiplication/division, and then addition/subtraction. x = 4 y = 5 z = x + y print ( z ) stri = \"Hello\" # or stri='Hello' No difference in python between \"\" and '' print ( stri + str ( z )) a = True print ( a ) b = ( 1 == 3 ) print ( b ) 9 Hello9 True False Three tools for understanding strange objects type() function type() (what is this thing?) To inspect which type is a variable use type(). dir() function dir() (what can I do with it?) help() function help() (tell me more) print ( type ( z )) print ( type ( a )) print ( type ( stri )) print ( dir ( 2 )) #print(help(2)) <class 'int'> <class 'int'> <class 'str'> ['__abs__', '__add__', '__and__', '__bool__', '__ceil__', '__class__', '__delattr__', '__dir__', '__divmod__', '__doc__', '__eq__', '__float__', '__floor__', '__floordiv__', '__format__', '__ge__', '__getattribute__', '__getnewargs__', '__gt__', '__hash__', '__index__', '__init__', '__init_subclass__', '__int__', '__invert__', '__le__', '__lshift__', '__lt__', '__mod__', '__mul__', '__ne__', '__neg__', '__new__', '__or__', '__pos__', '__pow__', '__radd__', '__rand__', '__rdivmod__', '__reduce__', '__reduce_ex__', '__repr__', '__rfloordiv__', '__rlshift__', '__rmod__', '__rmul__', '__ror__', '__round__', '__rpow__', '__rrshift__', '__rshift__', '__rsub__', '__rtruediv__', '__rxor__', '__setattr__', '__sizeof__', '__str__', '__sub__', '__subclasshook__', '__truediv__', '__trunc__', '__xor__', 'bit_length', 'conjugate', 'denominator', 'from_bytes', 'imag', 'numerator', 'real', 'to_bytes'] Python supports addition (+), substraction(-), multiplication( ), division(/),exponentiation( *), quotient (//) and remainder(%). You can chain exponentiations together. In other words, you can rise a number to multiple powers. id() function The id() function returns identity (unique integer) of an object. print ( 'id of 5 =' , id ( 5 )) a = 5 print ( 'id of a =' , id ( a )) b = a print ( 'id of b =' , id ( b )) c = 5.0 print ( 'id of c =' , id ( c )) id of 5 = 94364870744704 id of a = 94364870744704 id of b = 94364870744704 id of c = 140097885531312 It's important to note that everything in Python is an object, even numbers, and Classes. Hence, integer 5 has a unique id. The id of the integer 5 remains constant during the lifetime. Similar is the case for float 5.5 and other objects. isinstance() function To verify the type of an object, the isinstance() function checks if the object (first argument) is an instance or subclass of classinfo class (second argument). The None Object The None object is used to represent the absence of a value. It is similar to null in other programming languages. The None object is returned by any function that doesn't explicitly return anything else.","title":"Variables"},{"location":"PR/pyVar1/#three-tools-for-understanding-strange-objects","text":"","title":"Three tools for understanding strange objects"},{"location":"PR/pyVar1/#type-function","text":"type() (what is this thing?) To inspect which type is a variable use type().","title":"type() function"},{"location":"PR/pyVar1/#dir-function","text":"dir() (what can I do with it?)","title":"dir() function"},{"location":"PR/pyVar1/#help-function","text":"help() (tell me more) print ( type ( z )) print ( type ( a )) print ( type ( stri )) print ( dir ( 2 )) #print(help(2)) <class 'int'> <class 'int'> <class 'str'> ['__abs__', '__add__', '__and__', '__bool__', '__ceil__', '__class__', '__delattr__', '__dir__', '__divmod__', '__doc__', '__eq__', '__float__', '__floor__', '__floordiv__', '__format__', '__ge__', '__getattribute__', '__getnewargs__', '__gt__', '__hash__', '__index__', '__init__', '__init_subclass__', '__int__', '__invert__', '__le__', '__lshift__', '__lt__', '__mod__', '__mul__', '__ne__', '__neg__', '__new__', '__or__', '__pos__', '__pow__', '__radd__', '__rand__', '__rdivmod__', '__reduce__', '__reduce_ex__', '__repr__', '__rfloordiv__', '__rlshift__', '__rmod__', '__rmul__', '__ror__', '__round__', '__rpow__', '__rrshift__', '__rshift__', '__rsub__', '__rtruediv__', '__rxor__', '__setattr__', '__sizeof__', '__str__', '__sub__', '__subclasshook__', '__truediv__', '__trunc__', '__xor__', 'bit_length', 'conjugate', 'denominator', 'from_bytes', 'imag', 'numerator', 'real', 'to_bytes'] Python supports addition (+), substraction(-), multiplication( ), division(/),exponentiation( *), quotient (//) and remainder(%). You can chain exponentiations together. In other words, you can rise a number to multiple powers.","title":"help() function"},{"location":"PR/pyVar1/#id-function","text":"The id() function returns identity (unique integer) of an object. print ( 'id of 5 =' , id ( 5 )) a = 5 print ( 'id of a =' , id ( a )) b = a print ( 'id of b =' , id ( b )) c = 5.0 print ( 'id of c =' , id ( c )) id of 5 = 94364870744704 id of a = 94364870744704 id of b = 94364870744704 id of c = 140097885531312 It's important to note that everything in Python is an object, even numbers, and Classes. Hence, integer 5 has a unique id. The id of the integer 5 remains constant during the lifetime. Similar is the case for float 5.5 and other objects.","title":"id() function"},{"location":"PR/pyVar1/#isinstance-function","text":"To verify the type of an object, the isinstance() function checks if the object (first argument) is an instance or subclass of classinfo class (second argument).","title":"isinstance() function"},{"location":"PR/pyVar1/#the-none-object","text":"The None object is used to represent the absence of a value. It is similar to null in other programming languages. The None object is returned by any function that doesn't explicitly return anything else.","title":"The None Object"},{"location":"PR/pyVar2/","text":"int() function:To convert it to a number str() function:To convert it to a string float() function: To convert it to a float bool() function: To convert it to a bool age = int ( input ()) print ( \"Your age is \" + str ( age ) + \" years old\" ) 15 Your age is 15 years old numbers = [ 1 , 2 , 3 , 4 , 2 , 5 ] # check if numbers is instance of list result = isinstance ( numbers , list ) print ( result ) True","title":"Type Casting"},{"location":"PR/pyVar3/","text":"The location where we can find a variable and also access it if required is called the scope of a variable. Python resolves names using the so-called LEGB rule, which is named after the Python scope for names. The letters in LEGB stand for Local, Enclosing, Global, and Built-in. When you use nested functions, names are resolved by first checking the local scope or the innermost function\u2019s local scope. Then, Python looks at all enclosing scopes of outer functions from the innermost scope to the outermost scope. If no match is found, then Python looks at the global and built-in scopes. If it can\u2019t find the name, then you\u2019ll get an error. Global Keyword Global variables are the ones that are defined and declared outside any function and are not specified to any function. They can be used by any part of the program. We only need to use the global keyword in a function if we want to do assignments or change the global variable. global is not needed for printing and accessing. Python \u201cassumes\u201d that we want a local variable due to the assignment to s inside of f(), so the first statement throws the error message. Any variable which is changed or created inside of a function is local if it hasn\u2019t been declared as a global variable. To tell Python, that we want to use the global variable, we have to use the keyword \u201cglobal\u201d a = 1 # Uses global because there is no local 'a' def f (): print ( 'Inside f() : ' , a ) # Variable 'a' is redefined as a local def g (): a = 2 print ( 'Inside g() : ' , a ) # Uses global keyword to modify global 'a' def h (): global a a = 3 print ( 'Inside h() : ' , a ) # Global scope print ( 'global : ' , a ) f () print ( 'global : ' , a ) g () print ( 'global : ' , a ) h () print ( 'global : ' , a ) global : 1 Inside f() : 1 global : 1 Inside g() : 2 global : 1 Inside h() : 3 global : 3 Nonlocal Keyword In Python, nonlocal keyword is used in the case of nested functions. This keyword works similar to the global, but rather than global, this keyword declares a variable to point to the variable of outside enclosing function, in case of nested functions. # Python program to demonstrate # nonlocal keyword print ( \"Value of a using nonlocal is : \" , end = \"\" ) def outer (): a = 5 def inner (): nonlocal a a = 10 inner () print ( a ) outer () # demonstrating without non local # inner loop not changing the value of outer a # prints 5 print ( \"Value of a without using nonlocal is : \" , end = \"\" ) def outer (): a = 5 def inner (): a = 10 inner () print ( a ) outer () Value of a using nonlocal is : 10 Value of a without using nonlocal is : 5","title":"Scope of Variables"},{"location":"PR/pyVar3/#global-keyword","text":"Global variables are the ones that are defined and declared outside any function and are not specified to any function. They can be used by any part of the program. We only need to use the global keyword in a function if we want to do assignments or change the global variable. global is not needed for printing and accessing. Python \u201cassumes\u201d that we want a local variable due to the assignment to s inside of f(), so the first statement throws the error message. Any variable which is changed or created inside of a function is local if it hasn\u2019t been declared as a global variable. To tell Python, that we want to use the global variable, we have to use the keyword \u201cglobal\u201d a = 1 # Uses global because there is no local 'a' def f (): print ( 'Inside f() : ' , a ) # Variable 'a' is redefined as a local def g (): a = 2 print ( 'Inside g() : ' , a ) # Uses global keyword to modify global 'a' def h (): global a a = 3 print ( 'Inside h() : ' , a ) # Global scope print ( 'global : ' , a ) f () print ( 'global : ' , a ) g () print ( 'global : ' , a ) h () print ( 'global : ' , a ) global : 1 Inside f() : 1 global : 1 Inside g() : 2 global : 1 Inside h() : 3 global : 3","title":"Global Keyword"},{"location":"PR/pyVar3/#nonlocal-keyword","text":"In Python, nonlocal keyword is used in the case of nested functions. This keyword works similar to the global, but rather than global, this keyword declares a variable to point to the variable of outside enclosing function, in case of nested functions. # Python program to demonstrate # nonlocal keyword print ( \"Value of a using nonlocal is : \" , end = \"\" ) def outer (): a = 5 def inner (): nonlocal a a = 10 inner () print ( a ) outer () # demonstrating without non local # inner loop not changing the value of outer a # prints 5 print ( \"Value of a without using nonlocal is : \" , end = \"\" ) def outer (): a = 5 def inner (): a = 10 inner () print ( a ) outer () Value of a using nonlocal is : 10 Value of a without using nonlocal is : 5","title":"Nonlocal Keyword"},{"location":"PR/pyVar4/","text":"del is used in Python to unset a variable or name. You can use it on variable names, but a more common use is to remove indexes from a list or dictionary. my_list1 = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] print ( my_list1 ) # delete second element of my_list1 del my_list1 [ 1 ] print ( my_list1 ) # slice my_list1 from index 3 to 5 del my_list1 [ 3 : 5 ] print ( my_list1 ) [1, 2, 3, 4, 5, 6, 7, 8, 9] [1, 3, 4, 5, 6, 7, 8, 9] [1, 3, 4, 7, 8, 9] my_dict1 = { \"small\" : \"big\" , \"black\" : \"white\" , \"up\" : \"down\" } print ( my_dict1 ) # delete key-value pair with key \"black\" from my_dict1 del my_dict1 [ \"black\" ] print ( my_dict1 ) {'small': 'big', 'black': 'white', 'up': 'down'} {'small': 'big', 'up': 'down'}","title":"del Keyword"},{"location":"PR/pyWhile/","text":"A while loop is used to repeat a block of code multiple times. The while loop is used in cases when the number of iterations is not known and depends on some calculations and conditions in the code block of the loop. To end a while loop prematurely, the break statement can be used. Another statement that can be used within loops is continue. Unlike break, continue jumps back to the top of the loop, rather than stopping it. Basically, the continue statement stops the current iteration and continues with the next one. i = 1 while i <= 5 : print ( i ) i += 1 print ( \"the end\" ) 1 2 3 4 5 the end","title":"While-loops"},{"location":"PR/pyfor/","text":"Looping statements allow for the repeated execution of a section of code. For instance, suppose we wanted to add up all of the integers between zero (0) and ten (10), not including ten. We could, of course, do this in one line, but we could also use a loop to add each integer one at a time. Below is the code for a simple accumulator that accomplishes this: sum = 0 for i in range ( 10 ): sum = sum + i print ( sum ) alternative_sum = 0 + 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 print ( alternative_sum == sum ) 45 True Range function The range () built-in function generates the sequence of values that we loop over, and notice that range(10) does not include 10 itself. In order to output the range as a list, we need to explicitly convert it to a list, using the list() function. If range is called with one argument, it produces an object with values from 0 to that argument. If it is called with two arguments, it produces values from the first to the second. range can have a third argument, which determines the interval of the sequence produced, also called the step. We can also create list of decreasing numbers, using a negative number as the third argument. numbers = list ( range ( 10 )) print ( numbers ) numbers = list ( range ( 5 , 10 )) print ( numbers ) numbers = list ( range ( 5 , 10 , 2 )) print ( numbers ) print ( list ( range ( 20 , 5 , - 2 ))) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] [5, 6, 7, 8, 9] [5, 7, 9] [20, 18, 16, 14, 12, 10, 8, 6] elements in lists In addition to looping over a sequence of integers using the range() function, we can also loop over the elements in a list, which is shown below: ingredients = [ \"flour\" , \"sugar\" , \"eggs\" , \"oil\" , \"baking soda\" ] for ingredient in ingredients : print ( ingredient ) flour sugar eggs oil baking soda Above, the for-loop iterates over the elements of the list ingredients , and within the loop each of those elements is referred to as ingredient . The use of singular/plural nouns to handle this iteration is a common Python motif, but is by no means necessary to use in your own programming. Break and Continue Similar to while loops, the break and continue statements can be used in for loops, to stop the loop or jump to the next iteration. # use the break and continue statements for x in range ( 5 , 10 ): if ( x == 7 ): break if ( x % 2 == 0 ): continue print ( x ) #using the enumerate() function to get index days = [ \"Mon\" , \"Tue\" , \"Wed\" , \"Thu\" , \"Fri\" , \"Sat\" , \"Sun\" ] for i , d in enumerate ( days ): print ( i , d ) 5 0 Mon 1 Tue 2 Wed 3 Thu 4 Fri 5 Sat 6 Sun","title":"For-loops"},{"location":"PR/pyfor/#range-function","text":"The range () built-in function generates the sequence of values that we loop over, and notice that range(10) does not include 10 itself. In order to output the range as a list, we need to explicitly convert it to a list, using the list() function. If range is called with one argument, it produces an object with values from 0 to that argument. If it is called with two arguments, it produces values from the first to the second. range can have a third argument, which determines the interval of the sequence produced, also called the step. We can also create list of decreasing numbers, using a negative number as the third argument. numbers = list ( range ( 10 )) print ( numbers ) numbers = list ( range ( 5 , 10 )) print ( numbers ) numbers = list ( range ( 5 , 10 , 2 )) print ( numbers ) print ( list ( range ( 20 , 5 , - 2 ))) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] [5, 6, 7, 8, 9] [5, 7, 9] [20, 18, 16, 14, 12, 10, 8, 6]","title":"Range function"},{"location":"PR/pyfor/#elements-in-lists","text":"In addition to looping over a sequence of integers using the range() function, we can also loop over the elements in a list, which is shown below: ingredients = [ \"flour\" , \"sugar\" , \"eggs\" , \"oil\" , \"baking soda\" ] for ingredient in ingredients : print ( ingredient ) flour sugar eggs oil baking soda Above, the for-loop iterates over the elements of the list ingredients , and within the loop each of those elements is referred to as ingredient . The use of singular/plural nouns to handle this iteration is a common Python motif, but is by no means necessary to use in your own programming.","title":"elements in lists"},{"location":"PR/pyfor/#break-and-continue","text":"Similar to while loops, the break and continue statements can be used in for loops, to stop the loop or jump to the next iteration. # use the break and continue statements for x in range ( 5 , 10 ): if ( x == 7 ): break if ( x % 2 == 0 ): continue print ( x ) #using the enumerate() function to get index days = [ \"Mon\" , \"Tue\" , \"Wed\" , \"Thu\" , \"Fri\" , \"Sat\" , \"Sun\" ] for i , d in enumerate ( days ): print ( i , d ) 5 0 Mon 1 Tue 2 Wed 3 Thu 4 Fri 5 Sat 6 Sun","title":"Break and Continue"}]}